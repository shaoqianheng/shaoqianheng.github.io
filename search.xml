<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>函数表达式（二）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/06/27/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-2-3-内存泄露"><a href="#1-2-3-内存泄露" class="headerlink" title="1.2.3 内存泄露"></a>1.2.3 内存泄露</h3><p><br>    由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function assignHandler() &#123;</div><div class="line">    var element = document.getElementById(&quot;someElement&quot;);</div><div class="line">    element.onclick = function() &#123;</div><div class="line">        alert(element.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，这个问题可以通过稍微改写一下代码来解决，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function assignHandler() &#123;</div><div class="line">    var element = document.getElementById(&quot;someElement&quot;);</div><div class="line">    var id = element.id;</div><div class="line"></div><div class="line">    element.onclick = function() &#123;</div><div class="line">        alert(id);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    element = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄露的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。<br></p><h3 id="1-3-模仿块级作用域"><a href="#1-3-模仿块级作用域" class="headerlink" title="1.3 模仿块级作用域"></a>1.3 模仿块级作用域</h3><p><br>    如前所述，JavaScript没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的，来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count) &#123;</div><div class="line">    for(var i = 0; i &lt; count; i++) &#123;</div><div class="line">        alert(i);</div><div class="line">    &#125; </div><div class="line">    alert(i);    // 计数</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个函数中定义了一个for循环，而变量i的初始值被设置为0.在Java、C++等语言中，变量i只会在for循环的语句块中有定义，循环一旦结束，变量i就会被销毁。可是在JavaScript中，变量i是定义在outputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即使像下面这样错误地重新声明同一个变量，也不会改变它的值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count) &#123;</div><div class="line">    for(var i = 0; i &lt; count; i++) &#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;</div><div class="line">    var i;    // 重新声明变量</div><div class="line">    alert(i); // 计数</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见(不过，它会执行后续声明中的变量初始化)。匿名函数可以用来模仿块级作用域并避免这个问题。<br></p><p><br>    用做块级作用域(通常称为私有作用域)的匿名函数的语法如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p><br>    以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。如果感觉这种语法不太好理解，可以再看看下面这个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var count = 5;</div><div class="line">outputNumber(count);</div></pre></td></tr></table></figure><p><br>    这里初始化了变量count，将其值设置为5.当然，这里的变量是没有必要的，因为可以把值直接传给函数。为了让代码更简洁，我们在调用函数时用5来代替变量count，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">outputNumber(5);</div></pre></td></tr></table></figure><p><br>    这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。再看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var someFuntion = function() &#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;; </div><div class="line">someFunction();</div></pre></td></tr></table></figure><p><br>    这个例子先定义了一个函数，然后立即调用了它。定义函数的方式是创建一个匿名函数，并把匿名函数赋值给变量someFunction。而调用函数的方式是在函数名称后面添加一对圆括号，即someFunction()。通过前面的例子我们知道，可以使用实际的值来取代变量count，那在这里是不是也可以用函数的值来取代函数名呢？然后，下面的代码却会导致错误。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function() &#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;();    // 出错！</div></pre></td></tr></table></figure><p><br>    这段代码会导致语法错误，是因为JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，只要像下面这样给它加上一对圆括号即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    // 这里是块级作用域</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p><br>    无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function outputNumbers(count) &#123;</div><div class="line">    (function() &#123;</div><div class="line">        for(var i = 0; i &lt; count; i++) &#123;</div><div class="line">            alert(i);</div><div class="line">        &#125; </div><div class="line">    &#125;)();</div><div class="line">    alert(i);    // 导致一个错误！</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个重写的outputNumbers()函数中，我们在for循环外部插入了一个私有作用域。在匿名函数中定义的任何变量，都会在执行结束时被销毁。因此，变量i只能在循环中使用，使用后立即被销毁。而在私有作用域中能够访问变量count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。<br></p><p><br>    这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    var now = new Date();</div><div class="line">    if(now.getMonth() == 0 &amp;&amp; now.getDate() == 1) &#123;</div><div class="line">        alert(&quot;Happy new year!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p><br>    把上面这段代码放在全局作用域中，可以用来确定哪一天是1月1日；如果到了这一天，就会向用户显示一条祝贺新年的信息。其中的变量now现在是匿名函数中的局部变量，而我们不必在全局作用域中创建它。<br></p><blockquote><p>这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p></blockquote><h3 id="1-4-私有变量"><a href="#1-4-私有变量" class="headerlink" title="1.4 私有变量"></a>1.4 私有变量</h3><p><br>    严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包含函数的参数、局部变量和在函数内部定义的其他函数。来看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function add(num1, num2) &#123;</div><div class="line">    var sum = num1 + num2;</div><div class="line">    return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个函数内部，有3个私有变量：num1、num2和sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。<br></p><p><br>    我们把有权访问私有变量和私有函数的公有方法称为特权方法(privileged method).有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function MyObject() &#123;</div><div class="line">    // 私有变量和私有函数</div><div class="line">    var privateVariable = 10;</div><div class="line"></div><div class="line">    function privateFunction() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    // 特权方法</div><div class="line">    this.publicMethod = function() &#123;</div><div class="line">        privateVariable++;</div><div class="line">        return privateFunction();</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。对这个例子而言，变量privateVariable和函数privateFunction()只能通过特权方法publicMethod()来访问。在创建MyObject的实例后，除了使用publicMethod()这一个途径外，没有任何办法可以直接访问privateVariable和privateFunction().<br></p><p><br>    利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.getName = function() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;;</div><div class="line">    this.setName = function(value) &#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125; </div><div class="line"></div><div class="line">var person = new Person(&quot;Nicholas&quot;);</div><div class="line">alert(person.getName());    // &quot;Nicholas&quot;</div><div class="line">person.setName(&quot;Greg&quot;);</div><div class="line">alert(person.getName());    // &quot;Greg&quot;</div></pre></td></tr></table></figure><p><br>    以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。由于这两个方法是在构造函数内部定义的，它们作为闭包能够通过作用域链访问name。私有变量name在Person的每一个实例中都不相同，因为每次调用构造函数都会重新创建这两个方法。不过，在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。之前说过，构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。<br></p><h3 id="1-4-1-静态私有变量"><a href="#1-4-1-静态私有变量" class="headerlink" title="1.4.1 静态私有变量"></a>1.4.1 静态私有变量</h3><p><br>    通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    // 私有变量和私有函数</div><div class="line">    var privateVariable = 10;</div><div class="line"></div><div class="line">    function privateFunction() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 构造函数</div><div class="line">    MyObject = function() &#123;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    // 公有/特权方法</div><div class="line">    MyObject.prototype.publicMethod = function() &#123;</div><div class="line">        privateVariable++;</div><div class="line">        return privateFunction();</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p><br>    这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject时使用var关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但也要知道，在严格模式下给未声明的变量赋值会导致错误。<br></p><p><br>    这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。来看一看下面的代码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    var name = &quot;&quot;;</div><div class="line"></div><div class="line">    Person = function(value) &#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">    Person.prototype.getName = function() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;;</div><div class="line">    Person.prototype.setName = function(value) &#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;);</div><div class="line">alert(person1.getName());    // &quot;Nicholas&quot;</div><div class="line">person1.setName(&quot;Greg&quot;);</div><div class="line">alert(person1.getName());    // &quot;Greg&quot;</div><div class="line"></div><div class="line">var person2 = new Person(&quot;Michael&quot;);</div><div class="line">alert(person1.getName());    // &quot;Michael&quot;</div><div class="line">alert(person2.getName());    // &quot;Michael&quot;</div></pre></td></tr></table></figure><p><br>    这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或新建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。<br></p><p><br>    以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。<br></p><blockquote><p>多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个明显的不足之处。</p></blockquote><h3 id="1-4-2-模块模式"><a href="#1-4-2-模块模式" class="headerlink" title="1.4.2 模块模式"></a>1.4.2 模块模式</h3><p><br>    前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式(module pattern)则是为单例创建私有变量和特权方法。所谓单例(singleton)，指的就是只有一个实例的对象。按照惯例，JavaScript是以对象字面量的方式来创建单例对象的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var singleton = &#123;</div><div class="line">    name: value,</div><div class="line">    method: function() &#123;</div><div class="line">        // 这里是方法的代码</div><div class="line">    &#125; </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var singleton = function() &#123;</div><div class="line">    // 私有变量和私有函数</div><div class="line">    var privateVariable = 10;</div><div class="line"></div><div class="line">    function privateFunction() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 特权/公有方法和属性</div><div class="line">    return &#123;</div><div class="line">        publicProperty: true,</div><div class="line">        publicMethod: function() &#123;</div><div class="line">            privateVariable++;</div><div class="line">            return privateFunction();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p><br>    这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中值只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var application = function() &#123;</div><div class="line">    // 私有变量和函数</div><div class="line">    var components = new Array();</div><div class="line">    // 初始化</div><div class="line">    components.push(new BaseComponent());</div><div class="line"></div><div class="line">    // 公共</div><div class="line">    return &#123;</div><div class="line">        getComponentCount: function() &#123;</div><div class="line">            return components.length;</div><div class="line">        &#125;,</div><div class="line">        registerComponent: function(component) &#123;</div><div class="line">            if(typeof component == &quot;object&quot;) &#123;</div><div class="line">                components.push(component);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p><br>    在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例(在这里不需要关心BaseComponents的代码，我们只是用它来展示初始化操作)。而返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件的数组，后者用于注册新组件。<br></p><p><br>    简而言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。<br></p><h3 id="1-4-3-增强的模块模式"><a href="#1-4-3-增强的模块模式" class="headerlink" title="1.4.3 增强的模块模式"></a>1.4.3 增强的模块模式</h3><p><br>    有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和(或)方法对其加以增强的情况。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var singleton = function() &#123;</div><div class="line">    // 私有变量和私有函数</div><div class="line">    var privateVariable = 10;</div><div class="line"></div><div class="line">    function privateFunction() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 创建对象</div><div class="line">    var object = new CustomType();</div><div class="line"></div><div class="line">    // 添加特权/公有属性和方法</div><div class="line">    object.publicProperty = true;</div><div class="line"></div><div class="line">    object.publicMethod = function() &#123;</div><div class="line">        privateVariable++;</div><div class="line">        return privateFunction();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // 返回这个对象</div><div class="line">    return object;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p><br>    如果前面演示模块模式的例子中application对象必须是BaseComponent的实例，那么就可以使用以下代码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var application = function() &#123;</div><div class="line">    // 私有变量和函数</div><div class="line">    var components = new Array();</div><div class="line"></div><div class="line">    // 初始化</div><div class="line">    components.push(new BaseComponent());</div><div class="line"></div><div class="line">    // 创建application的一个局部副本</div><div class="line">    var app = new BaseComponent();</div><div class="line"></div><div class="line">    // 公共接口</div><div class="line">    app.getComponentCount = function() &#123;</div><div class="line">        return components.length;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    app.registerComponent = function(component) &#123;</div><div class="line">        if(typeof component == &quot;object&quot;) &#123;</div><div class="line">            components.push(component);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    // 返回这个副本</div><div class="line">    return app;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p><br>    在这个重写后的应用程序(application)单例中，首先也是像前面例子中一样定义了私有变量。主要的不同之处在于命名变量app的创建过程，因为它必须是BaseComponent的实例。这个实例实际上是application对象的局部变量版。此后，我们又为app对象添加了能够访问私有变量的公有方法。最后一步是返回app对象，结果仍然是将它赋值给全局变量application。<br></p><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p><br>    在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1) 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。</div><div class="line">(2) 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂。</div><div class="line">(3) 递归函数应该始终使用argument.callee来递归地调用自身，不要使用匿名函数——函数名可能会发生变化。</div></pre></td></tr></table></figure><p><br>    当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1) 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。</div><div class="line">(2) 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。</div><div class="line">(3) 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。</div></pre></td></tr></table></figure><p><br>    使用闭包可以在JavaScript中模仿块级作用域(JavaScript本身没有块级作用域的概念),要点如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1) 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。</div><div class="line">(2) 结果就是函数内部的所有变量都会被销毁——除非将某些变量赋值给了包含作用域(即外部作用域)中的变量。</div></pre></td></tr></table></figure><p><br>    闭包还可以用于在对象中创建私有变量，相关概念和要点如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1) 即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。</div><div class="line">(2) 有权访问私有变量的公有方法叫做特权方法。</div><div class="line">(3) 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。</div></pre></td></tr></table></figure><blockquote><p>JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Window对象(二)</title>
      <link href="/2018/06/27/window%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/"/>
      <url>/2018/06/27/window%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-1-计时器"><a href="#1-1-计时器" class="headerlink" title="1.1 计时器"></a>1.1 计时器</h3>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>变量、作用域和内存变量（一）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/27/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>按照ECMA-262的定义，JavaScript的变量与其他语言的变量有很大区别。JavaScript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但JavaScript变量实际的复杂程度还远不止如此。</p></blockquote><h3 id="1-1-基本类型和引用类型的值"><a href="#1-1-基本类型和引用类型的值" class="headerlink" title="1.1 基本类型和引用类型的值"></a>1.1 基本类型和引用类型的值</h3><p><br>    ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。<br></p><p><br>    在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br></p><p><br>    引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。(这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象)<br></p><blockquote><p>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。</p></blockquote><h3 id="1-1-1-动态的属性"><a href="#1-1-1-动态的属性" class="headerlink" title="1.1.1 动态的属性"></a>1.1.1 动态的属性</h3><p><br>    定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">alert(person.name);// &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    以上代码创建了一个对象并将其保存在了变量person中。然后，我们为该对象添加了一个名为name的属性，并将字符串值“Nicholas”赋给了这个属性。紧接着，又通过alert()函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。<br></p><p><br>    但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name = &quot;Nicholas&quot;;</div><div class="line">name.age = 27;</div><div class="line">alert(name.age);// undefined</div></pre></td></tr></table></figure><p><br>    在这个例子中，我们为字符串name定义了一个名为age的属性，并为该属性赋值27.但在下一行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。<br></p><h3 id="1-1-2-复制变量值"><a href="#1-1-2-复制变量值" class="headerlink" title="1.1.2 复制变量值"></a>1.1.2 复制变量值</h3><p><br>    除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。来看一个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num1 = 5;</div><div class="line">var num2 = num1;</div></pre></td></tr></table></figure><p><br>    在此，num1中保存的值是5。当使用num1的值来初始化num2时，num2中也保存了值5.但num2中的5与num1中的5是完全独立的，该值只是num1中5的一个副本。此后，这个变量可以参与任何操作而不会相互影响。图1-1形象地真是了赋值基本类型值的过程。<br></p><p><img src="https://shaoqianheng.github.io/images/h-4-1.png"></p><div style="text-align: center;">图1-1 复制基本类型值的过程</div><p><br>    当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj1 = new Object();</div><div class="line">var obj2 = obj1;</div><div class="line">obj1.name = &quot;Nicholas&quot;;</div><div class="line">alert(obj2.name);// &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了obj2中，换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加name属性后，可以通过obj2来访问这个属性，因为这两个变量引用的都是同一个对象。图1-2展示了保存在变量对象中的变量和保存在堆中的对象之间的这种关系。<br></p><p><img src="https://shaoqianheng.github.io/images/h-4-2.png"></p><div style="text-align: center;">图1-2 复制引用类型值的过程</div><h3 id="1-1-3-传递参数"><a href="#1-1-3-传递参数" class="headerlink" title="1.1.3 传递参数"></a>1.1.3 传递参数</h3><p><br>    ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。<br></p><p><br>    在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素)。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面这个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function addTen (num) &#123;</div><div class="line">    num += 10;</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line">var count = 20;</div><div class="line">var result = addTen(count);</div><div class="line">alert(count);// 20, 没有变化</div><div class="line">alert(result);// 30</div></pre></td></tr></table></figure><p><br>    这里的函数addTen()有一个参数num，而参数实际上是函数的局部变量。在调用这个函数时，变量count作为参数被传递给函数，这个变量的值是20.于是，数值20被复制给参数num以便在addTen()中使用。在函数内部，参数num的值被加上了10，但这一变化不会影响函数外部的count变量。参数num与变量count互不相识，它们仅仅是具有相同的值。假如num是按引用传递的话，那么变量count的值也将变成30，从而反映函数内部的修改。当然，使用数值等基本类型值来说明按值传递参数比较简单，但如果使用对象，那问题就不好理解了。再举一个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function setName (obj) &#123;</div><div class="line">    obj.name = &quot;Nicholas&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);// &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    以上代码中创建一个对象，并将其保存在了变量person中。然后，这个变量被传递到setName()函数中之后就被复制给了obj。在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象。于是，当在函数内部为obj添加name属性后，函数外部的person也将有所反映；因为person所指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setName (obj) &#123;</div><div class="line">    obj.name = &quot;Nickolas&quot;;</div><div class="line">    obj = new Object();</div><div class="line">    obj.name = &quot;Greg&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);// &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    这个例子与前一个例子的唯一区别，就是在setName()函数中添加了两行代码：一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给setName()后，其name属性被设置为“Nicholas”。然后，又将一个新对象赋给变量obj，同时将其name属性设置为“Greg”。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为“Greg”的新对象。但是，当接下来再访问person.name时，显示的值仍然是“Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。<br></p><blockquote><p>可以把ECMAScript函数的参数想象成局部变量。</p></blockquote><h3 id="1-1-4-检测类型"><a href="#1-1-4-检测类型" class="headerlink" title="1.1.4 检测类型"></a>1.1.4 检测类型</h3><p><br>    要检测一个变量是不是基本数据类型？typeof操作符是最佳的工具。说得更具体一点，typeof操作符是确定一个变量是字符串、数值、布尔值、还是undefined的最佳工具。如果变量的值是一个对象或null，则typeof操作符会像下面例子中所示的那样返回“object”：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var s = &quot;Nicholas&quot;;</div><div class="line">var b = true;</div><div class="line">var i = 22;</div><div class="line">var u;</div><div class="line">var n = null;</div><div class="line">var o = new Object();</div><div class="line"></div><div class="line">alert(typeof s);// &quot;string&quot;</div><div class="line">alert(typeof i);// &quot;number&quot;</div><div class="line">alert(typeof b);// &quot;boolean&quot;</div><div class="line">alert(typeof u);// &quot;undefined&quot;</div><div class="line">alert(typeof n);// &quot;object&quot;</div><div class="line">alert(typeof o);// &quot;object&quot;</div></pre></td></tr></table></figure><p><br>    虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符，其语法如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = variable instanceof constructor</div></pre></td></tr></table></figure><p><br>    如果变量是给定引用类型(根据它的原型链来识别)的实例，那么instanceof操作符就会返回true。请看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(person instanceof Object);// 变量person是Object吗？</div><div class="line">alert(colors instanceof Array);// 变量colors是Array吗？</div><div class="line">alert(pattern instanceof RegExp);// 变量pattern是RegExp吗？</div></pre></td></tr></table></figure><p><br>    根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。<br></p><blockquote><p>使用typeof操作符检测函数时，该操作符会返回“function”。在Safari 5及之前版本和Chrome 7及之前版本中使用typeof检测正则表达式时，由于规范的原因，这个操作符也返回“function”。ECMA-262规定任何在内部实现[[Call]]方法的对象都应该在应用typeof操作符时返回“function”。由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回“function”。在IE和Firefox中，对正则表达式应用typeof会返回“object”。</p></blockquote><h3 id="1-2-执行环境及作用域"><a href="#1-2-执行环境及作用域" class="headerlink" title="1.2 执行环境及作用域"></a>1.2 执行环境及作用域</h3><p><br>    执行环境(execution context, 为简单起见，有时也称为“环境”)是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<br></p><p><br>    全局执行环境是最外层的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁)。<br></p><p><br>    每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。<br></p><p><br>    当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象在最开始时只包含一个变量。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。<br></p><p><br>    标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止(如果找不到标识符，通常会导致错误发生)。请看下面的示例代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line">function changeColor () &#123;</div><div class="line">    if (color === &quot;blue&quot;) &#123;</div><div class="line">        color = &quot;red&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">        color = &quot;blue&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeColor();</div><div class="line">alert(&quot;Color is now &quot; + color);</div></pre></td></tr></table></figure><p><br>    在这个简单的例子中，函数changeColor()的作用域链包含两个对象：它自己的变量对象(其中定义着arguments对象)和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。<br></p><p><br>    此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function changeColor () &#123;</div><div class="line">var anotherColor = &quot;red&quot;;</div><div class="line">function swapColors () &#123;</div><div class="line">var tempColor = anotherColor;</div><div class="line">anotherColor = color;</div><div class="line">color = tempColor;</div><div class="line">// 这里可以访问color、anotherColor和tempColor</div><div class="line">&#125;</div><div class="line">// 这里可以访问color和anotherColor，但不能访问tempColor</div><div class="line">swapColors();</div><div class="line">&#125;</div><div class="line">// 这里只能访问color</div><div class="line">changeColor();</div></pre></td></tr></table></figure><p><br>    以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。全局环境中有一个变量和一个函数changeColor()。changeColor()的局部环境中有一个名为anotherColor的变量和一个名为swapColors()的函数，但它也可以访问全局环境中的变量color。swapColors()的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到。无论全局环境还是changeColor()的局部环境都无权访问tempColor。然而，在swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境都是它的父执行环境。图1-3形象地展示了前面这个例子的作用域链。<br></p><p><img src="https://shaoqianheng.github.io/images/h-4-3.png"></p><div style="text-align: center;">图1-3</div><p><br>    图1-3中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的swapColors()而言，其作用域链中包含3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问swapColors()的环境。<br></p><blockquote><p>函数参数也被当做变量来对待，因此其访问规则与执行环境中的其他变量相同。</p></blockquote><h3 id="1-2-1-延长作用域链"><a href="#1-2-1-延长作用域链" class="headerlink" title="1.2.1 延长作用域链"></a>1.2.1 延长作用域链</h3><p><br>    虽然执行环境的类型总共只有两种——全局和局部(函数),但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a) try-catch语句的catch块；</div><div class="line">b) with语句。</div></pre></td></tr></table></figure><p><br>    这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。下面看一个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function buildUrl () &#123;</div><div class="line">    var qs = &quot;?debug=true&quot;;</div><div class="line">    with(location) &#123;</div><div class="line">        var url = href + qs;</div><div class="line">    &#125;</div><div class="line">    return url;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在此，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量qs。当在with语句中引用变量href时(实际引用的是location.href)，可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。<br></p><blockquote><p>在IE8及之前版本的JavaScript实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。</p></blockquote><h3 id="1-2-2-没有块级作用域"><a href="#1-2-2-没有块级作用域" class="headerlink" title="1.2.2 没有块级作用域"></a>1.2.2 没有块级作用域</h3><p><br>    JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码块都有自己的作用域(如果用ECMAScript的话来讲，就是它们自己的执行环境)，因而支持根据条件来定义变量。例如，下面的代码在JavaScript中并不会得到想象中的结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    var color = &quot;blue&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(color);// &quot;blue&quot;</div></pre></td></tr></table></figure><p><br>    这里实在一个if语句中定义了变量color。如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境(在这里是全局环境)中。在使用for语句时尤其要牢记这一差异，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i);// 10</div></pre></td></tr></table></figure><p><br>    对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。<br></p><h3 id="1、声明变量"><a href="#1、声明变量" class="headerlink" title="1、声明变量"></a>1、声明变量</h3><p><br>    使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add (num1, num2) &#123;</div><div class="line">    var sum = num1 + num2;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">var result = add(10, 20);// 30</div><div class="line">alert(sum);// 由于sum不是有效的变量，因此会导致错误</div></pre></td></tr></table></figure><p><br>    以上代码中的函数add()定义了一个名为sum的局部变量，该变量包含加法操作的结果。虽然结果值从函数中返回了，但变量sum在函数外部是访问不到的。如果省略这个例子中的var关键字，那么当add()执行完毕后，sum也将可以访问到：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add (num1, num2) &#123;</div><div class="line">    sum = num1 + num2;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">var result = add(10, 20);// 30</div><div class="line">alert(sum);// 30</div></pre></td></tr></table></figure><p><br>    这个例子中的变量sum在被初始化赋值时没有使用var关键字。于是，当调用完add()之后，添加到全局环境中的变量sum将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。<br></p><blockquote><p>在编写JavaScript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。</p></blockquote><h3 id="2、查询标识符"><a href="#2、查询标识符" class="headerlink" title="2、查询标识符"></a>2、查询标识符</h3><p><br>    当在某个环境中为了读取或写入而引用一个标识符，必须通过搜索来确定标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。<br></p><p><br>    通过下面这个示例，可以理解查询标识符的过程：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function getColor () &#123;</div><div class="line">    return color;    </div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor());// &quot;blue&quot;</div></pre></td></tr></table></figure><p><br>    调用本例中的函数getColor()时会引用变量color。为了确定变量color的值，将开始一个两步的搜索过程。首先，搜索getColor()的变量对象，查找其中是否包含一个名为color的标识符。在没有找到的情况下，搜索继续到下一个变量对象(全局环境的变量对象)，然后在那里找到了名为color的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。图1-4形象地展示了上述搜索过程。<br></p><p><img src="https://shaoqianheng.github.io/images/h-4-4.png"></p><div style="text-align: center;">图1-4</div><p><br>    在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，如下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function getColor () &#123;</div><div class="line">var color = &quot;red&quot;;</div><div class="line">return color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor());// &quot;red&quot;</div></pre></td></tr></table></figure><p><br>    修改后的代码在getColor()函数中声明了一个名为color的局部变量。调用函数时，该变量就会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量color的值。搜索过程首先从局部环境中开始，而且在这里发现了一个名为color的变量，其值为“red”。因为变量已经找到了，所以搜索即行停止，return语句就使用这个局部变量，并为函数会返回“red”。也就是说，任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。<br></p><blockquote><p>变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BOM（一）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/BOM%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/27/BOM%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>ECMAScript是JavaScript的核心，但如果要在Web中使用JavaScript，那么BOM(浏览器对象模型)则无疑才是真正的核心。BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。多年来，缺少事实上的规范导致BOM既有意思又有问题，因为浏览器提供商会按照各自的想法随意去扩展它。于是，浏览器之间公有的对象就成为了事实上的标准。这些对象在浏览器中得以存在，很大程度上是由于它们提供了与浏览器的互操作性。W3C为了把浏览器中JavaScript最基本的部分标准化，已经将BOM的主要方面纳入了HTML5的规范中。</p></blockquote><h3 id="1-1-window对象"><a href="#1-1-window对象" class="headerlink" title="1.1 window对象"></a>1.1 window对象</h3><p><br>    BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。<br></p><h3 id="1-1-1-全局作用域"><a href="#1-1-1-全局作用域" class="headerlink" title="1.1.1 全局作用域"></a>1.1.1 全局作用域</h3><p><br>    由于window对象同时扮演着ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var age = 29;</div><div class="line">function sayAge() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125; </div><div class="line"></div><div class="line">alert(window.age);    // 29</div><div class="line">sayAge();             // 29</div><div class="line">window.sayAge();      // 29</div></pre></td></tr></table></figure><p><br>    我们在全局作用域中定义了一个变量age和一个函数sayAge()，它们被自动归在了window对象名下。于是，可以通过window.age访问变量age，可以通过window.sayAge()访问函数sayAge().由于sayAge()存在于全局作用域中，因此，this.age被映射到window.age,最终显示的仍然是正确的结果。<br></p><p><br>    抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var age = 29;</div><div class="line">window.color = &quot;red&quot;;</div><div class="line"></div><div class="line">// 在IE&lt;9时抛出错误，在其他所有浏览器中都返回false</div><div class="line">delete window.age;</div><div class="line"></div><div class="line">// 在IE&lt;9时抛出错误，在其他所有浏览器中都返回true</div><div class="line">delete window.color;    // return true</div><div class="line"></div><div class="line">alert(window.age);    // 29</div><div class="line">alert(window.color);  // undefined</div></pre></td></tr></table></figure><p><br>    刚才使用var语句添加的window属性有一个名为[[Configurable]]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除。IE8及更早版本在遇到使用delete删除window属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9及更高版本不会抛出错误。<br></p><p><br>    另外，还要记住一件事：尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 这里会抛出错误，因为oldValue未定义</div><div class="line">var newValue = oldValue;</div><div class="line"></div><div class="line">// 这里不会抛出错误，因为这是一次属性查询</div><div class="line">// newValue的值是undefined</div><div class="line">var newValue = window.oldValue;</div></pre></td></tr></table></figure><p><br>    后面将要讨论的很多全局JavaScript对象(如location和navigator)实际上都是window对象的属性。<br></p><h3 id="1-1-2-窗口关系及框架"><a href="#1-1-2-窗口关系及框架" class="headerlink" title="1.1.2 窗口关系及框架"></a>1.1.2 窗口关系及框架</h3><p><br>    如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引(从0开始，从左至右，从上到下)或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称。下面是一个包含框架的页面：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">    &lt;title&gt;Frameset Example&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;frameset rows=&quot;160, *&quot;&gt;</div><div class="line">    &lt;frame src=&quot;frame.htm&quot; name=&quot;topFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">    &lt;frameset cols=&quot;50%, 50%&quot;&gt;</div><div class="line">    &lt;frame src=&quot;anotherframe.htm&quot; name=&quot;leftFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">    &lt;frame src=&quot;yetAnotherframe.htm&quot; name=&quot;rightFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">    &lt;/frameset&gt;</div><div class="line">    &lt;/frameset&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><br>    以上代码创建了一个框架集，其中一个框架居上，两个框架居下。对这个例子而言，可以通过window.frames[0]或者window.frames[“topFrame”]来引用上方的框架。不过，恐怕你最好使用top而非window来引用这些框架(例如，通过top.frames[0]).<br></p><p><br>    我们知道，top对象始终指向最高(最外)层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。图1-1展示了在最高层窗口中，通过代码来访问前面例子中每个框架的不同方式。<br></p><p><img src="https://shaoqianheng.github.io/images/h-8-1.png"></p><div style="text-align: center;">图1-1</div><p><br>    与top相对的另一个window对象是parent。顾名思义，parent(父)对象始终指向当前框架的直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于top(此时它们都等于window)。再看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">    &lt;title&gt;</div><div class="line">    Frameset Example</div><div class="line">    &lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;frameset rows=&quot;100, *&quot;&gt;</div><div class="line">    &lt;frame src=&quot;frame.htm&quot; name=&quot;topFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">    &lt;frameset cols=&quot;50%,50%&quot;&gt;</div><div class="line">        &lt;frame src=&quot;anotherframe.htm&quot; name=&quot;leftFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">        // 包含另一个框架集</div><div class="line">        &lt;frame src=&quot;anotherframeset.htm&quot; name=&quot;rightFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">    &lt;/frameset&gt;</div><div class="line">    &lt;/frameset&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><br>    这个框架集中的一个框架包含了另一个框架集，该框架集的代码如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;Frameset Example&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;frameset cols=&quot;50%, 50%&quot;&gt;</div><div class="line">        &lt;frame src=&quot;red.htm&quot; name=&quot;redFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">        &lt;frame src=&quot;blue.htm&quot; name=&quot;blueFrame&quot;&gt;&lt;/frame&gt;</div><div class="line">    &lt;/frameset&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><br>    浏览器在加载完第一个框架集之后，会继续将第二个框架集加载到rightFrame中。如果代码位于redFrame(或blueFrame)中，那么parent对象指向的就是rightFrame。可是，如果代码位于topFrame中，则parent指的是top，因为topFrame的直接上层框架就是最外层框架。图1-2展示了在将前面例子加载到浏览器之后，不同window对象的值。<br></p><p><img src="https://shaoqianheng.github.io/images/h-8-2.png"></p><div style="text-align: center;">图1-2</div><p><br>    注意，除非最高层窗口是通过window.open()打开的，否则其window对象的name属性不会包含任何值。<br></p><p><br>    与框架有关的最后一个对象是self，它始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对应起来，因此它不格外包含其他值。<br></p><p><br>    所有这些对象都是window对象的属性，可以通过window.parent、window.top等形式来访问。同时，这也意味着可以将不同层次的window对象连缀起来，例如window.parent.parent.frames[0].<br></p><blockquote><p>在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用instanceof操作符。</p></blockquote><h3 id="1-1-3-窗口位置"><a href="#1-1-3-窗口位置" class="headerlink" title="1.1.3 窗口位置"></a>1.1.3 窗口位置</h3><p><br>    用来确定和修改window对象位置的属性和方法有很多。IE、Safari、Opera和Chrome都提供了screenLeft和screenTop，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口信息，Safari和Chrome也同时支持这两个属性。Opera虽然也支持screenX和screenY属性，但与screenLeft和screenTop属性并不对应，因此建议大家不要在Opera中使用它们。使用下列代码可以跨浏览器取得窗口左边和上边的位置。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var leftPos = (typeof window.screenLeft == &quot;number&quot;) ?</div><div class="line">                  window.screenLeft : window.screenX;</div><div class="line"></div><div class="line">var topPos = (typeof window.screenTop == &quot;number&quot;) ?</div><div class="line">                 window.screenTop : window.screenY;</div></pre></td></tr></table></figure><p><br>    这个例子运用二元操作符首先确定screenLeft和screenTop属性是否存在，如果是(在IE、Safari、Opera和Chrome中)则取得这两个属性的值。如果不存在(在Firefox中)，则取得screenX和screenY的值。<br></p><p><br>    在使用这些值的过程中，还必须注意一些小问题。在IE、Opera中，screenLeft和screenTop中保存的是从屏幕左边和上边到由window对象表示的页面可见区域的距离。换句话说，如果window对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y轴坐标为0，那么screenTop的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是在Chrome、Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0.<br></p><p><br>    更让人捉摸不透是，Firefox、Safari和Chrome始终返回页面中每个框架的top.screenX和top.screenY值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window对象使用的screenX和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐标值。<br></p><p><br>    最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而，使用moveTo()和moveBy()方法到是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。下面来看几个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 将窗口移动到屏幕左上角</div><div class="line">window.moveTo(0,0);</div><div class="line"></div><div class="line">// 将窗口向下移动100像素</div><div class="line">window.moveBy(0, 100);</div><div class="line"></div><div class="line">// 将窗口移动到(200, 300)</div><div class="line">window.moveTo(200, 300);</div><div class="line"></div><div class="line">// 将窗口向左移动50像素</div><div class="line">window.moveBy(-50, 0);</div></pre></td></tr></table></figure><p><br>    需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera和IE7(及更高版本)中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window对象使用。<br></p><h3 id="1-1-4-窗口大小"><a href="#1-1-4-窗口大小" class="headerlink" title="1.1.4 窗口大小"></a>1.1.4 窗口大小</h3><p><br>    跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera和Chrome均为此提供了4个属性：innerWidth、innerHeight、outerWidth和outerHeight。在IE9+、Safari和Firefox中，outWidth和outerHeight返回浏览器窗口本身的尺寸(无论是从最外层的window对象还是从某个框架访问)。在Opera中，这两个属性的值表示页面视图容器的大小。而innerWidth和innerHeight则表示该容器中页面视图区的大小(减去边框宽度)。在Chrome中，outerWidth、outerHeight与innerWidth、innerHeight返回相同的值，即视口(viewport)大小而非浏览器窗口大小。<br></p><p><br>    IE8及更早版本没有提供取得当前浏览器窗口的尺寸的属性；不过，它通过DOM提供了页面可见区域的相关信息。<br></p><p><br>    在IE、Firefox、Safari、Opera和Chrome中，document.documentElement.clientWidth和document.documentElement.clientHeight中保存了页面视口的信息。在IE6中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth和document.body.clientHeight取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body中的clientWidth和clientHeight属性，都可以取得视口的大小。<br></p><p><br>    虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var pageWidth = window.innerWidth,</div><div class="line">    pageHeight = window.innerHeight;</div><div class="line"></div><div class="line">if(typeof pageWidth != &quot;number&quot;) &#123;</div><div class="line">    pageWidth = document.documentELement.clientWidth;</div><div class="line">    pageHeight = document.documentElement.clientHeight;</div><div class="line">&#125; else &#123;</div><div class="line">    pageWidth = document.body.clientWidth;</div><div class="line">    pageHeight = document.body.clientHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在以上代码中，我们首先将window.innerWidth和window.innerHeight的值分别赋给了pageWidth和pageHeight。然后检查pageWidth中保存的是不是一个数值；如果不是，则通过检查document.compatMode来确定页面是否处于标准模式。如果是，则分别使用document.documentElement.clientWidth和document.documentElement.clientHeight的值。否则，就使用document.body.clientWidth和document.body.clientHeight的值。<br></p><p><br>    对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小。移动IE浏览器不支持这些属性，但通过document.documentElement.clientWidht和document.documentElement.clientHeight提供了相同的信息。随着页面的缩放，这些值也会相应变化。<br></p><p><br>    在其他移动浏览器中，document.documentElement度量的是布局视口，即渲染后页面的实际大小(与可见视口不同，可见视口只是整个页面的一小部分)。移动IE浏览器把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight中。这些值不会随着页面缩放变化。<br></p><p><br>    由于与桌面浏览器间存在这些差异，最好是先检测一下用户是否在使用移动设备，然后再决定使用哪个属性。<br></p><p><br>    另外，使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。这两个方法都接收两个参数，其中resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽度和高度之差。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 调整到100 * 100</div><div class="line">window.resizeTo(100, 100);</div><div class="line"></div><div class="line">// 调整到200 * 150</div><div class="line">window.resizeBy(100, 50);</div><div class="line"></div><div class="line">// 调整到300 * 300</div><div class="line">window.resizeTo(300, 300);</div></pre></td></tr></table></figure><p><br>    需要注意的是，这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在Opera和IE7(及更高版本)中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window对象使用。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的程序设计（三）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/06/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-2-4-组合使用构造函数模式和原型模式"><a href="#1-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="1.2.4 组合使用构造函数模式和原型模式"></a>1.2.4 组合使用构造函数模式和原型模式</h3><p><br>    创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line"> constructor: Person,</div><div class="line"> sayName: function() &#123;</div><div class="line">  alert(this.name);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div><div class="line"></div><div class="line">person1.friends.push(&quot;Van&quot;);</div><div class="line">alert(person1.friends);    // &quot;Shelby, Count, Van&quot;</div><div class="line">alert(person2.friends);    // &quot;Shelby, Count&quot;</div><div class="line">alert(person1.friends === person2.friends);    // false</div><div class="line">alert(person1.sayName === person2.sayName);    // true</div></pre></td></tr></table></figure><p><br>    在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。而修改了person1.friends(向其中添加一个新字符串)，并不会影响到person2.friends，因为它们分别引用了不同的数组。<br></p><p><br>    这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。<br></p><h3 id="1-2-5-动态原型模式"><a href="#1-2-5-动态原型模式" class="headerlink" title="1.2.5 动态原型模式"></a>1.2.5 动态原型模式</h3><p><br>    有其他OO语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的有点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    // 属性</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    // 方法</div><div class="line">    if(typeof this.sayName != &quot;function&quot;) &#123;</div><div class="line">        Person.prototype.sayName = function() &#123;</div><div class="line">            alert(this.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure><p><br>    注意上面代码的if语句。这里只在sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中，if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if语句检查每个属性和每个方法；只要检查其中一个即可。。对于采用这种模式创建的对象，还可以使用instanceof操作符确定它的类型。<br></p><blockquote><p>使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p></blockquote><h3 id="1-2-6-寄生构造函数模式"><a href="#1-2-6-寄生构造函数模式" class="headerlink" title="1.2.6 寄生构造函数模式"></a>1.2.6 寄生构造函数模式</h3><p><br>    通常，在前述的几种模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    var o = new Object();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = function() &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">    return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    在这个例子中，Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了使用new操作符并使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。<br></p><p><br>    这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function SpeicalArray() &#123;</div><div class="line">    // 创建数组</div><div class="line">    var values = new Array();</div><div class="line">    // 添加值</div><div class="line">    values.push.apply(values, arguments);</div><div class="line">    // 添加方法</div><div class="line">    values.toPopedString = function() &#123;</div><div class="line">        return this.join(&quot;|&quot;);</div><div class="line">    &#125;;</div><div class="line">    // 返回数组</div><div class="line">    return values；</div><div class="line">&#125;</div><div class="line"></div><div class="line">var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</div><div class="line">alert(colors.toPipedString());    // &quot;red|blue|green&quot;</div></pre></td></tr></table></figure><p><br>    在这个例子中，我们创建了一个名叫SpecialArray的构造函数。在这个函数内部，首先创建了一个数组，然后push()方法(用构造函数接收到的所有参数)初始化了数组的值。随后，又给数组实例添加了一个toPipedString()方法，该方法返回以竖线分割的数组值。最后，将数组以函数值的形式返回。接着，我们调用了SpecialArray构造函数，向其中传入了用于初始化数组的值，此后又调用了toPipedString()方法。<br></p><p><br>    关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。<br></p><h3 id="1-2-7-稳妥构造函数模式"><a href="#1-2-7-稳妥构造函数模式" class="headerlink" title="1.2.7 稳妥构造函数模式"></a>1.2.7 稳妥构造函数模式</h3><p><br>    道格拉斯·克罗克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中(这些环境中会禁止使用this和new)，或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不引用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    // 创建要返回的对象</div><div class="line">    var o = new Object();</div><div class="line">    // 可以在这里定义私有变量和函数</div><div class="line"></div><div class="line">    // 添加方法</div><div class="line">    o.sayName = function() &#123;</div><div class="line">    alert(name);</div><div class="line">    &#125;;</div><div class="line">    // 返回对象</div><div class="line">    return o；</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法返回name的值。可以像下面使用稳妥的Person构造函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    这样，变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境。<br></p><blockquote><p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p></blockquote><h3 id="1-3-继承"><a href="#1-3-继承" class="headerlink" title="1.3 继承"></a>1.3 继承</h3><p><br>    继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。<br></p><h3 id="1-3-1-原型链"><a href="#1-3-1-原型链" class="headerlink" title="1.3.1 原型链"></a>1.3.1 原型链</h3><p><br>    ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型有时另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。<br></p><p><br>    实现原型链有一种基本模式，其代码大致如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // true</div></pre></td></tr></table></figure><p><br>    以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确立了继承关系之后，我们给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如下图所示。<br></p><p><img src="https://shaoqianheng.github.io/images/h-6-4.png"></p><p><br>    在上面的代码中，我们没有使用SubType默认提供的原型，而是给它换了一个新原型；这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向SuperType的原型。最终结果就是这样的：instance指向SubType的原型，SubType的原型又指向SuperType的原型。getSuperValue()方法仍然还在SuperType.prototype中，但property则位于SubType.prototype中。这是因为property是一个实例属性，而getSuperValue()则是一个原型方法。既然SubType.prototype现在是SuperType的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来SubType.prototype中的constructor被重写了的缘故。<br></p><p><br>    通过实现原型链，本质上扩展了前面介绍的原型搜索机制。当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤:1) 搜索实例；2) 搜索SubType.prototype；3) 搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。<br></p><h4 id="1-别忘记默认的原型"><a href="#1-别忘记默认的原型" class="headerlink" title="1. 别忘记默认的原型"></a>1. 别忘记默认的原型</h4><p><br>    事实上，前面例子中展示的原型链还少了一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层次。下图展示了该例子中完整的原型链。<br></p><p><img src="https://shaoqianheng.github.io/images/h-6-5.png"></p><p><br>    一句话，SubType继承了SuperType，而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法。<br></p><h4 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2. 确定原型和实例的关系"></a>2. 确定原型和实例的关系</h4><p><br>    可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。以下几行代码就说明了这一点。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(instance instanceof Object);    // true</div><div class="line">alert(instance instanceof SuperType); // true</div><div class="line">alert(instance instanceof SubType);   // true</div></pre></td></tr></table></figure><p><br>    由于原型链的关系，我们可以说instance是Object、SuperType或SubType中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了true。<br></p><p><br>    第二种方式是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(Object.prototype.isPrototypeOf(instance));    // true</div><div class="line">alert(SuperType.prototype.isPrototypeOf(instance)); // true</div><div class="line">alert(SubType.prototype.isPrototypeOf(instance));   // true</div></pre></td></tr></table></figure><h4 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3. 谨慎地定义方法"></a>3. 谨慎地定义方法</h4><p><br>    子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">// 添加新方法</div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line">// 重写超类型中的方法</div><div class="line">SubType.prototype.getSuperValue = function() &#123;</div><div class="line">    return false;</div><div class="line">&#125;;</div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // false</div></pre></td></tr></table></figure><p><br>    在以上代码中，getSubValue()被添加到了SubType中。第二个方法getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个那个方法。这里要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。<br></p><p><br>    还有一点需要注意，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">// 使用字面量添加新方法，会导致上一行代码无效</div><div class="line">SubType.prototype = &#123;</div><div class="line">    getSubValue: function() &#123;</div><div class="line">        return this.subproperty;</div><div class="line">    &#125;,</div><div class="line">    someOtherMethod: function() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // error!</div></pre></td></tr></table></figure><p><br>    以上代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断——SubType和SuperType之间已经没有关系了。<br></p><h4 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h4><p><br>    原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。下列代码可以用来说明这个问题。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType() &#123;&#125;</div><div class="line"></div><div class="line">// 继承SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green, black&quot;</div></pre></td></tr></table></figure><p><br>    这个例子中的SuperType构造函数定义了一个colors属性，该属性包含一个数组(引用类型值)。SuperType的每个实例都会有各自包含自己数组的colors属性。当SubType通过原型链继承了SuperType之后，SubType.prototype就变成了SuperType的一个实例，因此它也拥有了一个它自己的colors属性——就跟专门创建了一个SubType.prototype.colors属性一样。但结果是什么呢？结果是SubType的所有实例都会共享这一个colors属性一样。但结果是什么呢？结果是SubType的所有实例都会共享这一个colors属性。而我们对instance1.colors的修改能够通过instance2.colors反映出来，就已经充分证实了这一点。<br></p><p><br>    原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。<br></p><h3 id="1-3-2-借用构造函数"><a href="#1-3-2-借用构造函数" class="headerlink" title="1.3.2 借用构造函数"></a>1.3.2 借用构造函数</h3><p><br>    在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType() &#123;</div><div class="line">    // 继承SuperType</div><div class="line">    SuperType.call(this);</div><div class="line">&#125;</div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green&quot;</div></pre></td></tr></table></figure><p><br>    代码中加注释（第一个）的那一行代码“借调”了超类型的构造函数。通过使用call()方法(或apply()方法也可以)，我们实际上是在(未来将要)新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都具有自己的colors属性的副本了。<br></p><h4 id="1-传递参数"><a href="#1-传递参数" class="headerlink" title="1. 传递参数"></a>1. 传递参数</h4><p><br>    相对于原型链而言，借用构造函数有一个很大的优势，既可以在子类型构造函数中向超类型构造函数传递参数。看下面这个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">function SubType() &#123;</div><div class="line">    // 继承了SuperType，同时还传递了参数</div><div class="line">    SuperType.call(this, &quot;Nicholas&quot;);</div><div class="line">    // 实例属性</div><div class="line">    this.age = 29;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.name);    // &quot;Nicholas&quot;;</div><div class="line">alert(instance.age);     // 29</div></pre></td></tr></table></figure><p><br>    以上代码中的SuperType只接受一个参数name，该参数会直接赋给一个属性。在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。<br></p><h4 id="2-借用构造函数的问题"><a href="#2-借用构造函数的问题" class="headerlink" title="2. 借用构造函数的问题"></a>2. 借用构造函数的问题</h4><p><br>    如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。<br></p><h3 id="1-3-3-组合继承"><a href="#1-3-3-组合继承" class="headerlink" title="1.3.3 组合继承"></a>1.3.3 组合继承</h3><p><br>    组合继承(combination inheritance),有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。下面来看一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    // 继承属性</div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">// 继承方法</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line">instance1.sayName();        // &quot;Nicholas&quot;</div><div class="line">instance1.sayAge();         // 29</div><div class="line"></div><div class="line">var instance2 = new SubType(&quot;Greg&quot;, 27);</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green&quot;</div><div class="line">instance2.sayName();        // &quot;Greg&quot;</div><div class="line">instance2.sayAge();         // 27</div></pre></td></tr></table></figure><p><br>    在这个例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName().SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge().这样一来，就可以让两个不同的SubType实例既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。<br></p><p><br>    组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。<br></p><h3 id="1-3-4-原型式继承"><a href="#1-3-4-原型式继承" class="headerlink" title="1.3.4 原型式继承"></a>1.3.4 原型式继承</h3><p><br>    道格拉斯·克罗克福德在2006年写了一篇文章，题为Prototyal Inheritance in JavaScript(JavaScript中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">    function F() &#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = object(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</div><div class="line"></div><div class="line">alert(person.friends);    // &quot;Shelby, Court, Van, Rob, Barbie&quot;</div></pre></td></tr></table></figure><p><br>    克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到object()函数中，然后改函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。<br></p><p><br>    ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson = Object.create(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = Object.create(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</div><div class="line"></div><div class="line">alert(person.friends);    // &quot;Shelby, Court, Van, Rob, Barbie&quot;</div></pre></td></tr></table></figure><p><br>    Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = Object.create(person, &#123;</div><div class="line">    name: &#123;</div><div class="line">        value: &quot;Greg&quot;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name);    // &quot;Greg&quot;</div></pre></td></tr></table></figure><p><br>    支持Object.create()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br></p><p><br>    在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。<br></p><h3 id="1-3-5-寄生式继承"><a href="#1-3-5-寄生式继承" class="headerlink" title="1.3.5 寄生式继承"></a>1.3.5 寄生式继承</h3><p><br>    寄生式(parasitic)继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function createAnother(original) &#123;</div><div class="line">    var clone = object(original);    // 通过调用函数创建一个新对象</div><div class="line">    clone.sayHi = function() &#123;</div><div class="line">        alert(&quot;hi&quot;);</div><div class="line">    &#125;;</div><div class="line">    return clone;    // 返回这个对象</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个例子中，createAnother()函数接收一个参数，也就是将要作为新对象基础的对象。然后，把这个对象(original)传递给object()函数，将返回的结果赋值给clone。再为clone对象添加一个新方法sayHi(),最后返回clone对象。可以像下面这样来使用createAnother()函数：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi();    // &quot;hi&quot;</div></pre></td></tr></table></figure><p><br>    这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person的所有属性和方法，而且还有自己的sayHi()方法。<br></p><p><br>    在主要考虑对象而不是定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。<br></p><blockquote><p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p></blockquote><h3 id="1-3-6-寄生组合式继承"><a href="#1-3-6-寄生组合式继承" class="headerlink" title="1.3.6 寄生组合式继承"></a>1.3.6 寄生组合式继承</h3><p><br>    前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数；一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。再来看一看下面组合继承的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    SuperType.call(this, name);    // 第二次调用SuperType()</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = new SuperType();    // 第一次调用SuperType()</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    加注释的代码是调用SuperType构造函数的代码。在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。图1-6展示了上述过程。<br></p><p><br>    图1-6所示，有两组name和colors属性：一组在实例上，一组在SubType原型中。这就是调用两次SuperType构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。<br></p><p><br>    所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType, superType) &#123;</div><div class="line">    var prototype = object(superType.prototype);    // 创建对象</div><div class="line">    prototype.constructor = subType;                // 增强对象</div><div class="line">    subType.prototype = prototype;                  // 指定对象</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个示例中的inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。最后一步，将新创建的对象(即副本)赋值给子类型的原型。这样，我们就可以用调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://shaoqianheng.github.io/images/h-6-6.png"></p><div style="text-align: center;">图1-6</div><p><br>    这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf().开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。<br></p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><br>    ECMAScript支持面向对象(OO)编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。<br></p><p><br>    (1) 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。<br><br>    (2) 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象(即与对象具有松散耦合的特点)，因此没有理由不在多个对象间共向函数。<br><br>    (3) 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式与原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。<br></p><p><br>    JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型的构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合模式，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。<br></p><p><br>    此外，还存在下列可供选择的继承模式。<br></p><p><br>    (1) 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。<br><br>    (2) 寄生式继承，与原型式继承非常类似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。<br><br>    (3) 寄生组合式继承，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弟子规 （五）</title>
      <link href="/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%885%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%885%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="六、泛爱众"><a href="#六、泛爱众" class="headerlink" title="六、泛爱众"></a>六、泛爱众</h3><p><br>    【解】“泛爱众”就是以广泛的爱心对待社会大众。人类生活是以爱心为纽带，没有爱心，人类生活就太痛苦不堪了。这个爱心从哪里来的？这个爱心就是孝心。孝道，正是培养爱心的第一步，一个连父母都不爱的人决不会真心爱他人，所以只有当孩子懂得了对父母尽孝道，他才能把这份爱心继续向外延伸出来爱一切人。这样由近及远，使他的爱心和责任感日扩日大，进而推衍到爱护别人的父母和孩子，再继续扩展到爱护一切万物，包括动物、植物、矿物。因此，孝道决不是培养孩子对家庭的自私，恰恰相反，是要最终培养成孩子大公无私的品德。<br></p><p><br>    现代很多人都是为了一己的目的在生活，他的人生追求和价值都是在为自己能够考个好大学、找个好工作、挣钱多、有小车洋房等等，追求的都是个人相关的利益，只顾自己而遗忘了整个天下国家和芸芸众生。这样的心胸是不会有真正快乐的，因为他的快乐是构建在成败得失之上的，有得失就会生忧喜，而真正的快乐是不以成败荣辱、称讥毁誉为原则的，那种乐是超乎于喜怒哀乐之上的乐。所谓“独乐乐不如众乐乐”，所以要想拥有真正的幸福快乐，就需要培养一点天下的精神，不是小我，而应该有一个大我，要能够使自己的心与天地万物同体。如果每一个人在为自己的时候都能够兼顾到他人、兼顾到国家天下，那么整个中华民族的伟大复兴、世界的和平、人类的共处都是指日可待的事情。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡是人 &emsp;皆须爱 &emsp;天同覆 &emsp;地同载</p><p style="margin-bottom: 0;"><br>    【解】只要是人，不分族群、人种、宗教信仰，皆须相亲相爱。同是天地所生，应该不分你我、互助合作，才能维持这个共生共荣的生命共同体。<br></p><p><br>    爱是用心去感受别人的需要。一个人不可能孤立的生活在这个世界上，衣食住行各个方面都离不开他人的辛勤劳动，大家彼此相互依存才构成了我们赖以生存的社会。作为社会的一分子，我们应该心存感激，密切关注社会上的一切人和事，随时准备伸出援助之手，关怀他人，帮助他人，以尽到作为社会成员的一份责任，如此人生才更有意义、更有价值。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">行高者 &emsp;名自高 &emsp;人所重 &emsp;非貌高</p><p style="margin-bottom: 0;"><br>    【解】德行高尚的人，他自自然就有很高的名望。人们所敬重的是他高尚的品行，而不是他的外表容貌是否出众。<br></p><p><br>    像孔子一生，他真正是力行人道，将圣贤教会向天下人来宣扬，所以他才有这么大的名气，成为万世师表，为百姓所敬仰，这些都是因为他有真正的德行、学问。夫子有温、良、恭、俭、让的美德，他具备了人格的魅力，所以走到哪里人们都要去亲近他。要是一个人很傲慢、很孤傲或者脾气暴躁，躲之唯恐不及，谁还敢去亲近他呢？但是对温和、谦敬、有礼貌、品德高尚的人，大家不自觉地就想和他亲近，肯定都很喜欢他。群众的眼睛是雪亮的，如果你没有真正的德行，人们不可能对你生起真正的敬仰之心，所以我们要懂得修养自己真实的道德学问。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">才大者 &emsp;望自大 &emsp;人所服 &emsp;非言大</p><p style="margin-bottom: 0;"><br>    【解】有才能的人，处理事情的能力卓越，声望自然不凡。人们之所以欣赏佩服，是因为它有真才实学，而不是因为他很会说大话。<br></p><p><br>    这个“才”，必须要建立在德行的基础上。一个有德行的人，他所学的才华一定是从利益家庭、利益社会、利益大众这个目的出发，取之于社会，用之于社会，他的才华一定会让人觉悟、让人受益，大家自然会对他很敬重、佩服。假如一个人有才无德，为了一己之力而忘记了道义，那就不可能赢得他人的尊重。一个没有优秀品格和素养的人，要想成才是很难的，即使日后学成，也不能成为“一个高尚的人，一个纯粹的人，一个脱离了低级趣味的人，一个有益于人民的人”。所以真正的人才标准是“德才兼备”，而且必须是德为先，才为后。中国人深知有才无德的人是小人，小人对社会的危害极大，现代社会受西方文化的影响，只知才能而不知道德，故世局日乱。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">己有能 &emsp;勿自私 &emsp;人所能 &emsp;勿轻訾</p><p style="margin-bottom: 0;"><br>    【解】一个人有才能和本事，不要自私保守、舍不得付出，要时刻想着服务大众、回报社会。看到别人有才华，应当学习欣赏赞叹，而不是批评、嫉妒、毁谤，不要因为嫉妒而贬低别人。<br></p><p><br>    嫉妒心强的人，看到别人才华高、名望大了，心里不服，于是千方百计地来刁难他、侮辱他，这种行为一定会导致自己身败名裂，最后是自食其果。一个真正有德有才的人，不会因为我们的嫉妒而使他的德行、才华降低，对他的伤害并不大，而对自己的伤害却是非常的严重。所以看到别人有优秀的地方，我们应该懂得赞叹，向他学习，为他高兴，这叫随喜。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">勿谄富 &emsp;勿骄贫 &emsp;勿厌故 &emsp;勿喜新</p><p style="margin-bottom: 0;"><br>    【解】不要去讨好巴结富有的人，也不要在穷人面前骄傲自大或者轻视他们。不要喜新厌旧，对于老朋友要珍惜，不要贪恋新朋友或新事物。<br></p><p><br>    谚云：“贫贱之交不可忘，糟糠之妻不下堂。”夫妻两人有缘走到一起，是多么难得的缘分，在日复一日、年复一年中，彼此互相关怀、照顾，一同孝敬父母、教育子女，携手走过多少风风雨雨，又一起尝过多少的酸甜苦辣，为这个家都逝去了青春年华。然而在共同经过患难之后，是否能够共甘甜？当我们事业有成之时，如果还能对对方依然如故，不离不弃，彼此尊敬、爱护，同心同德，有情有义，那么这才是夫妻之间的真情真爱。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">人不闲 &emsp;勿事搅 &emsp;人不安 &emsp;勿话扰</p><p style="margin-bottom: 0;"><br>    【解】别人很忙没空时，不要去打扰他。当别人心情不好、身心欠安的时候，我们不要闲言碎语去干扰他，增加他的烦恼与不安。<br></p> <p><br>    与人相处，我们应随时随地注重自己的言行不要影响到别人的正常生活与工作，这是一种做人的美德。如果我们总是以自我为中心来考虑问题，不能替对方着想，譬如说我们要找人帮忙（办事或谈话），不看对方是不是方便就贸然打扰，虽然对方往往碍于情面，不好意思跟你决绝，但是在心里已经对你形成很不好的印象了，在以后的相处中就会对你敬而远之。所以我们要在平时的生活点滴中学会察言观色，不等别人说，我们就要能看出他需要什么、不需要什么。纵使是再近的亲人，进退之间，我们也要站在对方的感受上设想，这样大家自然就可以相处得很融洽了。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">人有短 &emsp;切莫揭 &emsp;人有私 &emsp;切莫说</p><p style="margin-bottom: 0;"><br>    【解】别人的缺点、短处，不要去揭穿。别人有秘密不想让人知道，我们就不要说出来。对于他人的隐私，切忌去张扬，否则很可能为我们自己招来灾祸，这种缺德事是不可以做的。<br></p><p><br>    每个人都有自尊，我们自己不想自尊、面子受到侮辱，那我们也不能够这样对待别人。如果把别人的短处、隐私揭露出来，这样做就跟人家结怨了，自己也把德行败坏了，伤和气又伤厚道，有智慧的人怎么会去干这种傻事呢？我们也不要把别人的短处放在心里，把自己的心当成装别人短处的垃圾桶。把别人的那些垃圾、缺点全都装在自己的心里，这也是对不起自己啊！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">道人善 &emsp;即是善 &emsp;人知之 &emsp;愈思勉</p><p style="margin-bottom: 0;"><br>    【解】赞美别人的善行就是行善，当对方听到你的称赞之后，必定会更加勉励行善，进一步把善行提升。<br></p><p><br>    如果是其他人也同时听到你的赞叹，他们也会效法这个善人，所以对所有人都是好事。因此，能够常常称赞他人的优点、长处、善行，这本身就是行善，这是对大众的勉励，希望大众见贤思齐。现在有一部分人连什么是善都不甚了解，更不要说去道人善了，主要原因就是近百年来中国的传统文化、圣贤教育被严重破坏了，所以现在要恢复，如果能够把传统文化教育复兴起来，这就是最大的善，叫善中之善。它能够帮助人认识本善，修学恢复本善，这真是叫功德无量啊！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">扬人恶 &emsp;即是恶 &emsp;疾之甚 &emsp;祸且作</p><p style="margin-bottom: 0;"><br>    【解】到处宣扬他人的过失或缺点，这是最坏最恶的一件事，这是最大的过失。如果指责批评太过分了，还会给自己招来灾祸。<br></p><p><br>    古人讲：“口为祸福之门。”常常讲人家的过失、张扬人家恶事的这种行为，最开始可能是因为一念私心，要把别人贬低、打倒，久而久之习惯了，动不动就说人家的过失，可能说的时候就在谈笑之间，自己都没有觉察到是在造恶，就跟很多人结了怨，最后等别人报复的时候，自己都不知道是怎么回事。所以古人以“静坐常思己过，闲谈莫论人非”来惕励自己，实因口过之患、扬恶之害足以酿成滔天大祸，不可不慎！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">善相劝 &emsp;德皆建 &emsp;过不规 &emsp;道两亏</p><p style="margin-bottom: 0;"><br>    【解】朋友之间要懂得互相规过劝善，共同建立良好的品德修养。如果有错不能互相规劝，那么两个人的品德都会有亏损。<br></p><p><br>    规劝朋友，一定是在两个人的时候，其他人在场绝对不能讲，这是尊重对方，这样朋友会感恩你，规劝的效果也比较好。因为我们规劝的目的是为了朋友改过、为朋友好，所以这个方式一定要注意。如果方法不对，可能就达不到规劝的效果，弄不好他不但不肯改，甚至还会抵制、逆反的心理，而且可能会怀恨在心，这样我们不就适得其反了吗？所以跟人交往这些分寸、态度都是非常重要的，不可不慎重啊！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡取与 &emsp;贵分晓 &emsp;与宜多 &emsp;取宜少</p><p style="margin-bottom: 0;"><br>    【解】财物的取得和给予，一定要分辨清楚明白，不可含糊。宁可多给别人，自己少拿一些，才能广结善缘。<br></p><p><br>    古人讲：“登天难，求人更难。”所以最好不要向人索取、不要求人。所谓“人到无求品自高”，人的品格修养从哪里来分辨呢？就是看他有没有“求”的心。如果一个人真正能做到与人无争、于世无求，这种人就得大自在了。真正的君子淡泊名利，他所求的是道，不是世间的功名富贵。君子忧道不忧贫，谋道不谋食，他所忧得是自己的道德学问不能够增长、不能够为社会奉献、不能够帮助社会推广圣贤教育来达到安定和谐。所谓“无欲则刚”，他欲望少，因此他就刚强，不管是什么样的曲折、困难、诱惑自然拦不倒他，都不能够阻碍他的志向。所以无求、无取的这种境界，是我们每一个学习圣贤教育的人都应该立志去证得的。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">将加人 &emsp;先问己 &emsp;己不欲 &emsp;即速己</p><p style="margin-bottom: 0;"><br>    【解】当我们要对人说话或让人做事的时候，必须要先问问自己，别人如果这样对我们，我们能接受吗？喜欢吗？如果我们不希望别人这样对自己，那我们就不应该这样对待别人。<br></p><p><br>    这就是《论语》当中所说的“己所不欲，勿施于人”，这是待人之道，待人就要用这种原则。这是世界上所有宗教、文化乃至联合国都认同的一个原则，在世界上被称为“黄金法则”：你不愿意别人怎样对待你，你就不该怎样对待别人。如果你用这种存心去和你周围的人相处，自然就能得到大家的欢迎。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">恩欲报 &emsp;怨欲忘 &emsp;报怨短 &emsp;报恩长</p><p style="margin-bottom: 0;"><br>    【解】受人恩惠要常常记在心里，时时想着报答。别人有对不起自己的事情，应该宽大为怀把它忘掉。如果不小心和人结了怨仇，应请求他人的谅解。怨恨不平的事不要停留太久，过去就算了，耿耿于怀这是对不起自己、自己糟蹋自己，何苦呢？至于别人对我们的恩德，要感恩在心、常记不忘个、常思报答，生活在感恩的世界里，我们的心情多舒服啊！<br></p><p><br>    古人云：“受人滴水之恩，当以涌泉相报。”这一生有恩于我们的，不知凡几，想想父母养育之恩、国家赋予我们安定之恩、师长教诲之恩、众生努力生产之恩，这四种恩义，究竟我们感恩、回馈过多少呢？人与人相处难免会发生冲突，如果我们把别人的过失每天都放在心上，那可不好受，这样长此以往下去，只能给自己带来无穷的烦恼和病苦。常言道“可恶之人必有可怜之处”，他也是没有学过做人做事的道理，才会做出没有道义的事情来，我们应该对它生起怜悯心和慈悲心，而当我们肯原谅别人的同时，其实也就是原谅了自己。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">待婢仆 &emsp;身贵端 &emsp;虽贵端 &emsp;慈而宽</p><p style="margin-bottom: 0;"><br>    【解】对待家中的婢女和仆人（现代社会包括下属、下级在内），要注重自己的品行端正、庄重，并且以身作则，不可轻浮随便。虽然品行端正很重要，但是仁慈宽厚更可贵。<br></p><p><br>    这是讲对待下属知道。孔子说：“其身正，不令而行。其身不正，虽令不从。”这是说在上位的领导、长官自身做事正当，不用命令，底下的人自然会照做。可是如果自身做事不正当，即便你发号施令，下属也是不会服从的。现代社会许多人推崇西方管理思想，强调机制、信息、网络化管理等，而不知管理最根本处在“人”，以人为本，能以德性来引导人，使其工作自动自发，就是最高级的管理方法。做领导的若能体会下属之劳苦，常常勉励关怀，必能得其忠心。领导与部属的关系，应当建立在彼此信任与相互尊重的基础上，惟有如此才能和睦共事，成就永续的事业。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">势服人 &emsp;心不然 &emsp;理服人 &emsp;方无言</p><p style="margin-bottom: 0;"><br>    【解】如果对待下属是用权势强逼来压人，强迫对方屈服听你的话，虽然对方表面上不敢反抗，心中难免口服心不服、不以为然，而唯有以理服人，才能让人心悦诚服、没有怨言。<br></p><p><br>    人在拥有权势之后，很容易迷失方向，沉沦威权中仗恃优越，浑浑噩噩不知努力而虚度此生！如果对待下属再太过刻薄，他们就会阳奉阴违，暗地里给你捅纰漏，这就得不偿失。当知权势用之不当足以造作无边罪业，可不慎乎！以势服人非真服，以理服人方无言。要让大众都服你，你就要有公理、有道义存在，这样彼此之间才没有言语的纷争，你的公司、你的团体才有办法和谐。<br></p><h3 id="七、亲仁"><a href="#七、亲仁" class="headerlink" title="七、亲仁"></a>七、亲仁</h3><p><br>    【解】“亲仁”，亲是亲近、学习的意思，亲近那些有道德、有学问、有人生境界、有情操的人，这是讲择师。一个人的学问要有成就，有两个先决要素：一个是好老师，一个是好同学。好老师帮我们指路，把很重要的教会告诉我们，使我们的人生少走很多弯路；好同学能够彼此互相提携、互相提醒。只有这样，我们一生才能够得到幸福的人生、成功的事业乃至敬德修业成就圣贤的人品。<br></p><p><br>    我们时时亲近仁德之人，就能够提升自己的道德学问，所谓“入芝兰之室，久而不闻其香”，你每天接触的都是善人，我们无形当中德行都会提升。但是“入鲍鱼之肆，久而不闻其臭”，假如每天身旁都是狐群狗党，自己的言语、行为就会变得愈来愈粗俗、低级、下流。“学如逆水行舟，不进则退”，在学习的道路上，必须要有良师益友的提携。只有亲近仁德之人才能增长我们的智慧，人生有智慧才会下对抉择，人生才会愈走愈轻松，假如没有做对抉择，那人生会愈走愈沉重，所以“亲仁”非常重要。中国古人说：“天地君亲师。”这是因为人伦大道，必靠师而传承，无师则人道衰，故师的作用等同于天地。友以辅仁，亲近良师益友，才能学有所成。人应当有博爱之心，爱一切人，但首先是亲近有仁德的人。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">同是人 &emsp;类不齐 &emsp;流俗众 &emsp;仁者希</p><p style="margin-bottom: 0;"><br>    【解】同样是人，品行高低、善恶邪正却是良莠不齐。跟着潮流走的凡夫俗子很多，而真正仁慈博爱的君子却很稀少。<br></p><p><br>    一般凡夫俗子心无大志，每天都为着自己的衣食、饮食男女、自私自利而活着。仁者存心仁厚、处处谦卑，能够以身作则，他把一切人、一切众生看成是自己，处处能替人设想，没有私心，是真正大公无私的人。那么我们现在想想，自己是仁者还是流俗众呢？如果自己还是自私自利，一天到晚为自己打算，那就是流俗众啊！想当仁者就要放下错误的观念和知见，常常提起圣贤的教训，这是正念。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">果仁者 &emsp;人多畏 &emsp;言不讳 &emsp;色不媚</p><p style="margin-bottom: 0;"><br>    【解】如果有一位仁德的人出现，大家自然敬畏他，因为他说话公正无私，没有隐瞒，又不讨好他人，所以大家才会起敬畏之心。<br></p><p><br>    仁者他心地清净，与人无争，于世无求，所以他就不会有巴结人的念头，他所说的都是利益大众的话。利益大众的话不一定是好听话，所以一般人跟仁者在一起都觉得很难相处，对仁者也就敬而远之了。古人讲：“忠言逆耳利于行。”真正忠言可能不是好听的，但是听了之后能够接受、照做就有好处，因此我们要知道，别人不敢亲近仁者，他就不能提升，我们必须要亲近仁者，这样我们的品德学问才能够提升。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">能亲仁 &emsp;无限好 &emsp;德日进 &emsp;过日少</p><p style="margin-bottom: 0;"><br>    【解】能够亲近仁德之人，向他学习，就会得到无限的好处，因为他会使我们的道德学问一天天地进步，过失就会逐渐地减少。（在生命中，可以不间断的陪伴我们走完人生的仁者就是圣贤经典，它是最真实、最永恒的仁者！）<br></p><p><br>    我们想要学业，道业有所成就，选择老师至关重要，一定要听其言、观其行，要用圣贤的教诲去观察他，看他是否存心仁厚、处处谦卑并且能够以身作则，看他是不是真做到了。一旦找到了我们由衷佩服的老师，就要用至诚恭敬的心去依教奉行，所谓“一分诚敬得一分利益，十分诚敬得十分利益”，恭敬心才能够受教。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">同是人 &emsp;类不齐 &emsp;流俗众 &emsp;仁者希</p><p style="margin-bottom: 0;"><br>    【解】不肯亲近仁人君子与圣贤教育，就会有无穷的祸害。因为不肖的小人会趁虚而入，跑来亲近我们，日积月累，我们的言行举止就会受到不良的影响，事情就会弄得一败涂地，最后导致整个人生的失败。<br></p><p style="margin-bottom: 0;"><br>    什么是小人呢？就是追求世间名闻利养，搞自私自利，胸无大志，对圣贤教育并不想学习，小是因为他心量小，他的心量只有他自己，这叫小人。什么叫大人呢？大人是心量大，真的心怀天下，心里面装着宇宙一切的众生，他忘了自己，这是仁者。《易经》上讲：“方以类聚，物以群分”。人都是一类类的聚起来的，我们如果不肯学习圣教，跟仁者就会越来越远，自然就跟小人混在一起，最后使自己不知不觉也成为小人了。所谓“近朱者赤，近墨者黑”，《朱子治家格言》也讲到“狎昵恶少，久必受其累”，所以人对于环境的选择至关重要，在自己德行还没有相当稳固之前，对于一些比较没有德行的朋友，我们要敬而远之。<br></p><p style="margin-bottom: 0;"><br>    《弟子规》是照妖镜也是显圣镜，只要用《弟子规》去衡量，好朋友、坏朋友一看便知道。所以家长与其担心孩子以后会交到坏朋友，不如从小就教他落实《弟子规》，把他德行的根基扎稳固。通过学习使他善恶分明，自己懂得抉择正确的朋友，这样你才能真正地高枕无忧。当一个人善恶分明，纵使遇到坏朋友，不仅不会误入歧途，并且他还会“善相劝”，把坏朋友影响过来，做到“德皆建”。因此，为人父母者要深谋远虑，引导孩子更多地接触善友。否则，即使你整日担心，也不见得有什么帮助。因为“亲附善友，如雾露中行，虽不湿衣，时时有润”，让孩子在善友的熏陶下，父母又能够谆谆教诲和以身作则，这样孩子不仅能扎好德行的根，并且还能“根深叶茂”，这样我们的人生才会幸福。<br></p><p><br>    所以“亲仁”这一条非常重要，它告诫我们，人的内在一定要有道德作为基础，用圣贤人的这些智慧，来巩固我们内在的道德思想及修养，以增强明辨是非的能力，使自己在种种诱惑之面前能够把持住而不受干扰。如果没有得到这些熏习的话，在当今社会，一不小心把持不住，就有可能陷进去而自己都不晓得。尤其是沾上赌博、色情等一些不良的习气，可以让你一辈子堕落下去，危害相当之大。所以，我们不可一日远离良师益友，不可一日不读圣贤书。<br></p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>引用类型（二）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-3-3-RegExp构造函数属性"><a href="#1-3-3-RegExp构造函数属性" class="headerlink" title="1.3.3 RegExp构造函数属性"></a>1.3.3 RegExp构造函数属性</h3><p><br>    RegExp构造函数包含一些属性(这些属性在其他语言中被看成是静态属性)。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名(Opera是例外，它不支持短属性名)。下表列出了RegExp构造函数的属性。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">长属性名            短属性名         说明</div><div class="line">input               $_               最近一次要匹配的字符串。Opera未实现此属性</div><div class="line">lastMatch           $&amp;               最近一次的匹配项。Opera未实现此属性</div><div class="line">lastParen           $+               最近一次匹配的捕获组。Opera未实现此属性</div><div class="line">leftContext         $`               input字符串中lastMatch之前的文本</div><div class="line">multiline           $*               布尔值，表示是否所有表达式都是用多行模式。IE和Opera未实现此属性</div><div class="line">rightContext        $&apos;               Input字符串中lastMatch之后的文本</div></pre></td></tr></table></figure><p><br>    使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var text = &quot;this has been a short summer&quot;;</div><div class="line">var pattern = /(.)hort/g;</div><div class="line"></div><div class="line">// 注意：Opera不支持input、lastMatch、lastParen和multiline属性。IE不支持multiline属性。</div><div class="line">if (pattern.test(text)) &#123;</div><div class="line">    alert(RegExp.input);        // this has been a short summer</div><div class="line">    alert(RegExp.leftContext);// this has been a</div><div class="line">    alert(RegExp.rightContext);// summer</div><div class="line">    alert(RegExp.lastMatch);// short</div><div class="line">    alert(RegExp.lastParen);// s</div><div class="line">    alert(RegExp.multiline);// false</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    以上代码创建了一个模式，匹配任何一个字符后跟hort，而且第一个字符放在了一个捕获组中。RegExp构造函数的各个属性返回了下列值：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) input属性返回了原始字符串；</div><div class="line">b) leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串；</div><div class="line">c) lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short；</div><div class="line">d) lastParen属性返回最近一次匹配的捕获组，即例子中的s。</div></pre></td></tr></table></figure><p><br>    如前所述，例子使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var text = &quot;this has been a short summer&quot;;</div><div class="line">var pattern = /(.)hort/g;</div><div class="line"></div><div class="line">if (pattern.test(text)) &#123;</div><div class="line">    alert(RegExp.$_);       // this has been a short summer</div><div class="line">    alert(RegExp[&quot;$`&quot;]);    // this has been a</div><div class="line">    alert(RegExp[&quot;$&apos;&quot;]);    // summer</div><div class="line">    alert(RegExp[&quot;$&amp;&quot;]);    // short</div><div class="line">    alert(RegExp[&quot;$+&quot;]);    // s</div><div class="line">    alert(RegExp[&quot;$*&quot;]);    // false</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    除了上面介绍的几个属性之外，还有多大9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1、RegExp.$2……RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var text = &quot;this has been a short summer&quot;;</div><div class="line">var pattern = /(..)or(.)/g;</div><div class="line"></div><div class="line">if(pattern.test(text)) &#123;</div><div class="line">    alert(RegExp.$1);   // sh</div><div class="line">    alert(RegExp.$2);   // t</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这里创建了一个包含两个捕获组的模式，并且该模式测试了一个字符串。即使test()方法只返回一个布尔值，但RegExp构造函数的属性$1和$2也会被匹配相应捕获组的字符串自动填充。<br></p><h3 id="1-3-4-模式的局限性"><a href="#1-3-4-模式的局限性" class="headerlink" title="1.3.4 模式的局限性"></a>1.3.4 模式的局限性</h3><p><br>    尽管ECMAScript中的正则表达式功能还是比较完备的，但仍然缺少某些语言(特别是Perl)所支持的高级正则表达式特性。下面列出了ECMAScript正则表达式不支持的特性。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a) 匹配字符串开始和结尾的\A和\Z锚(但支持以插入符号(^)和美元符号($)来匹配字符串的开始和结尾)</div><div class="line">b) 向后查找(lookbehind)-但完全支持向前查找(lookahead)</div><div class="line">c) 并集和交集类</div><div class="line">d) 原子组(atomic grouping)</div><div class="line">e) Unicode支持</div><div class="line">f) 命名的捕获组-但支持编号的捕获组</div><div class="line">g) s(single,单行)和x(free-spacing,无间隔)匹配模式</div><div class="line">h) 条件匹配</div><div class="line">i) 正则表达式注释</div></pre></td></tr></table></figure><p><br>    即使存在这些限制，ECMAScript正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹配任务。<br></p><h3 id="1-4-Function类型"><a href="#1-4-Function类型" class="headerlink" title="1.4 Function类型"></a>1.4 Function类型</h3><p><br>    说起来ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function sum (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这与下面使用函数表达式定义函数的方式几乎相差无几。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sum = function(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    以上代码定义了变量sum并将其初始化为一个函数。有没有注意到，function后面没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量sum即可以引用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量一样。<br></p><p><br>    最后一种定义函数的方式是使用Function构造函数。Function函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。来看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var sum = new Funtion(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);// 不推荐</div></pre></td></tr></table></figure><p><br>    从技术角度讲，这是一个函数表达式。但是，我们不推荐使用这种方法定义函数，因为这种语法会导致解析两次代码(第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串)，从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。<br></p><p><br>    由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function sum (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum(10, 10));// 20</div><div class="line"></div><div class="line">var anotherSum = sum;</div><div class="line">alert(anotherSum(10, 10));// 20</div><div class="line"></div><div class="line">sum = null;</div><div class="line">alert(anotherSum(10, 10));// 20</div></pre></td></tr></table></figure><p><br>    以上代码首先定义了一个名为sum()的函数，用于求两个值的和。然后，又声明了变量anotherSum，并将其设置为与sum相等(将sum的值赋给anotherSum)。注意，使用不带圆括号的函数名是访问函数的指针，而非调用函数。此时，anotherSum和sum就都指向了同一个函数，因此anotherSum()也可以被调用并返回结果。即使将sum设置为null，让它与函数“断绝关系”，但仍然可以正常调用anotherSum()。<br></p><h3 id="1-4-1-没有重载-深入理解"><a href="#1-4-1-没有重载-深入理解" class="headerlink" title="1.4.1 没有重载(深入理解)"></a>1.4.1 没有重载(深入理解)</h3><p><br>    将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。以下是曾在第3章使用过的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function addSomeNumber (num) &#123;</div><div class="line">    return num + 100;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function addSomeNumber(num) &#123;</div><div class="line">    return num + 200;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result = addSomeNumber(100);// 300</div></pre></td></tr></table></figure><p><br>    显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var addSomeNumber = function (num) &#123;</div><div class="line">    return num + 100;</div><div class="line">&#125;;</div><div class="line">addSomeNumber = function (num) &#123;</div><div class="line">    return num + 200;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var result = addSomeNumber(100);// 300</div></pre></td></tr></table></figure><p><br>    通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。<br></p><h3 id="1-4-2-函数声明与函数表达式"><a href="#1-4-2-函数声明与函数表达式" class="headerlink" title="1.4.2 函数声明与函数表达式"></a>1.4.2 函数声明与函数表达式</h3><p><br>    到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使用其在指向任何代码之前可用(可以访问)；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(10, 10));</div><div class="line">function sum (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升(function declaration hoisting)的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(10, 10));</div><div class="line">var sum = function (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；而且，由于第一行代码就会导致“unexpected identifier”(意外标识符)错误，实际上也不会执行到下一行。<br></p><p><br>    除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。<br></p><blockquote><p>也可以同时使用函数声明和函数表达式，例如var sum = function sum () {}.不过这种语法在Safari中会导致错误。</p></blockquote><h3 id="1-4-3-作为值的函数"><a href="#1-4-3-作为值的函数" class="headerlink" title="1.4.3 作为值的函数"></a>1.4.3 作为值的函数</h3><p><br>    因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数的结果返回。来看一看下面的函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function callSomeFunction(someFunction, someArgument) &#123;</div><div class="line">    return someFunction(someArgument);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function add10 (num) &#123;</div><div class="line">    return num + 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result1 = callSomeFunction(add10, 10);</div><div class="line">alert(result1);// 20</div><div class="line"></div><div class="line">function getGreeting (name) &#123;</div><div class="line">    return &quot;Hello, &quot; + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);</div><div class="line">alert(result2);// &quot;Hello, Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后面那对圆括号。因此上面例子中传递给callSomeFunction()的是add10和getGreeting，而不是执行它们之后的结果。<br></p><p><br>    当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假如有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">    return function(object1, object2) &#123;</div><div class="line">        var value1 = object1[propertyName];</div><div class="line">        var value2 = object2[propertyName];</div><div class="line"></div><div class="line">        if (value1 &lt; value2) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125; else if (value1 &gt; value2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var data = [&#123;name: &quot;Zachary&quot;, age: 28&#125;, &#123;name: &quot;Nicholas&quot;, age: 29&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(&quot;name&quot;));</div><div class="line">alert(data[0].name);// Nicholas</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(&quot;age&quot;));</div><div class="line">alert(data[0].name);// Zachary</div></pre></td></tr></table></figure><p><br>    这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个age属性。在默认情况下，sort()方法会调用每个对象的toString()方法以确定他们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction(“name”)方法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name为“Nicholas”，age是29的对象。然后，我们又使用了createComparisonFunction(“age”)返回的比较函数，这次是按照对象的age属性排序。得到的结果是name值为“Zachary”，age值是28的对象排在了第一位。<br></p><h3 id="1-4-4-函数内部属性"><a href="#1-4-4-函数内部属性" class="headerlink" title="1.4.4 函数内部属性"></a>1.4.4 函数内部属性</h3><p><br>    在函数内部，有两个特殊的对象：arguments和this。其中，arguments它是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if (num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * factorial(num - 1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    定义阶乘函数一般都要用到递归算法；如上面代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if (num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num - 1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var trueFactorial = factorial;</div><div class="line"></div><div class="line">factorial = function () &#123;</div><div class="line">    return 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(trueFactorial(5));// 120</div><div class="line">alert(factorial(5));// 0</div></pre></td></tr></table></figure><p><br>    在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋给了factorial变量。如果像原来的factorial()那样不使用arguments.callee,调用trueFactorial()就会返回0.可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够地计算阶乘；至于factorial()，它现在只是一个返回0的函数。<br></p><p><br>    函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor();// &quot;red&quot;</div><div class="line"></div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor();// &quot;blue&quot;</div></pre></td></tr></table></figure><p><br>    上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window；换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了”red”。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了“blue”。<br></p><blockquote><p>请牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。</p></blockquote><p><br>    ECMAScript5也规范化了另一个函数对象的属性：caller。除了Opera的早期版本不支持，其他浏览器都支持这个ECMAScript3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outer() &#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function inner() &#123;</div><div class="line">    alert(inner.caller);</div><div class="line">&#125;</div><div class="line"></div><div class="line">outer();</div></pre></td></tr></table></figure><p><br>    以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了inner()，所以inner.caller就指向outer().为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outer() &#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function inner() &#123;</div><div class="line">   alert(arguments.callee.caller);</div><div class="line">&#125;</div><div class="line"></div><div class="line">outer();</div></pre></td></tr></table></figure><p><br>    IE、Firefox、Chrome和Safari的所有版本以及Opera9.6都支持caller属性<br></p><p><br>    当函数在严格模式下运行时，访问arguments.callee会导致错误。ECMAScript 5还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。<br></p><p><br>    严格模式还有一个限制：不能为函数的caller属性复制，否则会导致错误。<br></p><h3 id="1-4-5-函数属性和方法"><a href="#1-4-5-函数属性和方法" class="headerlink" title="1.4.5 函数属性和方法"></a>1.4.5 函数属性和方法</h3><p><br>    前面曾经提到过，ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function sayName(name) &#123;</div><div class="line">    alert(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sum(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sayHi() &#123;</div><div class="line">    alert(&quot;hi&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(sayName.length);// 1</div><div class="line">alert(sum.length);// 2</div><div class="line">alert(sayHi.length);// 0</div></pre></td></tr></table></figure><p><br>    以上代码定义了3个函数，但每个函数接收的命名参数个数不同。首先，sayName()函数定义了一个参数，因此其length属性的值为1.类似地，sum()函数定义了两个参数，结果其length属性中保存的值为2.而sayHi()没有命名参数，所以其length值为0.<br></p><p><br>    在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了。对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在ECMAScript5中，prototype属性是不可枚举的，因此使用for-in无法发现。<br></p><p><br>    每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum1(num1, num2) &#123;</div><div class="line">    return sum.apply(this, arguments);// 传入arguments对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum2(num1, num2) &#123;</div><div class="line">    return sum.apply(this, [num1, num2]);// 传入数组</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(callSum1(10, 10));// 20</div><div class="line">alert(callSum2(10, 10));// 20</div></pre></td></tr></table></figure><p><br>    在上面这个例子中，callSum1()在执行sum()函数时传入了this作为this值(因为是在全局作用域中调用的，所以传入的就是window对象)和arguments对象。而callSum2同样也调用了sum()函数，但它传入的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。<br></p><blockquote><p>在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this值将是undefined。</p></blockquote><p><br>    call()和apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum(num1, num2) &#123;</div><div class="line">    return sum.call(this, num1, num2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(callSum(10, 10));// 20</div></pre></td></tr></table></figure><p><br>    在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call(),完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。(在不给函数传递参数的情况下，使用哪个方法都无所谓。)<br></p><p><br>    事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor();             // red</div><div class="line"></div><div class="line">sayColor.call(this);    // red</div><div class="line">sayColor.call(window);  // red</div><div class="line">sayColor.call(o);       // blue</div></pre></td></tr></table></figure><p><br>    这个例子是在前面说明this对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示“red”——因为对this.color的求值会转换成对window.color的求值。而sayColor.call(this)和sayColor.call(window),则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示“red”。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是“blue”。<br></p><p><br>    使用call()(或apply())来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。<br></p><p><br>    ECMAScript 5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor();// blue</div></pre></td></tr></table></figure><p><br>    在这里，sayColor()调用bind()并传入对象o，创建了objectSayColor()函数。objectSayColor()函数的this值等于o，因此即使是在全局作用域中调用这个函数，也会看到“blue”。<br></p><p><br>    支持bind()方法的浏览器有IE 9+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。<br></p><p><br>    每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即有解析器删除了注释并对某些代码做了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf()方法同样也只返回函数代码。<br></p><h3 id="1-5-基本包装类型"><a href="#1-5-基本包装类型" class="headerlink" title="1.5 基本包装类型"></a>1.5 基本包装类型</h3><p><br>    为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。这些类型与前面介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">var s2 = s1.substring(2);</div></pre></td></tr></table></figure><p><br>    这个例子中的变量s1包含一个字符串，字符串当然是基本类型值。而下一行调用了s1的substring()方法，并将返回的结果保存在了s2中。我们子道，基本类型值不是对象，因为从逻辑上讲它们不应该有方法(尽管如我们所愿，它们确实有方法)。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问s1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。<br></p><p><br>    (1) 创建String类型的一个实例；<br>    (2) 在实例上调用指定的方法；<br>    (3) 销毁这个实例。<br>    可以将以上三个步骤想象成是执行下列ECMAScript代码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = new String(&quot;some text&quot;);</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s1 = null;</div></pre></td></tr></table></figure><p><br>    经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于Boolean和Number类型对应的布尔值和数字值。<br></p><p><br>    引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">s1.color = &quot;red&quot;;</div><div class="line">alert(s1.color);// undefined</div></pre></td></tr></table></figure><p><br>    在此，第二行代码试图为字符串s1添加一个color属性。但是，当第三行代码再次访问s1时，其color属性不见了。问题的原因就是第二行创建的String对象在执行第三行代码时已经被销毁了。第三行代码又创建自己的String对象，而该对象没有color属性。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>引用类型（一）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>引用类型的值(对象)是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因此它们描述的是一类对象所具有的属性和方法。</p></blockquote><p><br>    如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div></pre></td></tr></table></figure><p><br>    这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型(例如Object)，以便开发人员用以实现常见的计算任务。<br></p><h3 id="1-1-Object类型"><a href="#1-1-Object类型" class="headerlink" title="1.1 Object类型"></a>1.1 Object类型</h3><p><br>    到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。<br></p><p><br>    创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure><p><br>    另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的person对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &apos;Nicholas&apos;,</div><div class="line">    age: 29</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    在这个例子中，左边的花括号({)表示对象字面量的开始，因为它出现在了表达式上下文中(expression context)中。ECMAScript中的表达式上下文值得是能够返回一个值(表达式)。赋值操作符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文(statement context)中，例如跟在if语句条件的后面，则表示一个语句块的开始。<br></p><p><br>    然后，我们定义了name属性，之后是一个冒号，再后面是这个属性的值。在对象字面量中，使用逗号来分隔不同的属性，因此’Nicholas’后面是一个逗号。但是，在age属性的值29的后面不能添加逗号，因为age是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在IE7及更早版本和Opera中导致错误。<br></p><p><br>    在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    &quot;name&quot;: &quot;Nicholas&quot;,</div><div class="line">    &quot;age&quot;: 29,</div><div class="line">    5: true</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    这个例子会创建一个对象，包含三个属性：name、age和5.但这里的数值属性名会自动转换为字符串。<br></p><p><br>    另外，使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;// 与new Object()相同</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure><p><br>    这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。<br></p><blockquote><p>在通过对象字面量定义对象时，实际上不会调用Object构造函数(Firefox 2及更早版本会调用Object构造函数；但Firefox 3之后就不会了)。</p></blockquote><p><br>    虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function displayInfo (args) &#123;</div><div class="line">    var output = &quot;&quot;;</div><div class="line">    if (typeof args.name == &quot;string&quot;) &#123;</div><div class="line">        output += &quot;Name: &quot; + args.name + &quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    if (typeof args.age == &quot;number&quot;) &#123;</div><div class="line">        output += &quot;Age: &quot; + args.age +&quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    alert(output);</div><div class="line">&#125;</div><div class="line">displayInfo(&#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    age: 29</div><div class="line">&#125;);</div><div class="line">displayInfo(&#123;</div><div class="line">    name: &quot;Greg&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><br>    在这个例子中，函数displayInfo()接受一个名为args的函数。这个参数可能带有一个名为name或age的属性，也可能这两个属性都有或者都没有。在这个函数内部，我们通过typeof操作符来检测每个属性是否存在，然后再基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都是用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。<br></p><blockquote><p>这种传递参数的模式最适合需要向函数传入大量可选参数的情形。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p></blockquote><p><br>    一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，在JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中，如下面的例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person[&quot;name&quot;]);// &quot;Nicholas&quot;</div><div class="line">alert(person.name);// &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量来访问属性，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var propertyName = &quot;name&quot;;</div><div class="line">alert(person[propertyName]);// &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    如果属性名中包含导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person[&quot;first name&quot;] = &quot;Nicholas&quot;;</div></pre></td></tr></table></figure><p><br>    由于“first name”中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包含非字母非数字的，这时候就可以使用方括号表示法来访问它们。<br></p><p><br>    通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。<br></p><h3 id="1-2-Date类型"><a href="#1-2-Date类型" class="headerlink" title="1.2 Date类型"></a>1.2 Date类型</h3><p><br>    ECMAScript中的Date类型是在早期Java中的java.util.Date基础上构建的。为此，Date类型使用自UTC(Coordinated Universal Time, 国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的285616年。<br></p><p><br>    要创建一个日期对象，使用new操作符和Date构造函数即可，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var now = new Date();</div></pre></td></tr></table></figure><p><br>    在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示日期的毫秒数(即从UTC时间1970年1月1日午夜起至该日期止经过的毫秒数)。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。<br></p><p><br>    其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国浏览器通常都接受下列日期格式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) “月/日/年”，如6/13/2004;</div><div class="line">b) “英文月名 日，年”，如January 12, 2004;</div><div class="line">c) “英文星期几 英文月名 日 年 时：分：秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700;</div><div class="line">d) ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ(例如 2004-05-25T00:00:00)。只有兼容ECMAScript 5的实现支持这种格式。</div></pre></td></tr></table></figure><p><br>    例如，要为2004年5月25日创建一个日期对象，可以使用下面的代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));</div></pre></td></tr></table></figure><p><br>    如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前面的例子是等价的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var someDate = new Date(&quot;May 25, 2004&quot;);</div></pre></td></tr></table></figure><p><br>    这行代码将会得到与前面相同的日期对象。<br></p><blockquote><p>日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超出范围的值替换成当前的值，以便生成输出。例如，在解析“January 32,2007”时，有的浏览器会将其解释为“February 1, 2007”。而Opera则倾向于插入当前月份的当前日期，返回“January 当前日期，2007”。也就是说，如果在2007年9月21日运行前面的代码，将会得到“January 21,2007”(都是21日)。</p></blockquote><p><br>    Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0的月份(一月是0，二月是1，以此类推)、月中的哪一天(1到31)、小时数(0到23)、分钟、秒以及毫秒数。在这些参数中，只有前面两个参数(年和月)是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0.以下是两个使用Date.UTC()方法的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// GMT 时间2000年1月1日午夜零时</div><div class="line">var y2k = new Date(Date.UTC(2000, 0));</div><div class="line"></div><div class="line">// GMT 时间2005年5月5日下午5:55:55</div><div class="line">var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</div></pre></td></tr></table></figure><p><br>    这个例子创建了两个日期对象。第一个对象表示GMT时间2000年1月1日午夜零时，传入的值一个是表示年份的2000，一个是表示月份的0(即一月份)。因为其他参数是自动填充的(即月中的天数为1，其他所有参数均为0)，所以结果就是该月第一天的午夜零时。第二个对象表示GMT时间2005年5月5日下午5:55:55，即使日期和时间中只包含5，也需要传入不一样的参数：月份必须是4(因为月份是基于0的)、小时必须设置为17(因为小时以0到23表示)，剩下的参数就很直观了。<br></p><p><br>    如同模仿Date.parse()一样，Date构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTC()相同。因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。据此，可以将前面的例子重写如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 本地时间2000年1月1日午夜零时</div><div class="line">var y2k = new Date(2000, 0);</div><div class="line">// 本地时间2005年5月5日下午5:55:55</div><div class="line">var allFives = new Date(2005, 4, 5, 17, 55, 55);</div></pre></td></tr></table></figure><p><br>    以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区而创建的。<br></p><p><br>    ECMAScript 5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Date对象分析代码的工作。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 取得开始时间</div><div class="line">var start = Date.now();</div><div class="line"></div><div class="line">// 调用函数</div><div class="line">doSomething();</div><div class="line"></div><div class="line">// 取得停止时间</div><div class="line">var stop = Date.now(),</div><div class="line">    result = stop - start;</div></pre></td></tr></table></figure><p><br>    支持Date.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支持它的浏览器中，使用+操作符把Date对象转换成字符串，也可以达到同样的目的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 取得开始时间</div><div class="line">var start = +new Date();</div><div class="line"></div><div class="line">// 调用函数</div><div class="line">doSomething();</div><div class="line">// 取得停止时间</div><div class="line">var stop = +new Date(),</div><div class="line">    result = stop - start;</div></pre></td></tr></table></figure><h3 id="1-2-1-继承的方法"><a href="#1-2-1-继承的方法" class="headerlink" title="1.2.1 继承的方法"></a>1.2.1 继承的方法</h3><p><br>    与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法；但这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息(当然，具体的格式会因浏览器而异)。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间(即小时的范围是0到23)表示。下面给出了在不同浏览器中调用toLocaleString()和toString()方法，输出PST(Pacific Standard Time, 太平洋标准时间)时间2007年2月1日午夜零时的结果。<br></p><p><img src="https://shaoqianheng.github.io/images/h-5-1.png"></p><p><br>    显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。<br></p><p><br>    至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符(小于或大于)来比较日期值。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var date1 = new Date(2007, 0, 1);// &quot;January 1, 2007&quot;</div><div class="line">var date2 = new Date(2007, 1, 1);// &quot;February 1, 2007&quot;</div><div class="line"></div><div class="line">alert(date1 &lt; date2);// true</div><div class="line">alert(date1 &gt; date2);// false</div></pre></td></tr></table></figure><p><br>    从逻辑上讲，2007年1月1日要早于2007年2月1日，此时如果我们说前者小于后者比较符合常理。而表示2007年1月1日的毫秒值小于表示2007年2月1日的毫秒值，因此在首先使用小于操作符比较日期时，返回的结果是true。这样，就为我们比较日期提供了极大方便。<br></p><h3 id="1-2-2-日期格式化方法"><a href="#1-2-2-日期格式化方法" class="headerlink" title="1.2.2 日期格式化方法"></a>1.2.2 日期格式化方法</h3><p><br>    Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a) toDateString() —— 以特定于实现的格式显示星期几、月、日和年；</div><div class="line">b) toTimeString() —— 以特定于实现的格式显示时、分、秒和时区；</div><div class="line">c) toLocaleDateString() —— 以特定于地区的格式显示星期几、月、日和年；</div><div class="line">d) toLocaleTimeString() —— 以特定于实现的格式显示时、分、秒；</div><div class="line">e) toUTCString() —— 以特定于实现的格式完整的UTC日期。</div></pre></td></tr></table></figure><p><br>    与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。<br></p><blockquote><p>除了前面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写的代码一律使用toUTCString()方法。</p></blockquote><h3 id="1-2-3-日期-时间组件方法"><a href="#1-2-3-日期-时间组件方法" class="headerlink" title="1.2.3 日期/时间组件方法"></a>1.2.3 日期/时间组件方法</h3><p><br>    到目前为止，剩下还未介绍的Date类型的方法(如下表所示)，都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC日期指的是在没有时区偏差的情况下(将日期转换为GMT时间)的日期值。<br></p><p><img src="https://shaoqianheng.github.io/images/h-5-2.png"></p><h3 id="1-3-RegExp类型"><a href="#1-3-RegExp类型" class="headerlink" title="1.3 RegExp类型"></a>1.3 RegExp类型</h3><p><br>    ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var expression = / pattern / flags;</div></pre></td></tr></table></figure><p><br>    其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g：表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</div><div class="line">i：表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写；</div><div class="line">m：表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</div></pre></td></tr></table></figure><p><br>    因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 匹配字符串中所有“at”的实例</div><div class="line">var pattern1 = /at/g;</div><div class="line">// 匹配第一个“bat”或“cat”，不区分大小写</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line">// 匹配所有以“at”结尾的3个字符的组合，不区分大小写</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure><p><br>    与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( [ &#123; \ ^ $ | ) ? * + . ] &#125;</div></pre></td></tr></table></figure><p><br>    这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 匹配第一个“bat”或“cat”,不区分大小写</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">// 匹配第一个“[bc]at”,不区分大小写</div><div class="line">var pattern2 = /\[bc\]at/i;</div><div class="line">// 匹配所有以“at”结尾的3个字符的组合，不区分大小写</div><div class="line">var pattern3 = /.at/gi;</div><div class="line">// 匹配所有“.at”，不区分大小写</div><div class="line">var pattern4 = /\.at/gi;</div></pre></td></tr></table></figure><p><br>    在上面的例子中，pattern1匹配第一个“bat”或“cat”，不区分大小写。而要想直接匹配“[bc]at”的话，就需要像定义pattern2一样，对其中的两个方括号进行转义。对于pattern3来说，句点表示位于“at”之前的任意一个可以构成匹配项的字符。但如果想匹配“.at”，则必须对句点本身进行转义，如pattern4所示。<br></p><p><br>    前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 匹配第一个“bat”或“cat”，不区分大小写</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">// 与pattern1相同，只不过是使用构造函数创建的</div><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure><p><br>    在此，pattern1和pattern2是两个完全等价的正则表达式。要注意的是，传递给RegExp构造函数的两个参数都是字符串(不能把正则表达式字面量传给RegExp构造函数)。有RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n(字符\在字符串中通常被转义为\,而在正则表达式字符串中就会变成\\)。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义相同模式时使用的字符串。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">字面量模式             等价的字符串</div><div class="line">/\[bc\]at/             &quot;\\[bc\\]at&quot;</div><div class="line">/\.at/                 &quot;\\.at&quot;</div><div class="line">/name\/age/            &quot;name\\/age&quot;</div><div class="line">/\d.\d&#123;1,2&#125;/           &quot;\\d.\\d&#123;1,2&#125;&quot;</div><div class="line">/\w\\hello\\123/       &quot;\\w\\\\hello\\\\123&quot;</div></pre></td></tr></table></figure><p><br>    使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var re = null,</div><div class="line">    i;</div><div class="line"></div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">re = /cat/g;</div><div class="line">re.test(&quot;catastrophe&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">re = new RegExp(&quot;cat&quot;, &quot;g&quot;);</div><div class="line">re.test(&quot;catastrophe&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在第一个循环中，即使是循环体指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性不会重置，所以在循环中再次调用test()方法会失败。这是因为第一个调用test()找到了“cat”。但第二次调用是从索引为3的字符(上一次匹配的末尾)开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就有从头开始了。<br></p><p><br>    第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp实例，所以每次调用test()都会返回true。<br></p><p><br>    ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一眼，每次都创建新的RegExp实例。IE9+、Firefox4+和Chrome都据此做出了修改。<br></p><h3 id="1-3-1-RegExp实例属性"><a href="#1-3-1-RegExp实例属性" class="headerlink" title="1.3.1 RegExp实例属性"></a>1.3.1 RegExp实例属性</h3><p><br>    RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a) global：布尔值，表示是否设置了g标志。</div><div class="line">b) ignoreCase：布尔值，表示是否设置了i标志。</div><div class="line">c) lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</div><div class="line">d) multiline：布尔值，表示是否设置了m标志。</div><div class="line">e) source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</div></pre></td></tr></table></figure><p><br>    通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var pattern1 = /\[bc\]at/i;</div><div class="line"></div><div class="line">alert(pattern1.global);// false</div><div class="line">alert(pattern1.ignoreCase);// true</div><div class="line">alert(pattern1.multiline);// false</div><div class="line">alert(pattern1.lastIndex);// 0</div><div class="line">alert(pattern1.source);// &quot;\[bc\]at&quot;</div><div class="line"></div><div class="line">var pattern2 = new RegExp(&quot;\\[bc\\]at&quot;, &quot;i&quot;);</div><div class="line"></div><div class="line">alert(pattern2.global);// false</div><div class="line">alert(pattern2.ignoreCase);// true</div><div class="line">alert(pattern2.multiline);// false</div><div class="line">alert(pattern2.lastIndex);// 0</div><div class="line">alert(pattern2.source);// &quot;\[bc\]at&quot;</div></pre></td></tr></table></figure><p><br>    我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了RegExp构造函数，但它们的source属性是相同的。可见，source属性保存的是规范形式的字符串，即字面量形式所用的字符串。<br></p><h3 id="1-3-2-RegExp实例方法"><a href="#1-3-2-RegExp实例方法" class="headerlink" title="1.3.2 RegExp实例方法"></a>1.3.2 RegExp实例方法</h3><p><br>    RegExp对象的主要方法是exec(),该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)。请看下面这个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var text = &quot;mom and dad and baby&quot;;</div><div class="line">var pattern = /mom( and dad( and baby)?)?/gi;</div><div class="line"></div><div class="line">var matches = pattern.exec(text);</div><div class="line">alert(matches.index);// 0</div><div class="line">alert(matches.input);// &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[0]);// &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[1]);// &quot; and dad and baby&quot;</div><div class="line">alert(matches[2]);// &quot; and baby&quot;</div></pre></td></tr></table></figure><p><br>    这个例子中的模式包含两个捕获组。最内部的捕获组匹配“and baby”，而包含它的捕获组匹配“and dad”或者“and dad and baby”。当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs的index属性值为0.数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。<br></p><p><br>    对于exec()方法而言，即使在模式中设置了全局标志(g),他每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pattern1 = /.at/;</div><div class="line"></div><div class="line">var matches = pattern1.exec(text);</div><div class="line">alert(matches.index);// 0</div><div class="line">alert(matches[0]);// cat</div><div class="line">alert(pattern.lastIndex);// 0</div><div class="line"></div><div class="line">matches = pattern1.exec(text);</div><div class="line">alert(matches.index);// 0</div><div class="line">alert(matches[0]);// cat</div><div class="line">alert(matches.lastIndex);   // 0</div><div class="line"></div><div class="line">var pattern2 = /.at/g;</div><div class="line"></div><div class="line">var matches = pattern2.exec(text);</div><div class="line">alert(matches.index);// 0</div><div class="line">alert(matches[0]);// cat</div><div class="line">alert(pattern2.lastIndex);// 3</div><div class="line"></div><div class="line">matches = pattern2.exec(text);</div><div class="line">alert(matches.index);// 5</div><div class="line">alert(matches[0]);// bat</div><div class="line">alert(pattern2.lastIndex);// 8</div></pre></td></tr></table></figure><p><br>    这个例子中的第一个模式pattern1不是全局模式，因此每次调用exec()返回的都是第一个匹配项(“cat”)。而第二个模式pattern2是全局模式，因此每次调用exec()都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的lastIndex属性的变化情况。在全局匹配模式下，lastIndex的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。<br></p><blockquote><p>IE的JavaScript实现在lastIndex属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。</p></blockquote><p><br>    正则表达式的第二个方法是text()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;000-00-0000&quot;;</div><div class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</div><div class="line"></div><div class="line">if (pattern.text(text)) &#123;</div><div class="line">alert(&quot;The pattern was matched.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个例子中，我们使用正则表达式来测试一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效就无关紧要了。<br></p><p><br>    RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var pattern = new RegExp(&quot;\\[bc\\]at&quot;, &quot;gi&quot;);</div><div class="line">alert(pattern.toString());// /\[bc\]at/gi</div><div class="line">alert(pattern.toLocaleString());// /\[bc\]at/gi</div></pre></td></tr></table></figure><p><br>    即使上例中的模式是通过调用RegExp构造函数创建的，但toLocaleString()和toString()方法仍然会像它是以字面量形式创建的一样显示其字符串表示。<br></p><blockquote><p>正则表达式的valueOf()方法返回正则表达式本身。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的程序设计（一）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>面向对象(Object-Oriented, OO)的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。</p></blockquote><p>ECMAScript-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样，我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。</p><p>每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。</p><h3 id="1-1-理解对象"><a href="#1-1-理解对象" class="headerlink" title="1.1 理解对象"></a>1.1 理解对象</h3><p><br>    曾经介绍过，创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div><div class="line">person.job = &quot;Software Engineer&quot;;</div><div class="line"></div><div class="line">person.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    上面的例子创建了一个名为person的对象，并为它添加了三个属性(name、age和job)和一个方法(sayName())。其中，sayName()方法用于显示this.name(将被解析为person.name)的值。早期的JavaScript开发人员经常使用这个模式创建新对象。几年后，对象字面量成为创建这种对象的首选模式。前面的例子用对象字面量语法可以写成这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    age: 29,</div><div class="line">    job: &quot;Software Engineer&quot;,</div><div class="line"></div><div class="line">    sayName: function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    这个例子中的person对象与前面例子中的person对象是一样的，都有相同的属性和方法。这些属性在创建时都带有一些特征值(characteristic)，JavaScript通过这些特征值来定义它们的行为。<br></p><h3 id="1-1-1-属性类型"><a href="#1-1-1-属性类型" class="headerlink" title="1.1.1 属性类型"></a>1.1.1 属性类型</h3><p><br>    ECMA-262第5版在定义只有内部才用的特性(attribute)时，描述了属性(property)的各种特征。ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对方括号中，例如[[Enumerable]]。<br></p><p><br>    ECMAScript中有两种属性：数据属性和访问器属性。<br></p><h4 id="1-数据属性"><a href="#1-数据属性" class="headerlink" title="1.数据属性"></a>1.数据属性</h4><p><br>    数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(1) [[Configurable]] : 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</div><div class="line"></div><div class="line">(2) [[Enumerable]] : 表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</div><div class="line"></div><div class="line">(3) [[Writable]] : 表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们这个特性默认值为true。</div><div class="line"></div><div class="line">(4) [[Value]] : 包含这个属性的数据值。读取属性值的时候，从这个位置上读，写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</div></pre></td></tr></table></figure><p><br>    对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    这里创建了一个名为name的属性，为它指定的值是“Nicholas”。也就是说，[[Value]]特性将被设置为“Nicholas”，而对这个值的任何修改都反映在这个位置。<br></p><p><br>    要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符(descriptor)对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对应的特性值。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;；</div><div class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">    writable: false,</div><div class="line">    value: &quot;Nicholas&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div><div class="line">person.name = &quot;Greg&quot;;</div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    这个例子创建了一个名为name的属性，它的值“Nicholas”是只读的。这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。<br></p><p><br>    类似的规则也适用于不可配置的属性。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">    configurable: false,</div><div class="line">    value: &quot;Nicholas&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div><div class="line">delete person.name;</div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用Object.defineProperty()方法修改除了writable之外的特性，都会导致错误：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   var person = &#123;&#125;;</div><div class="line">   Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">       configurable: false,</div><div class="line">       value: &quot;Nicholas&quot;</div><div class="line">   &#125;);</div><div class="line"></div><div class="line">   // 抛出错误</div><div class="line">   Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">   configurable: true,</div><div class="line">   value: &quot;Nicholas&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><br>    也就是说，可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。<br></p><p><br>    在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功能。不过，理解这些概念对理解JavaScript对象却非常有用。<br></p><blockquote><p>IE8是第一个实现Object.defineProperty()方法的浏览器版本。然而，这个版本的实现存在诸多限制：只能在DOM对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，建议不要在IE8中使用Object.defineProperty()方法。</p></blockquote><h4 id="2-访问器属性"><a href="#2-访问器属性" class="headerlink" title="2. 访问器属性"></a>2. 访问器属性</h4><p><br>    访问器属性不包含数据值；它们包含一对getter和setter函数(不过，这两个函数都不是必需的)。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(1) [[Configurable]] : 表示能够通过delete属性删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</div><div class="line"></div><div class="line">(2) [[Enumerable]] : 表示能否通过for-in循环返回属性。对于直接在对象上定义的对象，这个特性的默认值为true。</div><div class="line"></div><div class="line">(3) [[Get]] : 在读取属性时调用的函数。默认值为undefined。</div><div class="line"></div><div class="line">(4) [[Set]] : 在写入属性时调用的函数。默认值为undefined。</div></pre></td></tr></table></figure><p><br>    访问器属性不能直接定义，必须使用Object.defineProperty()来定义。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;</div><div class="line">       _year: 2004,</div><div class="line">       edition: 1</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   Object.defineProperty(book, &quot;year&quot;, &#123;</div><div class="line">       get: function() &#123;</div><div class="line">       return this._year;</div><div class="line">       &#125;,</div><div class="line">       set: function(newValue) &#123;</div><div class="line">       if (newValue &gt; 2004) &#123;</div><div class="line">       this._year = newValue;</div><div class="line">       this.edition += newValue - 2004;</div><div class="line">       &#125;</div><div class="line">       &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = 2005;</div><div class="line">alert(book.edition);    // 2</div></pre></td></tr></table></figure><p><br>    以上代码创建了一个book对象，并给它定义了两个默认的属性：_year和edition。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year则包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致_year变成2005，而edition变为2.这是使用访问器属性的常见方式，即设置一个属性会导致其他属性发生变化。<br></p><p><br>    不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。<br></p><p><br>    支持ECMAScript 5的这个方法的浏览器有IE 9+(IE8只是部分实现)、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器属性，一般都是用两个非标准的方法：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。这两个方法最初由Firefox引入的，后来Safari 3、Chrome 1和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;</div><div class="line">       _year: 2004,</div><div class="line">       edition: 1</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   // 定义访问器的旧有方法</div><div class="line">   book.__defineGetter__(&quot;year&quot;, function() &#123;</div><div class="line">       return this._year;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.__defineSetter__(&quot;year&quot;, function(newValue) &#123;</div><div class="line">    if (newValue &gt; 2004) &#123;</div><div class="line">    this._year = newValue;</div><div class="line">    this.edition += newValue - 2004;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = 2005;</div><div class="line">alert(book.edition);    // 2</div></pre></td></tr></table></figure><p><br>    在不支持Object.defineProperty()方法的浏览器中不能修改[[Configurable]]和[[Enumerable]].<br></p><h3 id="1-1-2-定义多个属性"><a href="#1-1-2-定义多个属性" class="headerlink" title="1.1.2 定义多个属性"></a>1.1.2 定义多个属性</h3><p><br>    由于为对象定义多个属性的可能性很大，ECMAScript 5有定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;&#125;;</div><div class="line"></div><div class="line">   Object.defineProperties(book, &#123;</div><div class="line">   _year: &#123;</div><div class="line">   value: 2004</div><div class="line">   &#125;,</div><div class="line">   edition: &#123;</div><div class="line">   value: 1</div><div class="line">   &#125;,</div><div class="line">   year: &#123;</div><div class="line">   get: function() &#123;</div><div class="line">   return this._year;</div><div class="line">   &#125;,</div><div class="line">   set: function(newValue) &#123;</div><div class="line">   if(newValue &gt; 2004) &#123;</div><div class="line">   this._year = newValue;</div><div class="line">   this.edition += newValue - 2004;</div><div class="line">   &#125;</div><div class="line">   &#125;</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><br>    以上代码在book对象上定义了两个数据属性(_year和edition)和一个访问器属性(year).最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。<br></p><p><br>    支持Object.defineProperties()方法的浏览器有IE 9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br></p><h3 id="1-1-3-读取属性的特性"><a href="#1-1-3-读取属性的特性" class="headerlink" title="1.1.3 读取属性的特性"></a>1.1.3 读取属性的特性</h3><p><br>    使用ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;&#125;;</div><div class="line"></div><div class="line">   Object.defineProperties(book, &#123;</div><div class="line">       _year: &#123;</div><div class="line">       value: 2004</div><div class="line">       &#125;,</div><div class="line">       edition: &#123;</div><div class="line">       value: 1</div><div class="line">       &#125;,</div><div class="line">       year: &#123;</div><div class="line">       get: function() &#123;</div><div class="line">       return this._year;</div><div class="line">       &#125;,</div><div class="line">       set: function(newValue) &#123;</div><div class="line">       if(newValue &gt; 2004) &#123;</div><div class="line">       this._year = newValue;</div><div class="line">       this.edition += newValue - 2004;</div><div class="line">       &#125;</div><div class="line">       &#125;</div><div class="line">       &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);</div><div class="line">alert(descriptor.value);           // 2004</div><div class="line">alert(descriptor.configurable);    // false</div><div class="line">   alert(typeof descriptor.get);      // &quot;undefined&quot;</div><div class="line"></div><div class="line">   var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);</div><div class="line">   alert(descriptor.value);          // undefined</div><div class="line">   alert(descriptor.enumerable);     // false</div><div class="line">   alert(typeof descriptor,get);     // &quot;function&quot;</div></pre></td></tr></table></figure><p><br>    对于数据属性_year,value等于最初的值，configurable是false，而get等于undefined。对于访问器属性year，value等于undefined，enumerable是false，而get是一个指向getter函数的指针。<br></p><p><br>    在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br></p><h3 id="1-2-创建对象"><a href="#1-2-创建对象" class="headerlink" title="1.2 创建对象"></a>1.2 创建对象</h3><blockquote><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p></blockquote><h3 id="1-2-1-工厂模式"><a href="#1-2-1-工厂模式" class="headerlink" title="1.2.1 工厂模式"></a>1.2.1 工厂模式</h3><p><br>    工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age, job) &#123;</div><div class="line">    var o = new Object();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = function() &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">    return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure><p><br>    函数createPerson()能够根据接受的参数来创建一个包含所有必要信息的Person对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)。随着JavaScript的发展，又一个新模式出现了。<br></p><h3 id="1-2-2-构造函数模式"><a href="#1-2-2-构造函数模式" class="headerlink" title="1.2.2 构造函数模式"></a>1.2.2 构造函数模式</h3><p><br>    ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = function() &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure><p><br>    在这个例子中，Person()函数取代了createPerson()函数。我们注意到，Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：<br>    (1) 没有显式地创建对象；<br>    (2) 直接将属性和方法赋给了this对象；<br>    (3) 没有return语句。<br></p><p><br>    此外，还应该注意到函数名Person使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别于ECMAScript中的其他函数；因此构造函数本身也是函数，只不过可以用来创建对象而已。<br></p><p><br>    要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：<br>    (1) 创建一个新对象；<br>    (2) 将构造函数的作用域赋给新对象(因此this就指向了这个新对象)；<br>    (3) 执行构造函数中的代码(为这个新对象添加属性)；<br>    (4) 返回新对象。<br></p><p><br>    在前面例子的最后，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor(构造函数)属性，该属性指向Person，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person1.constructor == Person);    // true</div><div class="line">alert(person2.constructor == Person);    // true</div></pre></td></tr></table></figure><p><br>    对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object的实例，同时也是Person的实例，这一点通过instanceof操作符可以得到验证。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(person1 instanceof Object);    // true</div><div class="line">alert(person1 instanceof Person);    // true</div><div class="line">alert(person2 instanceof Object);    // true</div><div class="line">alert(person2 instanceof Person);    // true</div></pre></td></tr></table></figure><p><br>    创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，person1和person2之所以同时是Object的实例，是因为所有对象均继承自Object。<br></p><blockquote><p>以这种方式定义的构造函数是定义在Global对象(在浏览器中是window对象)中的。</p></blockquote><h4 id="1-将构造函数当作函数"><a href="#1-将构造函数当作函数" class="headerlink" title="1. 将构造函数当作函数"></a>1. 将构造函数当作函数</h4><p><br>    构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义的Person()函数可以通过下列任何一种方式来调用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 当作构造函数使用</div><div class="line">var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">person.sayName();    // &quot;Nicholas&quot;</div><div class="line"></div><div class="line">// 作为普通函数调用</div><div class="line">Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);    // 添加到window</div><div class="line">window.sayName();    // &quot;Greg&quot;</div><div class="line"></div><div class="line">// 在另一个对象的作用域中调用</div><div class="line">var o = new Object();</div><div class="line">Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);</div><div class="line">o.sayName();    // &quot;Kristen&quot;</div></pre></td></tr></table></figure><p><br>    这个例子中的前两行代码展示了构造函数的典型用法，即使用new操作符来创建一个新对象。接下来的两行代码展示了不使用new操作符调用Person()会出现什么结果：属性和方法都被添加给window对象了。当在全局作用域中调用一个函数时，this对象总是指向Global对象(在浏览器中就是window对象)。因此，在调用完函数之后，可以通过window对象来调用sayName()方法，并且还返回“Greg”。最后，也可以使用call()(或者apply())在某个特殊对象的作用域中调用Person()函数。这里是在对象o的作用域中调用的，因此调用后o就拥有了所有属性和sayName()方法。<br></p><h4 id="2-构造函数的问题"><a href="#2-构造函数的问题" class="headerlink" title="2. 构造函数的问题"></a>2. 构造函数的问题</h4><p><br>    构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了——ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = new Funtion(&quot;alert(this.name&quot;);    // 与声明函数在逻辑上是等价的</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例(以显示name属性)的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以证明这一点。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName == person2.sayName);    // false</div></pre></td></tr></table></figure><p><br>    然而，创建两个完成同样任务的Function实例的确没有必要；况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转义到构造函数外来解决这个问题。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sayName() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure><p><br>    在这个例子中，我们把sayName()函数的定义转移到了构造函数的外部。而在构造函数内部，我们将sayName属性设置成等于全局的sayName函数。这样一来，由于sayName包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用域中定义的同一个sayName()函数。这样做确实解决了两个函数做同一件事的问题，可是新的问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型模式来解决。<br></p><h3 id="1-2-3-原型模式"><a href="#1-2-3-原型模式" class="headerlink" title="1.2.3 原型模式"></a>1.2.3 原型模式</h3><p><br>    我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话来说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName();    // &quot;Nicholas&quot;</div><div class="line"></div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName();    // &quot;Nicholas&quot;</div><div class="line"></div><div class="line">alert(person1.sayName == person2.sayName);    // true</div></pre></td></tr></table></figure><p><br>    在此，我们将sayName()方法和所有属性直接添加到了Person的prototype属性中。构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。<br></p><h4 id="1-理解原型对象"><a href="#1-理解原型对象" class="headerlink" title="1.理解原型对象"></a>1.理解原型对象</h4><p><br>    无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br></p><p><br>    创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]].虽然在脚本中没有标准的方式访问[[Prototype]],但Firefox、Safari和Chrome在每个对象上都支持一个属性<strong>proto</strong>;而在其他实现中，这个属性对脚本则是完全可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。<br></p><p><br>    以前面使用Person构造函数和Person.prototype创建实例的代码为例，图1-1展示了各个对象之间的关系。<br></p><p><img src="https://shaoqianheng.github.io/images/h-6-1.png"></p><p><br>    图1-1展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。<br></p><p><br>    虽然在所有实现中都无法访问[[Prototype]],但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象(Person.prototype),那么这个方法就返回true，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Person.prototype.isPrototypeOf(person1));    // true</div><div class="line">alert(Person.prototype.isPrototypeOf(person2));    // true</div></pre></td></tr></table></figure><p><br>    这里，我们用原型对象的isPrototypeOf()方法测试了person1和person2.因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。<br></p><p><br>    ECMAScript 5增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Object.getPrototypeOf(person1) == Person.prototype);    // true</div><div class="line">alert(Object.getPrototypeOf(person1).name);    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure><p><br>    这里的第一行代码只是确定Object.getPrototypeOf()返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是“Nicholas”。使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。支持这个方法的浏览器有IE 9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。<br></p><p><br>    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName()的时候，会先后执行两次搜索。首先，解析器会问：“实例person1有sayName属性吗？”答：“没有”。然后，它继续搜索，再问：“person1的原型有sayName属性吗？”答：“有”。于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果，而这正是多个对象实例共享原型所包存的属性和方法的基本原理。<br></p><blockquote><p>前面提到过，原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问。</p></blockquote><p><br>    虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div></pre></td></tr></table></figure><p><br>    在这里例子中，person1的name被一个新值给屏蔽了。但无论访问person1.name还是访问person2.name都能够正常地返回值，即分别是“Greg”(来自对象实例)和“Nicholas”(来自原型)。当在alert()中访问person1.name时，需要读取它的值，因此就会在这个实例上搜索一个名为name的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问person2.name时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name属性。<br></p><p><br>    当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);    // &quot;Nicholas&quot;——来自原型</div></pre></td></tr></table></figure><p><br>    在这个修改后的例子中，我们使用delete操作符删除了person1.name，之前它保存的“Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用person1.name是，返回的就是原型中name属性的值了。<br></p><p><br>    使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法(不要忘了它是从Object继承来的)只在给定属性存在于实例中时，才会返回true。来看下面这个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // true</div><div class="line"></div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person2.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div></pre></td></tr></table></figure><p><br>    通过使用hasOwnProperty()方法，什么时候访问的是实例属性，什么时候访问的是原型属性就一清二楚了。调用person1.hasOwnProperty(“name”)时，只有当person1重写name属性后才会返回true，因为只有这时候name才是一个实例属性，而非原型属性。图1-2展示了上面例子在不同情况下的实现与原型的关系(为了简单起见，图中省略了与Person构造函数的关系).<br></p><p><img src="https://shaoqianheng.github.io/images/h-6-2.png"></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>群書治要360 (一)</title>
      <link href="/2018/06/27/%E7%BE%A4%E4%B9%A6%E6%B2%BB%E8%A6%81360%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/27/%E7%BE%A4%E4%B9%A6%E6%B2%BB%E8%A6%81360%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="《群書治要》序"><a href="#《群書治要》序" class="headerlink" title="《群書治要》序"></a>《群書治要》序</h3><p><br>    《群書治要》是唐太宗李世明（西元五九九年——六四九年）於貞觀初年下令編輯。太宗十六歲隨父從軍，起義平定動亂的社會，戎馬倥傯十餘年。二十七歲即帝位後，偃武修文，特別留心於治平之道，休生養民。<br></p><p><br>    太宗英武善辯，遺憾早年從軍，讀書不多。鑒於前隋滅亡之失，深知創業不易，守成維艱，在位期間，鼓勵群臣進諫，批評其決策過失。令諫官魏征及虞世南等，整理歷代帝王治國資政史料，擷取六經、四史、諸子百家中，有關修身、齊家、治國、平天下之精要，匯編成書。上始五帝，下迄晉代，自一萬四千多部、八萬九千多卷古籍中，博采典籍六十五種，共五十餘萬言。<br></p><p><br>    書成，如魏征於序文中所說，實為一部[用之當今你，足以鑒覽前古；傅之來葉，可以貽厥孫謀]的治世寶典。太宗喜其廣博而切要，日日手不釋卷。曰：[使我稽古臨事不惑者，卿等力也]。由是而知<br></p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弟子规 （四）</title>
      <link href="/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%884%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%884%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="五、信"><a href="#五、信" class="headerlink" title="五、信"></a>五、信</h3><p><br>    【解】“信”是会意字，代表人言，也就是说话要算数，说到做到。孔老夫子说：“人无信不立”。一个人假如没有信用，很难在社会上立足。当人人对你说的话、办的事都产生怀疑时，你就无法在社会、人群当中立足。因为社会是一个团体生活，假如大家都不信任你，就会离你而去，你就很难发展。所以，信用跟一个人的生命同等重要。因此，说话、做事都要以诚信为原则。特别是在生意场上，做生意最关键的就是信用，真正把诚信做到了，大家跟你合作会很欢喜，都会很愿意帮你，你的事业必定成功。所以，诚信的人可以在社会上立于不败之地。<br></p><p><br>    “信”引申来讲还包括信念的意思，一个人、一个团体、一个国家都要有信念，就是我们讲的志向。如果人没有了信念、没有了志向，人生也就没有了方向、目标，哪怕是吃的饱、穿得暖，奢华享受，那叫作混日子，说句不好听的话，一天到晚是“饱食终日，无所用心”。孟子说：“人之异于禽兽者几希。”那样的生活，是禽兽生，不是人生，人与禽兽的区别是在道德上。所以人要立志，立志做什么呢？立志做圣贤。圣贤人的生活一定幸福、圣贤人的事业一定成功。学习《弟子规》我们也要有一个正确的信念，要学做圣贤，那么幸福成功都是自然而然的。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡出言 &emsp;信为先 &emsp;诈与妄 &emsp;奚可焉</p><p style="margin-bottom: 0;"><br>    【解】开口说话，诚信为先，对自己讲出来的话绝对要在心上去实践、去履行。答应别人的事情一定要遵守承诺，没有能力做到的事不能随便答应，至于欺骗或花言巧语更不能使用。<br></p><p><br>    言语行为当中能守信，就已经奠定了一个人今后在社会上好的发展基础。假如我们不守信，还要找一些借口，赖掩饰自己的失信，那你的名声就会愈来愈差。假如有特殊原因让你是在无法实现诺言，这时就要坦诚布公，当他真正了解你的情况、了解你的诚意后，他也会退一步。但是你如果继续掩盖，他就会愈来愈愤怒，到时候就很难收拾了。所以，与别人的信诺绝不可以拖延，愈拖愈难解决。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">话说多 &emsp;不如少 &emsp;惟其是 &emsp;勿佞巧</p><p style="margin-bottom: 0;"><br>    【解】话说多了，大部分都是废话，不如少讲几句，避免过失。说话要恰到好处，谈话内容要实事求是，不着边际、没有根据的谎话，终有被识破的时候。<br></p><p><br>    所谓“言多必失”，如果你滔滔不绝，很多话还没有思考清楚就说出去了，结果就收不回来了。谚云：“是非只为多开口，烦恼皆因强出头。”人与人接触会有是非产生，就是因为话多，所以处事要少言、慎行。在讲话之前，我们首先要想一想，讲这句话自己能不能做到、能不能够对这个话负责。如果我们说的话能够做到、能够负起责任，这才能够说，如果说了话之后不能负责任，我们在他人心目中的信用就会慢慢地减少了。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">奸巧语 &emsp;秽污词 &emsp;市井气 &emsp;切戒之</p><p style="margin-bottom: 0;"><br>    【解】奸诈取巧的语言、下流肮脏的话以及街头无赖粗俗的口气，都要避免，不去沾染。如果已经被污染，就要下定决心切实戒除掉。<br></p><p><br>    说话时要戒掉一些不良的语言，言谈如果能够非常文雅，无形当中都会提升一个人的气质修养。当我们内心充满了对圣贤人的憧憬、向往，立志要成圣成贤的时候，我们的言语、行为自然就会效仿圣贤人的存心。凡是圣贤人不说不做的事情，我们绝对也不说不做。久而久之，自己那种圣贤的风范就会慢慢表露出来了，人们看到一定也会敬重你。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">见未真 &emsp;勿轻言 &emsp;知未的 &emsp;勿轻传</p><p style="margin-bottom: 0;"><br>    【解】任何事情在没有看到真相之前，不要轻易发表意见，对事情了解得不够清楚明白时，不可以任意传播，以免造成不良后果。<br></p><p><br>    即使你看到的是事情真相，也不要轻易地讲出来，因为与人相处会有纠纷及不愉快的事情发生，追根究底都是从口舌是非开始的，所以我们在讲话之前一定要想一想，这句话讲了之后它有没有后遗症？会不会破坏别人的声誉？它到底有没有利害关系？会不会破坏整个团体的和谐？千万不可以看到什么就讲什么。有些人随便听到一句闲话，再加上自己的妄想，就可以编出一件新闻。这种无根的谣言，常常惹出许多的是非，传出去后很容易跟人结怨，把自己的德行也败坏了。所谓“谣言止于智者”，我们不要被谣言所利用，聪明人碰到这些是是非非的事情，绝对不会跟着传，因为智者的心在道上，对于那些风吹草动、流言蜚语，统统都能够置之不理。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事非宜 &emsp;勿轻诺 &emsp;苟轻诺 &emsp;进退错</p><p style="margin-bottom: 0;"><br>    【解】不合义理的事，不要轻易答应。如果意气用事、轻率表态，事到临头才发现不合理，做也不是，不做也不是，那就太被动了。<br></p><p><br>    面对一件事情，首先要看应不应该去做，如果是不符合道义甚至是非法的，那就绝对不可以答应。假如我们轻易承诺以后就会进退两难，不做就是没有信用，做了又违背良心道德，这样会让自己陷入烦恼之中而无法解脱。因为有时我们与人方便，别人却变成了随便，所以在答应之前一定要详细查看内容是什么，不要先答应之后再后悔，那就来不及了。古人讲：“一言可以兴邦，一言可以丧邦。”如果我们讲话不谨慎而又事关重大，很可能会带来不堪设想的后果，尤其是在高位的领导人更要慎重。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡道字 &emsp;重且舒 &emsp;勿急疾 &emsp;勿模糊</p><p style="margin-bottom: 0;"><br>    【解】我们讲话吐字要清楚而有力，缓缓道来，要讲得很舒畅、放松。说话不可以太急，每个字都要吐得清清楚楚、不模糊，听的人也就听得很清楚、很舒服，这也避免了让人错意而造成没必要的误会。<br></p><p><br>    如果别人讲话太快，你又没有听清楚，正好又是要处理的事情，这时我们要养成一个习惯，不管是谁交代我们事情，到最后都要再给他复述一遍，这样才会万无一失。不然你似懂非懂，到时候出了偏差，就不能怪别人讲得太快，只能怪你没把话听清楚、听明白。所以我们不要怕麻烦，一定要把讲话内容确认清楚，不可马虎大意。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">彼说长 &emsp;此说短 &emsp;不关己 &emsp;莫闲管</p><p style="margin-bottom: 0;"><br>    【解】遇到他人来说是非好坏时，听听就算了，要有智慧判断，不要受影响，不要介入是非。如果与己无关，就不要多管闲事（来说是非者，便是是非人。）<br></p><p><br>    多管闲事会让自己增加很多烦恼，还会引来不愉快，跟人结怨。谚云：“利刃割体痕易合，恶语伤人恨难消。”讲人的是非、隐私，这个对人的伤害比利刃伤人更严重，引起的怨恨也更大，到时候你再怎么说对不起，也不见得能回到原来的那种关系了。所以古德说：“莫说他人短与长，说来说去自遭殃，若能闭口深藏舌，便是修行第一方。”劝导我们不说是非长短，要修养自己的厚德。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">见人善 &emsp;即思齐 &emsp;纵去远 &emsp;以渐跻</p><p style="margin-bottom: 0;"><br>    【解】见到人家的优点，我们要马上见贤思齐，向人学习。即使跟他差距很远，我们也要慢慢努力地去追赶，希望有朝一日能跟他看齐，这是一种好学的精神。<br></p><p><br>    古人云：“尺有所短，寸有所长。”看待事物和与他人相处，我们如果能多看别人的长处，不但和自己相处的人愉悦欢喜，而且最大的受益者就是自己。因为每个人在某个方面肯定都会有比我们做得好的地方，如果我们能带着谦卑的心去寻找他人的闪光点，那么即使和有很多缺点的人相处，也能从他人身上受益。与此相反，如果我们带着傲慢的心，仗恃自己的一点学识、观点，用评判和挑衅的眼光来看待周遭的一切，那么即使是圣贤大德的教诲，我们也能找到一些“疏漏”和“失误”，最终也无法受益。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">见人恶 &emsp;即内省 &emsp;有则改 &emsp;无加警</p><p style="margin-bottom: 0;"><br>    【解】看到别人的缺点或不良的行为，要先反观自己有没有犯同样的错。假如有，要赶快修正，假如没有，要警惕自己将来不要犯。（子曰：“三人行，必有我师焉，择其善者而从之，其不善者而改之。”）<br></p><p><br>    人生百态犹如一面镜子，见人过失易，不责人过失难，虽然镜子里的一切清清楚楚、明明白白，但智者可以借之反思警戒，而愚者却入中看戏而沉迷不悟！重要的是自己有无反省的功夫。一个人如果能处处看到自己的本分，他就不会把时间浪费在指责别人的不是上了。如果把别人的缺点、过失放在心上，那等于是把自己的心当成了垃圾桶，这样做是最傻的。做父母的要引导孩子正确看待他人的缺点和不足，不以自己的长处比他人的短处，要让孩子明白“金无足赤，人无完人”的道理。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">唯德学 &emsp;唯才艺 &emsp;不如人 &emsp;当自砺</p><p style="margin-bottom: 0;"><br>    【解】每一个人都应当重视自己的品德、学问和才能技艺的培养，如果感觉到有不如人的地方，应当自我惕励，奋发图强，努力赶上。<br></p><p><br>    《中庸》上讲：“好学近乎智，力行近乎仁，知耻近乎勇。”一个人他真能对德学才艺努力踏实去学习，这叫近乎智慧了；学到之后，关键是要力行，如何把孔夫子的温、良、恭、俭、让做出来，把孝、悌、忠、信、礼、义、廉、耻落实到生活当中，对父母如何行孝，对祖国如何尽忠，这叫力行，所以真正的仁，要有力行啊！知道自己有过失了，就叫知耻，知耻的人会勇猛改过，他必定是一步一步向着圣贤迈进。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">若衣服 &emsp;若饮食 &emsp;不如人 &emsp;勿生戚</p><p style="margin-bottom: 0;"><br>    【解】至于外表穿着或者饮食方面不如他人，心里不必难过，更没有必要忧虑自卑。物质上的这些享受够用就好，知足才是真正的富。<br></p><p><br>    如果一味追求物质享受，跟人攀比，看人穿名牌、时尚的衣服也要去赶时髦，看别人开名车、买大的别墅，心里又坐不住了，把大部分的时间、精力都花在逛街购物上，看到喜欢的款式就买，得到后很快又厌倦了。每天这样生活在患得患失之中，把人生短暂的时间、有限的精力、辛苦赚来的金钱都用在了这些奢侈、浪费、享受上，这样子生活很累，烦恼痛苦都是自己找的啊！所谓“欲是深渊，欲不可纵”，假如让自己的欲望无限制地膨胀下去，就会带给你很大的痛苦，当你入不敷出的时候，想回头都相当困难，因为“由俭入奢易，由奢入俭难”。所以明智的父母一定要防微杜渐，把孩子不健康的思想因素消灭在萌芽之中，一切都要谨慎于开始。父母同时也要以身作则，为孩子树立一个勤俭治家的好榜样，这样就会给孩子潜移默化的影响。当我们这样去引导孩子，让他懂得知足，他这一生才不会成为物质的奴隶，才不会崇尚虚华。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">闻过怒 &emsp;闻誉乐 &emsp;损友来 &emsp;益友却</p><p style="margin-bottom: 0;"><br>    【解】如果听到别人说自己的过错就一副不高兴的样子，听到别人称赞自己就欢喜的不得了，很快那些说好听话的、替你掩饰过失的、教你吃喝玩乐的损害你的朋友就会接近你，让你堕落，而真正的良朋益友反而远离你了，因为你根本听不进去好话，何必跟你结怨呢？<br></p><p><br>    人往往看不到自己的过失，因此这就需要善友的时时提醒。人一生中除了父母和老师之外，能有几个可以真心批评、指正我们的人呢？真心批评、指正我们的人，那真的是我们的善友，没有他们的批评、指正，我们还真的看不到自己的问题所在，所以感恩都来不及，怎么可以闻过之后发怒呢？古人将朋友也列为五伦之一，就是因为朋友可以帮助我们共同实践人生大道。曾子说：“君子以文会友，以友辅仁。”真正的朋友是以道义为准绳的，而不是以功利为纽带的世道教。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">闻誉恐 &emsp;闻过欣 &emsp;直谅士 &emsp;渐相亲</p><p style="margin-bottom: 0;"><br>    【解】听到别人赞叹我们，心中感到很惶恐，深怕别人言过其实，觉得自己根本没有那么好，应该要更加努力才对，听到别人说自己的过失，能够感到很欢喜，那么自然就有正直、诚实、讲信用的益友跟我们走在一起了，这对我们的学业、事业、道业都有莫大的帮助啊！<br></p><p><br>    要知道我们的才华、成就，绝不是个人能力所能达到的，都是父母长辈们养育、教育、指导、关怀以及众人付出的结果。所以我们每一件事情的成就，首先要感谢他们，这样我们才不会自视甚高，一个真正有所作为的人，必定是一个有大的涵养和度量、善于听取别人劝谏、欢喜改过的人。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">无心非 &emsp;名为错 &emsp;有心非 &emsp;名为恶</p><p style="margin-bottom: 0;"><br>    【解】无心犯的过失，这种过失称为错。假如已经知道这件事是错的，但是还要去做，那就是作恶。<br></p><p><br>    “人非圣贤，孰能无过”，圣贤之所以能成为圣贤，就是因为他能够天天改过啊！我们过去没有学习过圣贤教育，不懂得孝、悌、忠、信、礼、义、廉、耻，不知道怎么做人，做了很多错事，心里很后悔，现在回头重新来学习《弟子规》，发心做一个好人、做一个有德的君子乃至于要做圣贤。如果我们学了以后还是我行我素，明知做错了也不肯改过，那我们就是恶人了。过去做了错事还有个借口“没学过”，现在没有借口了，不能不改了！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">过能改 &emsp;归于无 &emsp;倘掩饰 &emsp;增一辜</p><p style="margin-bottom: 0;"><br>    【解】知错能改是勇者的行为，错误自然慢慢地减少消失。如果为了面子，死不认错，还要替自己开脱、掩饰，那就是错上加错，反而又增加一项掩饰的罪过了。<br></p><p><br>    世上没有完美无缺的人，每个人都是在不断纠正自己的错误中得到进步和发展的。一个人改正错误到最后实际就是超越自己，这需要极大的勇气与毅力，而要改错首先是知错、认识错误，还要有承认错误的勇气，最后才是改正错误的毅力。知过能改，善莫大焉！有过失没关系，能承认、能改过那就是好人。《菜根谭》上告诉我们：“弥天罪过，都当不得一个悔字。”天大的过失，只要能够忏悔改过，他就有救，因为当善心生起的时候，过去的罪恶都烟消云散了。如果我们不肯改，甚至还要为自己找借口来掩饰，那就会让人家从此瞧不起你、不信任你，这就叫作自暴自弃、自甘堕落啊！所以对于改过要痛下决心，这样人生才能走得坦坦荡荡。<br></p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象的程序设计（二）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/06/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="2-原型与in操作符"><a href="#2-原型与in操作符" class="headerlink" title="2.原型与in操作符"></a>2.原型与in操作符</h4><p><br>    有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。看一看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line">alert(&quot;name&quot; in person1);    // true</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // true</div><div class="line">alert(&quot;name&quot; in person1);    // true</div><div class="line"></div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person2.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line">alert(&quot;name&quot; in person2);    // true</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line">alert(&quot;name&quot; in person1);    // true</div></pre></td></tr></table></figure><p><br>    在以上代码执行的整个过程中，name属性要么是直接在对象上能访问到的，要么是通过原型访问到的。因此，调用“name” in person1始终都返回true，无论该属性存在于实例还是存在于原型中。同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function hasPrototypeProperty(object, name) &#123;</div><div class="line">    return !object.hasOwnProperty(name) &amp;&amp; (name in object);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty()只在属性存在于实例中时才返回true，因此只要in操作符返回true而hasOwnProperty()返回false，就可以确定属性是原型中的属性。下面来看一看上面定义的函数hasPrototypeProperty()的用法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Person();</div><div class="line">alert(hasPrototypeProperty(person, &quot;name&quot;));    // true</div><div class="line"></div><div class="line">person.name = &quot;Greg&quot;;</div><div class="line">alert(hasPrototypeProperty(person, &quot;name&quot;));    // false</div></pre></td></tr></table></figure><p><br>    在这里，name属性先是存在于原型中，因此hasPrototypeProperty()返回true。当在实例中重写name属性后，该属性就存在于实例中了，因此hasPrototypeProperty()返回false。即使原型中仍然有name属性，但由于现在实例中也有这个属性，因此原型中的name属性就用不到了。<br></p><p><br>    在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性(即将[[Enumerable]]标记为false的属性)的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。<br></p><p><br>    IE早期版本的实现中存在一个bug，即屏蔽不可枚举属性的实例属性不会出现在for-in循环中。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">    toString: function() &#123;</div><div class="line">        return &quot;My Object&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">for(var prop in o) &#123;</div><div class="line">    if (prop == &quot;toString&quot;) &#123;</div><div class="line">        alert(&quot;Found toString&quot;);    // 在IE中不会显示</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    当以上代码运行时，应该会显示一个警告框，表明找到了toString()方法。这里的对象o定义了一个名为toString()的方法，该方法屏蔽了原型中(不可枚举)的toString()方法。在IE中，由于其实现认为原型的toString()方法被打上了值为false的[[Enumerable]]标记，因此应该跳过该属性，结果我们就不会看到警告框。该bug会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和valueOf()。ECMAScript 5也将constructor和prototype属性的[[Enumerable]]特性设置为false，但并不是所有浏览器都照此实现。<br></p><p><br>    要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var keys = Object.keys(Person.prototype);</div><div class="line">alert(keys);    // &quot;name, age, job, sayName&quot;</div><div class="line"></div><div class="line">var p1 = new Person();</div><div class="line">p1.name = &quot;Rob&quot;;</div><div class="line">p1.age = 31;</div><div class="line">var p1keys = Object(p1);</div><div class="line">alert(p1keys);    // &quot;name, age&quot;</div></pre></td></tr></table></figure><p><br>    这里，变量keys中将保存一个数组，数组中是字符串“name”、“age”、“job”和“sayName”。这个顺序也是它们在for-in循环中出现的顺序。如果是通过Person的实例调用，则Object.keys()返回的数组只包含“name”和“age”这两个实例属性。<br></p><p><br>    如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var keys = Object.getOwnPropertyNames(Person.prototype);</div><div class="line">alert(keys);    // &quot;constructor, name, age, job, sayName&quot;</div></pre></td></tr></table></figure><p><br>    注意结果中包含了不可枚举的constructor属性。Object.keys()和Object.getOwnPropertyNames()方法都可以用来替代for-in循环。支持这两个方法的浏览器有IE9+、Firefox4+、Safari5+、Opera12+和Chrome。<br></p><h4 id="3-更简单的原型语法"><a href="#3-更简单的原型语法" class="headerlink" title="3.更简单的原型语法"></a>3.更简单的原型语法</h4><p><br>    前面例子中每添加一个属性和方法就要敲一遍Person.prototype.为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">name: &quot;Nicholas&quot;,</div><div class="line">age: 29,</div><div class="line">job: &quot;Software Engineer&quot;,</div><div class="line">sayName: function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    在上面的代码中，我们将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：constructor属性不再指向Person了。前面曾经介绍过，每创建一个函数，就会同时创建它的property对象，这个对象也会自动获得constructor属性。而我们在这里使用的语法，本质上完全重写了默认的property对象，因此constructor属性也就变成了新对象的constructor属性(指向Object构造函数)，不再指向Person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var friend = new Person();</div><div class="line"></div><div class="line">alert(friend instanceof Object);        // true</div><div class="line">alert(friend instanceof Person);        // true</div><div class="line">alert(friend.constructor == Person);    // false</div><div class="line">alert(friend.constructor == Object);    // true</div></pre></td></tr></table></figure><p><br>    在此，用instanceof操作符测试Object和Person仍然返回true，但constructor属性则等于Object而不等于Person了。如果constructor的值真的很重要，可以像下面这样特意将它设置回适当的值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">constructor: Person,</div><div class="line">name: &quot;Nicholas&quot;,</div><div class="line">age: 29,</div><div class="line">job: &quot;Software Engineer&quot;,</div><div class="line">sayName: function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    以上代码特意包含了一个constructor属性，并将它的值设置为Person，从而确保了通过该属性能够访问到适当的值。<br></p><p><br>    注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的，因此如果你使用兼容ECMAScript5的JavaScript引擎，可以试一试Object.defineProperty()。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">name: &quot;Nicholas&quot;,</div><div class="line">age: 29,</div><div class="line">job: &quot;Software Engineer&quot;,</div><div class="line">sayName: function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">// 重设构造函数，只适用于ECMAScript5兼容的浏览器</div><div class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</div><div class="line">    enumerable: false,</div><div class="line">    value: Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4.原型的动态性"></a>4.原型的动态性</h4><p><br>    由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var friend = new Person();</div><div class="line"></div><div class="line">Person.prototype.sayHi = function() &#123;</div><div class="line">    alert(&quot;hi&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayHi();    // &quot;hi&quot;</div></pre></td></tr></table></figure><p><br>    以上代码先创建了Person的一个实例，并将其保存在person中。然后，下一条语句在Person.prototype中添加了一个方法sayHi().即使person实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用person.sayHi()时，首先会在实例中搜索名为sayHi的属性，在没有找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在哪里的函数。<br></p><p><br>    尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]],而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">var friend = new Person();</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">constructor: Person,</div><div class="line">name: &quot;Nicholas&quot;,</div><div class="line">age: 29,</div><div class="line">job: &quot;Software Engineer&quot;,</div><div class="line">sayName: function() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayName();    // error</div></pre></td></tr></table></figure><p><br>    在这里例子中，我们先创建了Person的一个实例，然后又重写了其原型对象。然后在调用friend.sayName()时发生了错误，因为friend指向的原型中不包含以该名字命名的属性。下图展示了这个过程的内幕。<br></p><p><img src="https://shaoqianheng.github.io/images/h-6-3.png"></p><p><br>    从上图可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。<br></p><h4 id="5-原生对象的原型"><a href="#5-原生对象的原型" class="headerlink" title="5.原生对象的原型"></a>5.原生对象的原型</h4><p><br>    原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型(Object、Array、String,等等)都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(typeof Array.prototype.sort);          // &quot;function&quot;</div><div class="line">alert(typeof String.prototype.sunstring);    // &quot;function&quot;</div></pre></td></tr></table></figure><p><br>    通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了一个名为startWith()的方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String.prototype.startsWith = function(text) &#123;</div><div class="line">    return this.indexOf(text) == 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var msg = &quot;Hello world!&quot;;</div><div class="line">alert(msg.startsWith(&quot;Hello&quot;));    // true</div></pre></td></tr></table></figure><p><br>    这里新定义的startsWith()方法会在传入的文本位于一个字符串开始时返回true。既然方法被添加了String.prototype,那么当前环境中的所有字符串就都可以调用它。由于msg是字符串，而且后台会调用String基本包装函数创建这个字符串，因此通过msg就可以调用startsWith()方法。<br></p><blockquote><p>尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法。</p></blockquote><h4 id="6-原型对象的问题"><a href="#6-原型对象的问题" class="headerlink" title="6.原型对象的问题"></a>6.原型对象的问题</h4><p><br>    原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。<br></p><p><br>    原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟(如前面的例子所示)，通过在实例上添加一个同名属性，可以隐藏原型中的对象属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">constructor: Person,</div><div class="line">name: &quot;Nicholas&quot;,</div><div class="line">age: 29,</div><div class="line">job: &quot;Software Engineer&quot;,</div><div class="line">friends: [&quot;Shelby&quot;, &quot;Court&quot;],</div><div class="line">sayName: function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.friends.push(&quot;Van&quot;);</div><div class="line"></div><div class="line">alert(person1.friends);    // &quot;Shelby, Court, Van&quot;</div><div class="line">alert(person2.friends);    // &quot;Shelby, Court, Van&quot;</div><div class="line">alert(person1.friends == person2.friends);    // true</div></pre></td></tr></table></figure><p><br>    在此，Person.prototype对象有一个名为friends属性，该属性包含一个字符串数组。然后，创建了Person的两个实例。接着，修改了person.friends引用的数组，向数组中添加了一个字符串。由于friends数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2.friends(与person1.friends指向同一个数组)反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果没话可说。可以实例一般都是要有属于自己的全部属性。而这个问题正是我们很少看到有人单独使用原型模式的原因所在.<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弟子规 （二）</title>
      <link href="/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%882%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="三、出则弟"><a href="#三、出则弟" class="headerlink" title="三、出则弟"></a>三、出则弟</h3><p><br>    【解】这一篇说的是家中兄弟相处之道以及与长辈在一起的规矩，教导孩子对待长辈要有恭顺的态度和行为，要懂得尊重别人。当我们在家里已经养成了对父母、师长、兄弟的一种恭敬顺承的态度后，长大踏入社会，自然对领导、长辈及一切人也都有一种恭敬的存心，表现在外面就是以礼待人。我们要知道，很多为人处世的行为，确确实实是在家里养成的，所以为什么说家教如此重要！一个懂礼貌的人，他走到哪里都能赢得众人的喜欢、获得贵人的帮助。相反，假如没有礼貌，他不只不会遇到贵人、不会有很多助力，在言语、行为当中还会形成很多的阻力。他自己还会觉得莫名其妙，他们怎么都看我不顺眼，搞不清楚问题到底发生在哪里。所以，为人父母者果真为你的孩子前途着想，一定要慎重思考，在他成长的过程中，到底是考试分数重要还是教孩子做人做事的态度重要？既然我们都希望自己的孩子将来能遇到贵人、事业有成，那么从小就要重视这些影响孩子一辈子的重要的德行教育，这才是他人生幸福美满的根源！不然，等孩子长大以后习惯成自然，就很难改变了，这才是我们教育的当务之急！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">兄道友 &emsp;弟道恭 &emsp;兄弟睦 &emsp;孝在中</p><p style="margin-bottom: 0;"><br>    【解】当哥哥姐姐的要有爱弟妹，做弟弟妹妹的要懂得恭敬兄姐，这样兄弟姐妹就能和睦相处而减少冲突。兄弟姐妹能和睦相处、互相尊重，父母自然欢喜，孝道就在其中了。<br></p><p><br>    兄弟姐妹同为父母所生，情同手足，同声相应，同气相求，故能尽悌道也就是孝道。现在常在报纸上看到这样一些悲哀的现象，父母含辛茹苦地把好几个儿女养大，到父母老了需要儿女照顾时，谁都不愿意承担赡养的义务。父母过世后，儿女之间又为了互相争夺财产，告上法庭，甚至兄弟姐妹变成了仇人，全把父母的教诲忘在脑后。这是大不孝啊！想想父母在世时为我们操劳一生，走后在天之灵都无法得到安息，这是多么令父母操心、悲伤、蒙羞的事情啊！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">财物轻 &emsp;怨何生 &emsp;言语忍 &emsp;忿自泯</p><p style="margin-bottom: 0;"><br>    【解】与人相处，不斤斤计较财物，怨恨就无从生起。讲话要谨慎，不要说过激、太伤人的话语，给对方一分尊重，不要逼人太甚，这样自然就会刺痛对方而产生怨恨。<br></p><p><br>    言语在孔门四科里面排在第二位，这是很重要的一门学问。俗话说：“忍一时风平浪静，退一步海阔天空。”能忍让，就能化干戈怒气于无形之中。其实，在忍当中不但能扩宽自己的心量，也会唤醒对方的惭愧之心。因为，毕竟当人在发脾气的时候，往往都是比较情绪化，等他冷静下来，就会觉得自己理亏。所以，这一忍，忍出了自己的德行，也忍出了对方的惭愧，而且更保持了彼此的关系，何乐而不为呢？<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">或饮食 &emsp;或坐走 &emsp;长者先 &emsp;幼者后</p><p style="margin-bottom: 0;"><br>    【解】不论用餐、就座或行走，都应该谦虚礼让、长幼有序，让年长者优先，年幼者在后。<br></p><p><br>    现在家庭大多只有一个孩子，他们很多已经成为家中的小皇帝、小公主，几代人围着一个孩子转，有什么好吃的、好用的，总是首先想着孩子。这样长期下去，就增长了他自私自利的心性，以致小孩认为这是理所当然的，不知道要礼让长辈，认为自己是老大，使孩子养成了坏习惯。很难想象，一个自私自利、连自己的父母都不放在心上的人，怎么可能会为别人着想，将来怎么可能得到大家的尊重而获得真正的幸福成功呢？所以，不要因为大人的宠爱，而忽略了从小就应该培养孩子礼让的美德。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">长呼人 &emsp;即代叫 &emsp;人不在 &emsp;己即到</p><p style="margin-bottom: 0;"><br>    【解】长辈有事呼唤人，应代为传唤。如果那个人不再，自己应该主动去询问是什么事？可以帮忙的就帮忙，不能帮忙则代为转告。<br></p><p><br>    这是告诉我们，时时要有一颗为他人着想的心。当我们知道出处尊重长辈，常常有服务于长辈的心，长辈交代我们的事一定是立即去做，而且会把做完的情形向长辈报告，让长辈放心。当别人交代给我们的工作都能从头至尾做好，有始有终，这样我们走到哪里都会受到欢迎，别人看我们也顺眼，自然也就能得到长辈的垂爱和提携。其实，当一个孩子在落实这些礼仪的时候，他的耐性、沉着也就逐渐地培养出来了。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">称尊长 &emsp;勿呼名 &emsp;对尊长 &emsp;勿见能</p><p style="margin-bottom: 0;"><br>    【解】称呼长辈，不可以直呼姓名，这是对长辈的一种尊重。在长辈面前，要谦虚有礼，不要表现出自己很有才能，藐视长辈。<br></p><p><br>    晚辈直呼长辈的名字是不礼貌的、没有教养的表现，因此要在称呼上从小就树立孩子长幼、尊卑的态度，这样才能培养孩子谦虚的心态。如果孩子目无尊长、爱好表现，长辈就不愿意教他们了。古人很重视韬光养晦，一个人即使有才华，也不能在大庭广众之中故意卖弄，这是相当危险的。因为锋芒太露了很容易遭人嫉妒，这对将来的前途以及立身处世都有负面的影响。真正有德有才之人，久而久之自然能获得大家的敬佩、爱戴，何必用表现自己来证明自己的才华呢？<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">路遇长 &emsp;疾趋揖 &emsp;长无言 &emsp;退恭立</p><p style="margin-bottom: 0;"><br>    【解】路上遇到长辈，应快步向前问好。长辈没有事时，即恭敬退后站立一旁，等待长辈离去。<br></p><p><br>    如果见到长辈，还慢吞吞、大摇大摆地走上去，这种形象就已经充满了傲慢。文明礼貌看起来是一种外在的行为变现，实际上反映了一个人的内心修养，体现出一个人自尊和尊重他人的意识。人与人之间互相观察和了解，一般都是从礼仪开始的，一个举止优雅、彬彬有礼的人，更容易交到好的朋友、找到好的工作，所以礼貌就是一张金名片。而父母良好的行为举止是对孩子最生动、最有效的礼貌教育，事项一个满口脏话的家长，想要自己的孩子语言文明也是不大可能的。因此，家长应严格要求自己，给孩子做出一个好的榜样。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">骑下马 &emsp;乘下车 &emsp;过犹待 &emsp;百步余</p><p style="margin-bottom: 0;"><br>    【解】古礼：不论骑马或乘车，路上遇见长辈均应下马或下车问候。长辈离开以后，应该站在原地，目送长辈离开百步之遥，我们才可以离开。<br></p><p><br>    这都是体现出一种对长辈的恭敬之心。礼节作为人与人之间行为规范的一种规定，可以说是人与人之间所保持的最优美的距离，这种自然的秩序如果我们遵守的话，相处起来就感觉非常舒服、和谐，不会觉得唐突。假如这个礼你觉得繁琐，要把它废除掉，往往就会产生很多的不愉快跟误会。要知道正是这些繁琐的礼节，才能培养出一个人的耐心、细心、恭敬之心。这样久久养成习惯之后，这个人自然就有一个雍容大度之气，即使是在事情很忙乱的时候，他的礼节都分寸不乱，这才是真正大德之人。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">长者立 &emsp;幼勿坐 &emsp;长者坐 &emsp;命乃坐</p><p style="margin-bottom: 0;"><br>    【解】长辈如果站着，我们绝对不可以坐，因为这是非常无礼的。即使是长辈不坐，我们也不能坐。当长辈坐下来了，吩咐我们也一起坐时，我们才可以坐下来。如果长辈没有让我们坐，那我们就要侍奉在长辈旁边，服务于长辈。<br></p><p><br>    这是一项非常重要的社交礼节。我们参加聚会时，大家都有这样的感受，譬如说有家长带孩子来时，一群孩子遇到一起，如果小孩没有受到约束，往往就会在屋子里毫无顾忌地东跑西跑、大声喊叫，非常没有礼貌，给人的感觉是很没有家教。这是什么原因造成的呢？就是从小父母没有教过他这些应对进退的基本礼节。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">尊长前 &emsp;声要低 &emsp;低不闻 &emsp;却非宜</p><p style="margin-bottom: 0;"><br>    【解】在长辈面前讲话，声音要柔和适中，但回答的音量太小让人听不清楚，也是不恰当的，和颜悦色、柔和清楚最好。<br></p><p><br>    这是提醒我们时时要注意别人的感受。在长辈面前讲话，声音太大、很刺耳，讲起话来还滔滔不绝，旁边坐的长辈心里一定会觉得很难受、不舒服。所以，从小我们就要有意识地训练孩子，在长辈面前言谈举止要落落大方，要有一种柔和的气质。家里如果有长辈来，我们一定要让子女出来跟他问候，并注意在旁边观察他的礼貌、应对情形。如果发觉孩子有哪些过失及表现不妥的地方，当下就要知道他应该如何做才是最好的。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">进必趋 &emsp;退必迟 &emsp;问起对 &emsp;视勿移</p><p style="margin-bottom: 0;"><br>    【解】有事要到长辈面前，应快步向前，等到告退时，必须稍微慢一些才合乎礼节。当长辈问话时，应当专注聆听，眼睛不可以东张西望、左顾右盼。<br></p><p><br>    孩子对人讲话时眼睛不专注，代表他的心没有恭敬，心不在焉，很浮躁。现在孩子为什么这么焦躁？就是太缺乏礼节的教育，久而久之我行我素惯了。所以这些小细节，都需要我们为人长者好好用耐性去教导，慢慢让他能循规蹈矩，处处替人着想。加入与人相处都能遵守这些基本的礼节，回馈给我们的就是所有人都愿意帮助你、喜欢你。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事诸父 &emsp;如事父 &emsp;事诸兄 &emsp;如事兄</p><p style="margin-bottom: 0;"><br>    【解】对待叔叔、伯伯等尊长，要如同对待自己的父亲一般孝顺恭敬，对待同族兄长（堂兄姊、表兄姊），要如同对待自己的兄长一样友爱尊敬。<br></p><p style="margin-bottom: 0;"><br>    我们回想一下，这些长辈在我们小时候不知曾经抱过我们多少次，在心里祝福我们健康成长，对我们有很多的提携、关怀，这一份情我们要时时存在心里。当他们有需要的时候，我们一定要尽心尽力去帮忙，俗话说，“受人点滴”要“涌泉相报”。我们再把这种心扩展到社会，对待任何人的父母、兄弟姐妹也都要关心、爱护。当我们有了这样的态度，心胸就会非常开阔，量大福也就大，人生才会充满快乐。<br></p><p><br>    有人认为现代社会独生子女无兄弟姐妹，故不需有悌道，这种看法是狭隘的、短浅的。“兄弟”一伦也叫“长幼”，孩子长大成人进入社会，知有前辈晚辈，有年长于己而有才德者即视之如兄，就是悌道。晚辈能虚心向学，前辈能教而无倦，人类文化方能传承不绝，故曰：“四海之内皆兄弟也。”<br></p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>盒模型概述</title>
      <link href="/2018/06/27/%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/06/27/%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-1-盒模型"><a href="#1-1-盒模型" class="headerlink" title="1.1 盒模型"></a>1.1 盒模型</h3><p><span style="color: #000; font-weight: bold;">盒模型</span>是CSS的基石之一，它指定元素如何显示以及（在某种程度上）如何相互交互。<span style="color: #000; font-weight: bold;">页面上的每个元素被看做一个矩形框，这个框由元素的内容、内边距、边框和外边距组成。</span>（如图1-1）。</p><p>内边距出现在内容区域的周围。如果在元素上添加背景，那么背景会应用于由内容和内边距组成的区域。因此，我们常常使用内边距在内容周围创建一个隔离带，使内容不会与背景混在一起。添加边框会在内边距的区域外边加一条线。这些线可以有很多样式，比如实线、虚线或电线。在边框外边的是外边距。<span style="color: #000; font-weight: bold;">外边距是透明的。</span>一般使用它来控制元素之间的间隔。</p><p><br><br><img src="https://shaoqianheng.github.io/images/1-1.png"><br><div style="text-align: center;">图1-1 盒模型示意图</div><br><br></p><p><span style="color: #000; font-weight: bold;">内边距、边框和外边距都是可选的，默认值为零。</span>但是，许多元素将由用户代理样式表设置外边距和内边距。可以通过将元素的margin或padding设置为零来覆盖这些浏览器样式。这可以分别进行，也可以使用通用选择器对所有元素进行设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    margin: 0;</div><div class="line">    padding: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><span style="color: #000; font-weight: bold;">请记住，这种技术不区分元素，所以它对option等元素有不利影响。因此，使用全局reset把内边距和外边距显式地设置为零可能更安全。</span></p><p><span style="color: #000; font-weight: bold;">在CSS中，width和height指的是内容区域的宽度和高度。</span>增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素的总尺寸。假设框的每个边上有10像素的外边距和5像素的内边距，如果希望这个框达到100像素宽，就需要将内容的宽度设置为70像素。（图1-2）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#myBox &#123;</div><div class="line">    margin: 10px;</div><div class="line">    padding: 5px;</div><div class="line">    width: 70px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><span style="color: #000; font-weight: bold;">内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。外边距还可以是负值，这可以用在多种技术中。</span></p><p><img src="https://shaoqianheng.github.io/images/1-2.png"></p><div style="text-align: center;">图1-2 正确的盒模型</div><hr><h3 id="1-2-IE和盒模型"><a href="#1-2-IE和盒模型" class="headerlink" title="1.2 IE和盒模型"></a>1.2 IE和盒模型</h3><p> 令人遗憾的是，IE的早期版本，包括IE6，<span style="color: #000; font-weight: bold;">在混杂模式中使用自己的非标准盒模型。这些浏览器的width属性不是内容的宽度，而是内容、内边距和边框的宽度总和。</span>这实际上很有道理，因为在现实世界中框具有固定的尺寸，而且内边距是放在框里面的。添加的内边距越多，给内容留下的空间就越少。尽管符合逻辑，但是这些IE版本不符合规范，这会造成严重的问题。例如，在前面的示例中，在IE 5.x中框的总宽度只有90像素。这是因为IE 5.x认为每个边上5像素的内边距是70像素的宽度的一部分，而不是宽度之外附加的（图1-3）</p><p><img src="https://shaoqianheng.github.io/images/1-3.png"></p><div style="text-align: center;">图1-3 IE专有的盒模型使元素比预期的小</div><p> 幸运的是，有几个方法可以解决这个问题，这些方法在以后会介绍到。但是，目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素或子元素。</p><hr><h3 id="1-3-外边距叠加"><a href="#1-3-外边距叠加" class="headerlink" title="1.3 外边距叠加"></a>1.3 外边距叠加</h3><p> 外边距叠加是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。<span style="color: #000; font-weight: bold;">简单地说，当两个或更多垂直外边距相遇时，它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。</span></p><p><span style="color: #000; font-weight: bold;">当一个元素出现在另一个元素上面时，第一个元素的底外边距与第二个元素的顶外边距发生叠加。</span>（图1-4）</p><p><img src="https://shaoqianheng.github.io/images/1-4.png"></p><div style="text-align: center;">图1-4 元素的顶外边距与前面元素的底外边距发生叠加</div><p><span style="color: #000; font-weight: bold;">当一个元素包含在另一个元素中时（假设没有内边距或边框将外边距分隔开），它们的顶和或底外边距也会发生叠加。</span>（图1-5）</p><p>尽管初看上去有点儿奇怪，但是外边距甚至可以与本身发生叠加。假设有一个空元素，它有外边距，但是没有边框或内边距。在这种情况下，顶外边距与底外边距就碰到了一起，它们会发生叠加。（图1-6）</p><p><img src="https://shaoqianheng.github.io/images/1-5（1）.png"></p><div style="text-align: center;">图1-5 元素的顶外边距与父元素的顶外边距发生叠加</div><p><img src="https://shaoqianheng.github.io/images/1-6.png"></p><div style="text-align: center;">图1-6 元素的顶外边距与底外边距发生叠加</div><p><span style="color: #000; font-weight: bold;">如果这个外边距碰到另一个元素的外边距，它还会发生叠加</span>（图1-7）</p><p><img src="https://shaoqianheng.github.io/images/1-7.png"></p><div style="text-align: center;">图1-7 空元素中已经叠加的外边距与另一个空元素的外边距发生叠加</div><p><span style="color: #000; font-weight: bold;">这就是一系列空的段落元素占用的空间非常小的原因，因为它们的所有外边距都叠加到一起，形成一个小的外边距。</span></p><p> 外边距叠加初看上去可能有点儿奇怪，但是它实际上有<span style="color: #000; font-weight: bold;">重要的意义</span>。<span style="color: #000; font-weight: bold;">以由几个段落组成的典型文本页面为例（1-8）。第一个段落上面的空间等于段落的顶外边距。如果没有发生外边距叠加，后续所有段落之间的空间将是相邻顶外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距叠加，段落之间的顶外边距和底外边距就叠加在一起，这样各处的距离就一致了。</span></p><p><span style="color: #000; font-weight: bold;">只有普通文档流中块框的垂直外边距才会发生外边距叠加。行内框、浮动框或绝对定位框之间的外边距不会叠加。</span></p><p><img src="https://shaoqianheng.github.io/images/1-8.png"></p><div style="text-align: center;">图1-8 外边距叠加在元素之间维持了一致的距离</div>]]></content>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BOM（二）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/BOM%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/06/27/BOM%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-1-5-导航和打开窗口"><a href="#1-1-5-导航和打开窗口" class="headerlink" title="1.1.5 导航和打开窗口"></a>1.1.5 导航和打开窗口</h3><p><br>    使用window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。<br></p><p><br>    如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 等同于&lt;a href=&quot;http://……&quot; target=&quot;topFrame&quot;&gt;&lt;/a&gt;</div><div class="line">window.open(&quot;http://……&quot;, &quot;topFrame&quot;);</div></pre></td></tr></table></figure><p><br>    调用这行代码，就如同用户单击了href属性为<a href="http://……，target属性为“topFrame”的链接。如果有一个名叫“topFrame”的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就会创建一个新窗口并将其命名为“topFrame”。此外，第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top或_blank。" target="_blank" rel="external">http://……，target属性为“topFrame”的链接。如果有一个名叫“topFrame”的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就会创建一个新窗口并将其命名为“topFrame”。此外，第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top或_blank。</a><br></p><h4 id="1、弹出窗口"><a href="#1、弹出窗口" class="headerlink" title="1、弹出窗口"></a>1、弹出窗口</h4><p><br>    如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置(工具栏、地址栏和状态栏等)的新浏览器窗口(或者打开一个新标签页——根据浏览器设置)。在不打开新窗口的情况下，会忽略第三个参数。<br></p><p><br>    第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示那些特性。下表列出了可以出现在这个字符串中的设置选项。<br></p><p><img src="https://shaoqianheng.github.io/images/h-8-3.png"></p><div style="text-align: center;">图1-3</div><p><br>    表中所列的部分或全部设置选项，都可以通过逗号分隔的名值对列表来指定。其中，名值对以等号表示(注意，整个特性字符串中不允许出现空格)，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.open(&quot;http://……&quot;, &quot;wroxWindoe&quot;, &quot;height=400,widht=400,top=10,left=10,resizable=yes&quot;);</div></pre></td></tr></table></figure><p><br>    这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为400*400像素，并且距屏幕上沿和左边各10像素。<br></p><p><br>    window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window对象大致相似，但我们可以对其进行更多控制。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var wroxWin = window.open(&quot;http://……&quot;, &quot;wroxWindoe&quot;, &quot;height=400,widht=400,top=10,left=10,resizable=yes&quot;);</div><div class="line"></div><div class="line">// 调整大小</div><div class="line">wroxWin.resizeTo(500, 500);</div><div class="line"></div><div class="line">// 移动位置</div><div class="line">wroxWin.moveTo(100, 100);</div><div class="line"></div><div class="line">// 调用close()方法还可以关闭新打开的窗口</div><div class="line">wroxWin.close();</div></pre></td></tr></table></figure><p><br>    但是，这个方法仅适用于通过window.open()打开的弹出窗口。对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。不过，弹出窗口到时可以调用top.close()在不经用户允许的情况下关闭自己。弹出窗口关闭之后，窗口的引用仍然还在，但除了像下面这样检测其closed属性之外，已经没有其他用处了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wroxWin.close();</div><div class="line">alert(wroxWin.closed);    // true</div></pre></td></tr></table></figure><p><br>    新创建的window对象有一个opener属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window对象(top)中有定义，而且指向调用window.open()的窗口或框架。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var wroxWin = window.open(&quot;http://……&quot;, &quot;wroxWindoe&quot;, &quot;height=400,widht=400,top=10,left=10,resizable=yes&quot;);</div><div class="line"></div><div class="line">alert(wroxWin.opener == window);    // true</div></pre></td></tr></table></figure><p><br>    虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口，因此我们只能在必要的时候自己来手动实现跟踪。<br></p><p><br>    有些浏览器(如IE8和Chrome)会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome中，将新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var wroxWin = window.open(&quot;http://……&quot;, &quot;wroxWindoe&quot;, &quot;height=400,widht=400,top=10,left=10,resizable=yes&quot;);</div><div class="line"></div><div class="line">wroxWin.opener = null;</div></pre></td></tr></table></figure><p><br>    将opener属性设置为null就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。标签页之间的联系一旦切断，将没有办法恢复。<br></p><h4 id="2-安全显示"><a href="#2-安全显示" class="headerlink" title="2. 安全显示"></a>2. 安全显示</h4><p><br>    曾经有一段时间，广告商在网上使用弹出窗口达到了肆无忌惮的程度。他们经常把弹出窗口打扮成系统对话框的模样，引诱用户去点击其中的广告。由于看起来像是系统对话框，一般用户很难分辨是真是假。为了解决这个问题，有些浏览器开始在弹出窗口配置方面增加限制。<br></p><p><br>    Windows XP SP2中的IE6对弹出窗口施加了多方面的安全限制，包括不允许在屏幕之外创建弹出窗口、不允许将弹出窗口移动到屏幕之外、不允许关闭状态栏等。IE7则增加了更多的安全限制，如不允许关闭地址栏、默认情况下不允许移动弹出窗口或调整其大小。Firefox 1从一开始就不支持修改状态栏，因此无论给window.open()传入什么样的特性字符串，弹出窗口中都会无一例外地显示状态栏。后来的Firefox 3又强制始终在弹出窗口中显示地址栏。Opera只会在主浏览器窗口中打开弹出窗口，但不允许它们出现在可能与系统对话框混淆的地方。<br></p><p><br>    此外，有的浏览器只根据用户操作来创建弹出窗口。这样一来，在页面尚未加载完成时调用window.open()的语句根本不会执行，而且可还可能会将错误信息显示给用户。换句话说，只能通过单击或者击键打开弹出窗口。<br></p><p><br>    对于那些不是用户有意打开的弹出窗口，Chrome采取了不同的处理方式。它不会像其他浏览器那样简单地屏蔽这些弹出窗口，而是只显示它们的标题栏，并把它们放在浏览器窗口的右下角。<br></p><blockquote><p>在打开计算机硬盘中的网页时，IE会解除对弹出窗口的某些限制。但是在服务器上执行这些代码会受到对弹出窗口的限制。</p></blockquote><h4 id="3-弹出窗口屏蔽程序"><a href="#3-弹出窗口屏蔽程序" class="headerlink" title="3. 弹出窗口屏蔽程序"></a>3. 弹出窗口屏蔽程序</h4><p><br>    大多数浏览器都内置有弹出窗口屏蔽程序，而没有内置此类程序的浏览器，也可以安装Yahoo！Toolbar等带有内置屏蔽程序的实用工具。结果就是用户可以将绝大多数不想看到的弹出窗口屏蔽掉。于是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var wroxWin = window.open(&quot;http://……&quot;, &quot;_blank&quot;);</div><div class="line">if(wroxWin == null) &#123;</div><div class="line">    alert(&quot;The popup was blocked!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch块中，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var blocked = false;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    var wroxWin = window.open(&quot;……&quot;, &quot;_blank&quot;);</div><div class="line">    if (wroxWin == null) &#123;</div><div class="line">        blocked = true;</div><div class="line">    &#125;</div><div class="line">&#125; catch (ex) &#123;</div><div class="line">    blocked = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (blocked) &#123;</div><div class="line">    alert(&quot;The popup was blocked!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在任何情况下，以上代码都可以检测出调用window.open()打开的弹出窗口是不是被屏蔽了。但要注意的是，检测弹出窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关的信息。<br></p><h3 id="1-1-6-间歇调用和超时调用"><a href="#1-1-6-间歇调用和超时调用" class="headerlink" title="1.1.6 间歇调用和超时调用"></a>1.1.6 间歇调用和超时调用</h3><p><br>    JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。<br></p><p><br>    超时调用需要使用window对象的setTimeout()方法，它接收两个参数：要执行的代码和以毫秒表示的时间(即在执行代码前需要等待多少毫秒)。其中，第一个参数可以是一个包含JavaScript代码的字符串(就和在eval()函数中使用的字符串一样)，也可以是一个函数。例如，下面对setTimeout()的两次调用都会在一秒钟后显示一个警告框。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   // 不建议传递字符串！</div><div class="line">   setTimeout(&quot;alert(&apos;Hello world!&apos;)&quot;, 1000);</div><div class="line"></div><div class="line">   // 推荐的调用方式</div><div class="line">   setTimeout(function() &#123;</div><div class="line">       alert(&apos;Hello world!&apos;);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><p><br>    虽然这两种调用方式都没有问题，但由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。<br></p><p><br>    第二个参数是一个表示等待多长时间的毫秒数，但经过改时间后指定的代码不一定会执行。JavaScript是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间就把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。<br></p><p><br>    调用setTimeout()之后，该方法会返回一个数值ID，表示超时时间。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 设置超时调用</div><div class="line">var timeoutId = setTimeout(function() &#123;</div><div class="line">    alert(&quot;Hello world!&quot;);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">// 注意：把它取消</div><div class="line">clearTimeout(timeoutId);</div></pre></td></tr></table></figure><p><br>    只要是在指定的时间尚未过去之前调用clearTimeout()，就可以完全取消超时调用。前面的代码在设置超时调用之后马上又调用了clearTimeout(),结果就跟什么也没有发生一样。<br></p><blockquote><p>超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。</p></blockquote><p><br>    间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval(),它接受的参数与setTimeout()相同：要执行的代码(字符串或函数)和每次执行之前需要等待的毫秒数。下面来看一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   // 不建议传递字符串！</div><div class="line">   setInterval(&quot;alert(&apos;Hello world!&apos;)&quot;, 1000);</div><div class="line"></div><div class="line">   // 推荐的调用方式</div><div class="line">   setInterval(function() &#123;</div><div class="line">       alert(&apos;Hello world!&apos;);</div><div class="line">&#125;, 10000);</div></pre></td></tr></table></figure><p><br>    调用setInterval()方法同样也会返回一个间歇调用ID，该ID可用于在将来某个时刻取消间歇调用。要取消间歇调用，可以使用clearInterval()方法并传入相应的间歇调用ID。取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。以下是一个常见的使用间歇调用的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var num = 0;</div><div class="line">var max = 10;</div><div class="line">var inervalId = null;</div><div class="line"></div><div class="line">function incrementNumber() &#123;</div><div class="line">    num++;</div><div class="line">    // 如果执行次数达到了max设定的值，则取消后续尚未执行的调用</div><div class="line">    if (num == max) &#123;</div><div class="line">        clearInterval(intervalId);</div><div class="line">        alert(&quot;Done&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">intervalId = setInterval(incrementNumber, 500);</div></pre></td></tr></table></figure><p><br>    在这个例子中，变量num每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用。这个模式也可以使用超时调用来实现，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var num = 0;</div><div class="line">var max = 10;</div><div class="line"></div><div class="line">function incrementNumber() &#123;</div><div class="line">    num++;</div><div class="line">    //如果执行次数未达到 max 设定的值，则设置另一次超时调用</div><div class="line">    if (num &lt; max) &#123;</div><div class="line">        setTimeout(incrementNumber, 500);</div><div class="line">    &#125; else &#123;</div><div class="line">        alert(&quot;Done&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(incrementNumber, 500);</div></pre></td></tr></table></figure><p><br>    可见，在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境中，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数表达式（一）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/27/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><br>    函数表达式是JavaScript中的一个既强大又容易令人困惑的特性。前面介绍过，定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法是这样的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function functionName(arg0, arg1, arg2) &#123;</div><div class="line">    // 函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    首先是function关键字，然后是函数的名字，这就是指定函数名的方式。Firefox、Safari、Chrome和Opera都给函数定义了一个非标准的name属性，通过这个属性可以访问到给函数指定的名字。这个属性的值永远等于跟在function关键字后面的标识符。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 只在Firefox、Safari、Chrome和Opera有效</div><div class="line">alert(functionName.name);    // &quot;functionName&quot;</div></pre></td></tr></table></figure><p><br>    关于函数声明，它的一个重要特征就是函数声明提升(function declaration hoisting)，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sayHi();</div><div class="line">function sayHi() &#123;</div><div class="line">    alert(&quot;Hi!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个例子不会抛出错误，因为在代码执行之前会先读取函数声明。<br></p><p><br>    第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var functionName = function(arg0, arg1, arg2) &#123;</div><div class="line">    // 函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。这种情况下创建的函数叫做匿名函数(anonymous function)，因为function关键字后面没有标识符。(匿名函数有时候也叫做拉姆达函数。)匿名函数的name属性是空字符串。<br></p><p><br>    函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sayHi();    // 错误：函数还不存在</div><div class="line">var sayHi = function() &#123;</div><div class="line">    alert(&quot;Hi!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。例如，执行以下代码的结果可能会让人意想不到。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 不要这样做</div><div class="line">if(condition) &#123;</div><div class="line">    function sayHi() &#123;</div><div class="line">        alert(&quot;Hi!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    function sayHi() &#123;</div><div class="line">        alert(&quot;Yo!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    表面上看，以上代码表示在condition为true时，使用一个sayHi()的定义；否则，就使用另一个定义。实际上，这在ECMAScript中属于无效语法，JavaScript引擎会尝试修正错误，将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略condition；Firefox会在condition为true时返回第一个声明。因此这种使用方式很危险，不应该出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 可以这样做</div><div class="line">var sayHi;</div><div class="line"></div><div class="line">if(condition) &#123;</div><div class="line">    sayHi = function() &#123;</div><div class="line">        alert(&quot;Hi!&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125; else &#123;</div><div class="line">    sayHi = function() &#123;</div><div class="line">        alert(&quot;Yo!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个例子不会有什么意外，不同的函数会根据condition被赋值给sayHi。<br></p><p><br>    能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。还记得之前中的那个createComparisonFunction()函数吗：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">    return function(object1, object2) &#123;</div><div class="line">        var value1 = object1[propertyName];</div><div class="line">        var value2 = object2[propertyName];</div><div class="line"></div><div class="line">        if(value1 &lt; value2) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125; else if(value1 &gt; value2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    createComparisonFunction()就返回了一个匿名函数。返回的函数可能会被赋值给一个变量，或者以其他方式被调用；不过，在createComparisonFunction()函数内部，它是匿名的。在把函数当成值来使用的情况下，都可以使用匿名函数。不过，这并不是匿名函数唯一的用途。<br></p><h3 id="1-1-递归"><a href="#1-1-递归" class="headerlink" title="1.1 递归"></a>1.1 递归</h3><p><br>    递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if(num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * factorial(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var anotherFactorial = factorial;</div><div class="line">factorial = null;</div><div class="line">alert(anotherFactorial(4));    // 出错！</div></pre></td></tr></table></figure><p><br>    以上代码先把factorial()函数保存在变量anotherFactorial中，然后将factorial变量设置为null，结果指向原始函数的引用只剩下一个。但在接下来调用anotherFactorial()时，由于必须执行factorial()，而factorial已经不再是函数，所以就会导致错误。在这种情况下，使用arguments.callee可以解决这个问题。<br></p><p><br>    我们知道，arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，例如。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if(num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    最后一行代码显示，通过使用arguments.callee代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用arguments.callee总比使用函数名更保险。<br></p><p><br>    但在严格模式下，不能通过脚本访问arguments.callee,访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var factorial = (function f(num) &#123;</div><div class="line">    if(num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * f(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><br>    以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正常完成。这种方式在严格模式和非严格模式下都行得通。<br></p><h3 id="1-2-闭包"><a href="#1-2-闭包" class="headerlink" title="1.2 闭包"></a>1.2 闭包</h3><p><br>    有不少开发人员总是搞不清匿名函数和闭包这两个概念，因此经常混用。闭包是指有权访问另个一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数，仍以前面的createComparisonFunction()函数为例，注意两个var语句。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">    return function(object1, object2) &#123;</div><div class="line">        var value1 = object1[propertyName];</div><div class="line">        var value2 = object2[propertyName];</div><div class="line"></div><div class="line">        if(value1 &lt; value2) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125; else if(value1 &gt; value2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个例子中，var的那两行代码是内部函数(一个匿名函数)中的代码，这两行代码访问了外部函数中的变量propertyName。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可以访问变量propertyName。之所以还能够访问这个变量，是因为内部函数的作用域链中包含createComparisonFunction()的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候都会发生什么入手。<br></p><p><br>    了解有关如何创建作用域链以及作用域链有什么作用的细节，对彻底理解闭包至关重要。当某个函数被调用时，会创建一个执行环境(execution context)及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。<br></p><p><br>    在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2) &#123;</div><div class="line">    if(value1 &lt; value2) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125; else if(value1 &gt; value2) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">var result = compare(5, 10);</div></pre></td></tr></table></figure><p><br>    以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当调用compare()时，会创建一个包含arguments、value1和Value2的活动对象。全局执行环境的变量对象(包括result和compare)在compare()执行环境的作用域链中则处于第二位。图1-1展示了包含上述关系的compare()函数执行时的作用域链。<br></p><p><img src="https://shaoqianheng.github.io/images/h-7-1.png"></p><div style="text-align: center;">图1-1</div><p><br>    后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过赋值函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。<br></p><p><br>    无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况又有所不同。<br></p><p><br>    在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。图1-2展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var compare = createComparisionFunction(&quot;name&quot;);</div><div class="line">var result = compare(&#123;name: &quot;Nicholas&quot;&#125;, &#123;name: &quot;Greg&quot;&#125;);</div></pre></td></tr></table></figure><p><br>    在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 创建函数</div><div class="line">var compareNames = createComparisonFunction(&quot;name&quot;);</div><div class="line">// 调用函数</div><div class="line">var result = compareNames(&#123;name: &quot;Nicholas&quot;&#125;, &#123;name: &quot;Greg&quot;&#125;);</div><div class="line">// 解除对匿名函数的引用(以便释放内存)</div><div class="line">compareNames = null;</div></pre></td></tr></table></figure><p><br>    首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域(除了全局作用域)也都可以安全地销毁了。图1-2展示了调用compareNames()的过程中产生的作用域链之间的关系。<br></p><p><img src="https://shaoqianheng.github.io/images/h-7-2.png"></p><div style="text-align: center;">图1-2</div><blockquote><p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，我们建议只在绝对必要时再考虑使用闭包。虽然像V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存，但还是要慎重使用闭包。</p></blockquote><h3 id="1-2-1-闭包与变量"><a href="#1-2-1-闭包与变量" class="headerlink" title="1.2.1 闭包与变量"></a>1.2.1 闭包与变量</h3><p><br>    作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说明这个问题。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createFuntions() &#123;</div><div class="line">    var result = new Array();</div><div class="line"></div><div class="line">    for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">        result[i] = function() &#123;</div><div class="line">            return i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返回自己的索引值，即位置0的函数返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10.因为每个函数的作用域链中都保存着createFunction()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10.但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createFuntions() &#123;</div><div class="line">    var result = new Array();</div><div class="line"></div><div class="line">    for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">        result[i] = function(num) &#123;</div><div class="line">            return function() &#123;</div><div class="line">                return num;</div><div class="line">            &#125;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在重写了前面的createFunctions()函数后，每个函数就会返回各自不同的索引值了。在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋值给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包。这样一来，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。<br></p><h3 id="1-2-1-关于this对象"><a href="#1-2-1-关于this对象" class="headerlink" title="1.2.1 关于this对象"></a>1.2.1 关于this对象</h3><p><br>    在闭包中使用this对象也可能会导致一些问题。我们知道，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。下面来看一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getNameFun: function() &#123;</div><div class="line">        return function() &#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()());    // &quot;The Window&quot;(在非严格模式下)</div></pre></td></tr></table></figure><p><br>    以上代码先创建了一个全局变量name，又创建了一个包含name属性的对象。这个对象还包含一个方法——getNameFunc()，它返回一个匿名函数，而匿名函数又返回this.name.由于getNameFunc()返回一个函数，因此调用object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串。然而，这个例子返回的字符串是”The Window”,即全局name变量的值。为什么匿名函数没有取得其包含作用域(或外部作用域)的this对象呢？<br></p><p><br>    前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中this对象保存在一个闭包能够访问到的变量例，就可以让闭包访问该对象了，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;;</div><div class="line"></div><div class="line">    getNameFunc: function() &#123;</div><div class="line">        var that = this;</div><div class="line">        return function() &#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()());    // &quot;My Object&quot;</div></pre></td></tr></table></figure><p><br>    在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因此它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，taht也仍然引用这object，所以调用object.getNameFunc()就返回了“My Object”。<br></p><blockquote><p>this和arguments也存在同样的问题。如果想访问作用域链中的arguments对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。</p></blockquote><p><br>    在几种特殊情况下，this的值可能会意外地改变。比如，下面的代码是修改前面例子的结果。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getName: function() &#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    这里的getName()方法只简单地返回this.name的值。以下是几种调用object.getName()的方式以及各自的结果。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object.getName();    // &quot;My Object&quot;</div><div class="line">(object.getName)();  // &quot;My Object&quot;</div><div class="line">(object.getName = object.getName)();    // &quot;The Window&quot;, 在非严格模式下</div></pre></td></tr></table></figure><p><br>    第一行代码跟平常一样调用了object.getName()，返回的是“My Object”，因为this.name就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像是在引用一个函数，但this的值得到了维持，因为object.getName和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this的值不能得到维持，结果就返回了”The Window”。<br></p><p><br>    当然，你不大可能会像第二行和第三行代码一样调用这个方法。不过，这个例子有助于说明即使是语法的细微变化，都有可能意外改变this的值。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOM（三）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/DOM%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/06/27/DOM%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><br>    另一个常用于取得元素引用的方法是getElementsByTagName().这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的NodeList。在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个“动态”集合，该对象与NodeList非常类似。例如，下列代码会取得页面中的所有的<img>元素，并返回一个HTMLCollection。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var images = document.getElementsByTagName(&quot;img&quot;);</div></pre></td></tr></table></figure><p><br>    这行代码会将一个HTMLCollection对象保存在images变量中。与NodeList对象类似，可以使用方括号语法或item()方法来访问HTMLCollection对象中的项。而这个对象中元素的数量则可以通过其length属性取得，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(images.length);       // 输出图像的数量</div><div class="line">alert(images[0].src);       // 输出第一个图像元素的src特性</div><div class="line">alert(images.item(0).src);  // 输出第一个图像元素的src特性</div></pre></td></tr></table></figure><p><br>    HTMLCollection对象还有一个方法，叫做namedItem(),使用这个方法可以通过元素的name特性取得集合中的项。例如，假设上面提到的页面中包含如下<img>元素：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt;</div></pre></td></tr></table></figure><p><br>    那么就可以通过如下方式从images变量中取得这个<img>元素：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myImage = images.namedItem(&quot;myImage&quot;);</div></pre></td></tr></table></figure><p><br>    在提供按索引访问项的基础上，HTMLCollection还支持按名称访问项，这就为我们取得实际想要的元素提供了便利。而且，对命名的项也可以使用方括号语法来访问，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var myImage = images[&quot;myImages&quot;];</div></pre></td></tr></table></figure><p><br>    对HTMLCollection而言，我们向方括号中传入数值或字符串形式的索引值。在后台，对数组索引就会调用item（），而对字符串索引就会调用namedItem（）。<br></p><p>要想取得文档中的所有元素，可以向getElementsByTagName()中传入“<em>”。在JavaScript及CSS中，星号（</em>）通常表示“全部”。下面看一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var allElements = document.getElementsByTagName(&quot;*&quot;);</div></pre></td></tr></table></figure><p>仅此一行代码返回的HTMLCollection中，就包含了整个页面中的所有元素——按照他们出现的先后顺序。换句话说，第一项是<html>元素，第二项是<head>元素，以此类推。<br>由于IE将注释（Comment）实现为元素（Element），因此在IE中调用getElementsByTagName(“*”)将会返回所有注释节点。</head></html></p><blockquote><p>  虽然标准规定标签名需要区分大小写，但为了最大限度地与既有HTML页面兼容，传给getElementsByTagName()的标签名是不需要区分大小写的。但对于<br>XML页面而言（包括XHTML），getElementsByTagName（）方法就会区分大小写。</p></blockquote><p>第三个方法，也是只有HTMLDocument类型才有的方法，是getElementsByName（）。顾名思义，这个方法会返回带有给定name特性的所有元素。最常使用getElementsByName()<br>方法的情况是取得单选按钮；为了确保发送给浏览器的值准确无误，所有单选按钮必须具有相同的name特性，如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;fieldset&gt;</div><div class="line">  &lt;legend&gt;Which color do you prefer?&lt;/legend&gt;</div><div class="line">  &lt;ul&gt;</div><div class="line">    &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;red&quot; name=&quot;color&quot; id=&quot;colorRed&quot;&gt;</div><div class="line">        &lt;label for=&quot;colorRed&quot;&gt;Red&lt;/label&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;green&quot; name=&quot;color&quot; id=&quot;colorGreen&quot;&gt;</div><div class="line">        &lt;label for=&quot;colorGreen&quot;&gt;Green&lt;/label&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;blue&quot; name=&quot;color&quot; id=&quot;colorBlue&quot;&gt;</div><div class="line">        &lt;label for=&quot;colorBlue&quot;&gt;Blue&lt;/label&gt;&lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">&lt;/fieldset&gt;</div></pre></td></tr></table></figure><p>如这个例子所示，其中所有单选按钮的name特性值都是“color”，但它们的ID可以不同。ID的作用在于将<label>元素应用到每个单选按钮，而name特性则用于确保三个值中只有一个被发送<br>给浏览器。这样，我们就可以使用如下代码取得所有单选按钮。</label></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var radios = document.getElementsByName(&quot;color&quot;);</div></pre></td></tr></table></figure><p>与getElementsByTagName()类似，getElementsByName()方法也会返回一个HTMLCollection。但是，对于这里的单选按钮来说，而namedItem()方法则只会取得第一项（因为每一项的name特性都<br>相同）。</p><h4 id="4-特殊集合"><a href="#4-特殊集合" class="headerlink" title="4.特殊集合"></a>4.特殊集合</h4><p>除了属性和方法，document对象还有一些特殊的集合。这些集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式，包括：</p><ul><li>document.anchors,包括文档中所有带name特性的\<a\>元素；</a\></li><li>document.applets,包含文档中所有的<applet>元素，因为不再推荐使用<applet>元素，所以这个集合已经不建议使用了；</applet></applet></li><li>document.forms,包含文档中所有的<form>元素，与document.getElementsByTagName(“form”)得到的结果相同；</form></li><li>document.images,包含文档中所有的<img>元素，与document.getElementsByTagName(“img”)得到结果相同；</li><li>document.links,包含文档中所有带href特性的<a>元素。</a></li></ul><p>这个特殊集合始终都可以通过HTMLDocument对象访问到，而且，与HTMLCollection对象类似，集合中的项也会随着当前文档内容的更新而更新。</p><h4 id="5-DOM一致性检测"><a href="#5-DOM一致性检测" class="headerlink" title="5.DOM一致性检测"></a>5.DOM一致性检测</h4><p>由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要了。document.implementation属性就是<br>为此提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。DOM1级只为document.implementation规定了一个方法，即hasFeature().这个<br>方法接受两个参数：要检测的DOM功能的名称及版本号。如果浏览器支持给定名称和版本的功能，则该方法返回true，如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;, &quot;1.0&quot;);</div></pre></td></tr></table></figure><p>下表列出了可以检测的不同的值及版本号。</p><p><img src="https://shaoqianheng.github.io/images/h-10-3.png"></p><p>尽管使用hasFeature（）确实方便，但也有缺点。因为事先者可以自行决定是否与DOM规范的不同部分保持一致。事实上，要想<br>让hasFeature()方法针对所有值都返回true很容易，但返回true有时候也不意味着实现与规范一致。例如，Safari2.x及更早版本<br>会在没有完全实现某些DOM功能的情况下也返回true。为此，我们建议多数情况下，在使用DOM的某些特殊的功能之前，最好除了检测<br>hasFeature（）之外，还同时使用能力检测。</p><h4 id="6-文档写入"><a href="#6-文档写入" class="headerlink" title="6.文档写入"></a>6.文档写入</h4><p>有一个document对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力体现在下列4个方法中：write()、writeIn()、<br>open()和close()。其中，write()和writeIn()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而writeIn()则会<br>在字符串的末尾添加一个换行符(\n)。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容，如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;document.write() Example&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">     &lt;p&gt;The current date and time is:</div><div class="line">       &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">       document.write(&quot;&lt;strong&gt;&quot; + (new Date()).toString() + &quot;&lt;/strong&gt;&quot;);</div><div class="line">       &lt;/script&gt;</div><div class="line">     &lt;/p&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>这个例子展示了在页面加载过程中输出当前日期和时间的代码。其中，日期被包含在一个<strong>元素中，就像HTML页面中包含普通的文本一样。<br>这样做会创建一个DOM元素，而且可以在将来访问该元素。通过write()和writeIn()输出的任何HTML代码都将如此处理。</strong></p><p>此外，还可以使用write()和writeIn()方法动态地包含外部资源，例如JavaScript文件等。在包含JavaScript文件时，必须注意不能像下面的例子那样<br>直接包含字符串”“,因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;document.write() Example 2&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">     &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">     document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; +</div><div class="line">     &quot;&lt;/script&gt;&quot;);</div><div class="line">     &lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>即使这个文件看起来没错，但字符串”“将被解释为与外部的<script>标签匹配，结果文本”)；将会出现在页面中。为避免这个问题，只需假如转义字符\即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;document.write() Example 3&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">     &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">     document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; +</div><div class="line">     &quot;&lt;\/script&gt;&quot;);</div><div class="line">     &lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>字符串”&lt;\/script&gt;”不会被当作外部<script>标签的关闭标签，因而页面中也就不会出现多余的内容了。</p><p>前面的例子使用document.write()在页面被呈现的过程中直接向其中输出了内容。如果在文档加载结束后再<br>调用document.write()，那么输出的内容将会重写整个页面，如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;document.write() Example 4&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">     &lt;p&gt;This is some content that you won&apos;t get to see because it will be overwritten.&lt;/p&gt;</div><div class="line">     &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">     window.onload = function()&#123;</div><div class="line">     document.write(&quot;Hello world!&quot;);</div><div class="line">     &#125;;</div><div class="line">     &lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>在这个例子中，我们使用了window.onload事件处理程序，等到页面完全加载之后延迟执行函数。函数执行后，字符串“hello world！”会重写<br>整个页面内容。</p><p>方法open（）和close（）分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()或writeIn()方法，则不需要用到这两个方法。</p><h3 id="10-1-3-Element类型"><a href="#10-1-3-Element类型" class="headerlink" title="10.1.3 Element类型"></a>10.1.3 Element类型</h3><p>除了Document类型之外，Element类型就要算是Web编程中最常用的类型了。Element类型就要算是Web编程中最常用的类型了。Element类型用于表现<br>XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征：</p><ul><li>nodeType的值为1；</li><li>nodeName的值为元素的标签名；</li><li>nodeValue的值为null；</li><li>parentNode可能是Document或Element；</li><li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference。</li></ul><p>要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回相同的值（使用后者主要是为了清晰起见）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure><p>可以像下面这样取得这个元素及其标签名：</p><p>var div = document.getElementById(“myDiv”);<br>alert(div.tagName);   // “DIV”<br>alert(div.tagName == div.nodeName);  // true</p><p>这里的元素标签名是div，它拥有一个值为“myDiv”的ID。可是，div.tagName实际上输出的是“DIV”而非“div”。在HTML中，标签名始终都<br>以全部大写表示：而在XML（有时候也包括XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在HTML还是XML文档<br>中执行，最好还是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (element.tagName == &quot;div&quot;) &#123; // 不能这样比较，很容易出错！</div><div class="line">  // 在此执行某些操作</div><div class="line">&#125;</div><div class="line">if (element.tagName.toLowerCase() == &quot;div&quot;) &#123; // 这样最好（适用于任何文档）</div><div class="line">  // 在此执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个例子展示了围绕tagName属性的两次比较操作。第一次比较非常容易出错，因为其代码在HTML中不管用。第二次比较将标签名转换成了全部小写，是我们<br>推荐的做法，因为这种做法适用于HTML文档，也适用于XML文档。</p></script></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BOM（三）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/BOM%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/06/27/BOM%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-1-7-系统对话框"><a href="#1-1-7-系统对话框" class="headerlink" title="1.1.7 系统对话框"></a>1.1.7 系统对话框</h3><p><br>    浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及(或)浏览器设置决定，而不是由CSS决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。<br></p><p><br>    前面经常会用到alert()方法，这个方法接受一个字符串并将其显示给用户。具体来说，调用alert()方法的结果就是向用户显示一个系统对话框，其中包含指定的文本和一个OK(“确定”)按钮。<br></p><p><br>    通常使用alert()生成的“警告”对话框向用户显示一些他们无法控制的消息，例如错误消息。而用户只能在看完消息后关闭对话框。<br></p><p><br>    第二种对话框是调用confirm()方法生成的。从向用户显示消息的方面来看，这种“确认”对话框很像是一个“警告”对话框。但二者的主要区别在于“确认”对话框除了显示OK按钮外，还会显示一个Cancel(“取消”)按钮，两个按钮可以让用户决定是否执行给定的操作。<br></p><p><br>    最后一种对话框是通过调用prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示OK和Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值(可以是一个空字符串)。<br></p><p><br>    综上所述，这些系统对话框很适合向用户显示消息并请用户做出决定。由于不涉及HTML、CSS或JavaScript，因此它们是增强Web应用程序的一种便捷方式。<br></p><h3 id="1-2-location对象"><a href="#1-2-location对象" class="headerlink" title="1.2 location对象"></a>1.2 location对象</h3><p><br>    location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location对象是很特别的一个对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下表列出了location对象的所有属性。<br></p><p><img src="https://shaoqianheng.github.io/images/h-8-4.png"></p><h3 id="1-2-1-查询字符串参数"><a href="#1-2-1-查询字符串参数" class="headerlink" title="1.2.1 查询字符串参数"></a>1.2.1 查询字符串参数</h3><p><br>    虽然通过上面的属性可以访问到location对象的大多数信息，但其中访问URL包含的查询字符串的属性并不方便。尽管location.search返回从问好到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。为此，可以像下面这样创建一个函数，用于解析查询字符串，然后返回包含所有参数的一个对象。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function getQueryStringArgs() &#123;</div><div class="line">    // 取得查询字符串并去掉开头的问好</div><div class="line">    var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;),</div><div class="line"></div><div class="line">    // 保存数据的对象</div><div class="line">    args = &#123;&#125;，</div><div class="line"></div><div class="line">    // 取得每一项</div><div class="line">    items = qs.length ? qs.split(&quot;&amp;&quot;) : [],</div><div class="line">    item = null,</div><div class="line">    name = null,</div><div class="line">    value = null,</div><div class="line"></div><div class="line">    // 在for循环中使用</div><div class="line">    i = 0,</div><div class="line">    len = items.length;</div><div class="line"></div><div class="line">    // 逐个将每一项添加到args对象中</div><div class="line">    for(i = 0; i &lt; len; i++) &#123;</div><div class="line">        item = items[i].split(&quot;=&quot;);</div><div class="line">        name = decodeURIComponent(item[0]);</div><div class="line">        value = decodeURIComponent(item[1]);</div><div class="line"></div><div class="line">        if (name.length) &#123;</div><div class="line">            args[name] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return args;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个函数的第一步是先去掉查询字符串开头的问号。当然，前提是location.search中必须要包含一个或多个字符。然后，所有参数将被保存在args对象中，该对象以字面量形式创建。接下来，根据和号(&amp;)来分割查询字符串，并返回name=value格式的字符串数组。下面的for循环会迭代这个数组，然后再根据等于号分割每一项，从而返回第一项为参数名，第二项为参数值的数组。在使用decodeURIComponent()分别解码name和value(因为查询字符串应该是被编码过的)。最后，将name作为args对象的属性，将value作为相应属性的值。下面给出了使用这个函数的示例。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 假设查询字符串是?q=javascript&amp;num=10</div><div class="line">var args = getQueryStringArgs();</div><div class="line"></div><div class="line">alert(args[&quot;q&quot;]);    // &quot;javascript&quot;</div><div class="line">alert(args[&quot;num&quot;]);  // &quot;10&quot;</div></pre></td></tr></table></figure><p><br>    可见，每个查询字符串参数都成了返回对象的属性。这样就极大地方便了对每个参数的访问。<br></p><h3 id="1-2-2-位置操作"><a href="#1-2-2-位置操作" class="headerlink" title="1.2.2 位置操作"></a>1.2.2 位置操作</h3><p><br>    使用location对象可以通过很多方式来改变浏览器的位置。首先，也是最常用的方式，就是使用assign()方法并为其传递一个URL，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.assign(&quot;xxxx&quot;);</div></pre></td></tr></table></figure><p><br>    这样，就可以立即打开新URL并在浏览器的历史记录中生成一条记录。如果将location.href或window.location设置为一个URL值，也会以该值调用assign()方法。例如，下列两行代码与显式调用assign()方法的效果完全一样。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">window.location = &quot;xxxx&quot;;</div><div class="line">location.href = &quot;xxxx&quot;;</div></pre></td></tr></table></figure><p><br>    在这些改变浏览器位置的方法中，最常用的是设置location.href属性。<br></p><p><br>    另外，修改location对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将hash、search、hostname、pathname和port属性设置为新值来改变URL。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 假设初始URL为 http://www.wrox.com/WileyCDA/</div><div class="line"></div><div class="line">// 将URL修改为 http://www.wrox.com/WileyCDA/#section1</div><div class="line">location.hash = &quot;#section1&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.wrox.com/WileyCDA/?q=javascript</div><div class="line">location.search = &quot;?q=javascript&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.yahoo.com/WileyCDA/</div><div class="line">location.hostname = &quot;www.yahoo.com&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.yahoo.com/mydir/</div><div class="line">location.pathname = &quot;mydir&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.yahoo.com:8080/WileyCDA/</div><div class="line">location.port = 8080;</div></pre></td></tr></table></figure><p><br>    每次修改location的属性(除hash外)，页面都会以新URL重新加载。<br></p><p><br>    当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。这个方法只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新纪录。在调用replace()方法之后，用户不能回到前一个页面，来看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;You won&apos;t be able to get back here&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;p&gt;Enjoy this page for a second, because you won&apos;t be coming back here.&lt;/p&gt;</div><div class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            setTimeout(function () &#123;</div><div class="line">                location.replace(&quot;http://www.wrox.com/&quot;);</div><div class="line">            &#125;, 1000);</div><div class="line">        &lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><br>    如果将这个页面加载到浏览器中，浏览器就会在1秒钟后重新定向到www.wrox.com。然后，“后退”按钮将处于禁用状态，如果不重新输入完整的URL，则无法返回示例页面。<br></p><p><br>    与位置有关的最后一个方法是reload(),作用是重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">location.reload();      // 重新加载(有可能从缓存中加载)</div><div class="line">location.reload(true);  // 重新加载(从服务器重新加载)</div></pre></td></tr></table></figure><p><br>    位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。<br></p><h3 id="1-3-navigator对象"><a href="#1-3-navigator对象" class="headerlink" title="1.3 navigator对象"></a>1.3 navigator对象</h3><p><br>    最早由Netscape Navigator 2.0引入的navigator对象，现在已经成为识别客户端浏览器的事实标准。虽然其他浏览器也通过其他方式提供了相同或相似的信息(例如，IE中的window.clientInformation和Opera中的window.opera),但navigator对象却是所有支持JavaScript的浏览器所共有的。与其他BOM对象的情况一样，每个浏览器中的navigator对象也都有一套自己的属性。下表列出了存在于所有浏览器中的属性和方法，以及支持他么的浏览器版本。<br></p><p><img src="https://shaoqianheng.github.io/images/h-8-5(1).png"><br><img src="https://shaoqianheng.github.io/images/h-8-5(2).png"></p><h3 id="1-3-1-检测插件"><a href="#1-3-1-检测插件" class="headerlink" title="1.3.1 检测插件"></a>1.3.1 检测插件</h3><p><br>    检测浏览器中是否安装了特定的插件是一种最常见的检测例程。对于非IE浏览器，可以使用plugins数组来达到这个目的。该数组中的每一项都包含下列属性。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(1) name: 插件的名字。</div><div class="line">(2) description: 插件的描述。</div><div class="line">(3) filename: 插件的文件名。</div><div class="line">(4) length: 插件所处理的MIME类型数量。</div></pre></td></tr></table></figure><p><br>    一般来说，name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 检测插件（在 IE 中无效）</div><div class="line">function hasPlugin(name) &#123;</div><div class="line">    name = name.toLowerCase();</div><div class="line">    for (var i=0; i &lt; navigator.plugins.length; i++) &#123;</div><div class="line">        if (navigator. plugins [i].name.toLowerCase().indexOf(name) &gt; -1) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测 Flash</div><div class="line">alert(hasPlugin(&quot;Flash&quot;));</div><div class="line">// 检测 QuickTime</div><div class="line">alert(hasPlugin(&quot;QuickTime&quot;));</div></pre></td></tr></table></figure><p><br>    这个hasPlugin()函数接受一个参数：要检测的插件名。第一步是将传入的名称转换为小写形式，以便于比较。然后迭代plugins数组，通过indexOf()检测每个name属性，以确定传入的名称是否出现在字符串的某个地方。比较的字符串都使用小写形式可以避免因大小写不一致导致的错误。而传入的参数应该尽可能具体，以避免混淆。应该说，像Flash和QuickTime这样的字符串就比较具体了，不容易导致混淆。在Firefox、Safari、Opera和Chrome中可以使用这种方法来检测插件。<br></p><blockquote><p>每个插件对象本身也是一个MimeType对象的数组，这些对象可以通过方括号语法来访问。每个MimeType对象有4个属性：包含MIME类型描述的description、回指插件对象的enabledPlugin、表示与MIME类型对应的文件扩展名的字符串suffixes(以逗号分隔)和表示完整MIME类型字符串的type。</p></blockquote><p><br>    检测IE中的插件比较麻烦，因为IE不支持Netscape式的插件。在IE中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。例如，Flash的标识符是ShockwaveFlash.shockwaveFlash.知道唯一标识符之后，就可以编写类似下面的函数来检测IE中是否安装相应插件了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 检测 IE 中的插件</div><div class="line">function hasIEPlugin(name) &#123;</div><div class="line">    try &#123;</div><div class="line">        new ActiveXObject(name);</div><div class="line">        return true;</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测 Flash</div><div class="line">alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;));</div><div class="line">// 检测 QuickTime</div><div class="line">alert(hasIEPlugin(&quot;QuickTime.QuickTime&quot;));</div></pre></td></tr></table></figure><p><br>    在这个例子中，函数hasIEPlugin()只接收一个COM标识符作为参数。在函数内部，首先会尝试创建一个COM对象的实例。之所以要在try-catch语句中进行实例化，是因为创建未知COM对象会抛出错误。这样，如果实例化成功，则函数返回true；否则，如果抛出了错误，则执行catch块，结果就会返回false。例子最后检测IE中是否安装了Flash和QuickTime插件。<br></p><p><br>    鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 检测所有浏览器中的 Flash</div><div class="line">function hasFlash() &#123;</div><div class="line">    var result = hasPlugin(&quot;Flash&quot;);</div><div class="line">    if (!result) &#123;</div><div class="line">        result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);</div><div class="line">    &#125; </div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测所有浏览器中的 QuickTime</div><div class="line">function hasQuickTime() &#123;</div><div class="line">    var result = hasPlugin(&quot;QuickTime&quot;);</div><div class="line">    if (!result) &#123;</div><div class="line">        result = hasIEPlugin(&quot;QuickTime.QuickTime&quot;);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测 Flash</div><div class="line">alert(hasFlash());</div><div class="line">// 检测 QuickTime</div><div class="line">alert(hasQuickTime());</div></pre></td></tr></table></figure><p><br>    上面代码中定义了两个函数：hasFlash()和hasQuickTime().每个函数都是先尝试使用不针对IE的插件检测方法。如果返回了false(在IE中会这样)，那么再使用针对IE的插件检测方法。如果IE的插件检测方法再返回false，则整个方法也将返回false。只要任何一次检测返回true，整个方法都会返回true。<br></p><blockquote><p>plugins集合有一个名叫refresh()的方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。</p></blockquote><h3 id="1-3-2-注册处理程序"><a href="#1-3-2-注册处理程序" class="headerlink" title="1.3.2 注册处理程序"></a>1.3.2 注册处理程序</h3><p><br>    Firefox 2为navigator对象新增了registerContentHandler()和registerProtocolHandler()方法(这两个方法是在HTML5中定义的)。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。<br></p><p><br>    其中，registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称。举个例子，要将一个站点注册为处理RSS源的处理程序，可以使用如下代码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   navigator.registerContentHandler(&quot;application/rss+xml&quot;,</div><div class="line">&quot;http://www.somereader.com?feed=%s&quot;, &quot;Some Reader&quot;);</div></pre></td></tr></table></figure><p><br>    第一个参数是RSS源的MIME类型。第二个参数是应该接收RSS源URL的URL，其中的%s表示RSS源URL，由浏览器自动插入。当下一次请求RSS源时，浏览器就会打开指定的URL，而相应的Web应用程序将以适当方式来处理该请求。<br></p><blockquote><p>Firefox 4及之前版本只允许在registerContentHandler()方法中使用三个MIME类型：application/rss+xml、application/atom+xml和application/vnd.mozilla.maybe.feed.这三个MIME类型的作用都一样，即为RSS或ATOM新闻源(feed)注册处理程序。</p></blockquote><p><br>    类似的调用方式也适用于registerProtocolHandler()方法，它也接收三个参数：要处理的协议(例如，mailto或ftp)、处理该协议的页面的URL和应用程序的名称。例如，要想将一个应用程序注册为默认的邮件客户端，可以使用如下代码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   navigator.registerProtocolHandler(&quot;mailto&quot;,</div><div class="line">&quot;http://www.somemailclient.com?cmd=%s&quot;, &quot;Some Mail Client&quot;);</div></pre></td></tr></table></figure><p><br>    这个例子注册了一个mailto协议的处理程序，该程序指向一个基于Web的电子邮件客户端。同样，第二个参数仍然是处理相应请求的URL，而%s则表示原始的请求。<br></p><blockquote><p>Firefox 2虽然实现了registerProtocolHandler(),当该方法还不能用。Firefox 3完整实现这个方法。</p></blockquote><h3 id="1-4-screen对象"><a href="#1-4-screen对象" class="headerlink" title="1.4 screen对象"></a>1.4 screen对象</h3><p><br>    JavaScript中有几个对象在编程中用处不大，而screen对象就是其中之一。screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各自不同的属性，下表列出了所有属性及支持相应属性的浏览器。<br></p><p><img src="https://shaoqianheng.github.io/images/h-8-6(1).png"><br><img src="https://shaoqianheng.github.io/images/h-8-6(2).png"></p><p><br>    这些信息经常集中出现在测定客户端能力的站点跟踪工具中，但通常不会用于影响功能。不过，有时候也可能会用到其中的信息来调整浏览器窗口大小，使其占据屏幕的可用空间，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.resizeTo(screen.availWidth, screen.availHeight);</div></pre></td></tr></table></figure><p><br>    前面曾经提到过，许多浏览器都会禁用调整浏览器窗口大小的能力，因此上面这行代码不一定在所有环境下都有效。<br></p><p><br>    涉及移动设备的屏幕大小时，情况有点不一样。运行iOS的设备始终会像是把设备竖着拿在手里一样，因此返回的值是768 * 1024.而Android设备则会相应调用screen.width和screen.height的值。<br></p><h3 id="1-5-history对象"><a href="#1-5-history对象" class="headerlink" title="1.5 history对象"></a>1.5 history对象</h3><p><br>    history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。出于安全方面的考虑，开发人员无法得知用于浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL的情况下实现后退和前进。<br></p><p><br>    使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转(类似于单击浏览器的“后退”<br>    按钮)，正数表示向前跳转(类似于单击浏览器的“前进”按钮)。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//后退一页</div><div class="line">history.go(-1);</div><div class="line"></div><div class="line">//前进一页</div><div class="line">history.go(1);</div><div class="line"></div><div class="line">//前进两页</div><div class="line">history.go(2);</div></pre></td></tr></table></figure><p><br>    也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//跳转到最近的 wrox.com 页面</div><div class="line">history.go(&quot;wrox.com&quot;);</div><div class="line"></div><div class="line">//跳转到最近的 nczonline.net 页面</div><div class="line">history.go(&quot;nczonline.net&quot;);</div></pre></td></tr></table></figure><p><br>    另外，还可以使用两个简写方法back()和forward()来代替go().顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//后退一页</div><div class="line">history.back();</div><div class="line"></div><div class="line">//前进一页</div><div class="line">history.forward();</div></pre></td></tr></table></figure><p><br>    除了上述几个方法外，history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0.通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的页面。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (history.length == 0) &#123;</div><div class="line">    //这应该是用户打开窗口后的第一个页面</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    虽然history并不常用，但在创建自定义的“后退”和“前进”按钮，以及检测当前页面是不是用户历史记录中第一个页面时，还是必须使用它。<br></p><blockquote><p>当页面的URL改变时，就会生成一条历史记录。在IE8及更高版本、Opera、Firefox、Safari 3以及更高版本及Chrome中，这里所说的改变包括URL中的hash的变化(因此，设置location.hash会在这些浏览器中生成一条新的历史记录)。</p></blockquote><h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h3><p><br>    浏览器对象模型(BOM)以window对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。这章讨论了下列BOM的组成部分。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(1) 在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames集合中，可以通过位置或通过名称来访问。</div><div class="line">(2) 有一些窗口指针，可以用来引用其他框架，包括父框架。</div><div class="line">(3) top对象始终指向最外围的框架，也就是整个浏览器窗口。</div><div class="line">(4) parent对象表示包含当前框架的框架，而self对象则回指window。</div><div class="line">(5) 使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。</div><div class="line">(6) 调用replace()方法可以导航到一个新URL，同时该URL会替换掉浏览器历史记录中当前显示的页面。</div><div class="line">(7) navigator对象提供了与浏览器相关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性(如userAgent)存在于所有浏览器中。</div></pre></td></tr></table></figure><blockquote><p>BOM中还有两个对象：screen和history，但它们的功能有限。screen对象中保存着与客户端显示器有关信息，这些信息一般只用于站点分析。history对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOM（一）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/DOM%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/27/DOM%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><br>   DOM(文档对象模型)是针对HTML和XML文档的一个API(应用程序编程接口)。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM脱胎于Netscape及微软公司创始的DHTML(动态HTML)，但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。<br></p><p><br>    1998年10月DOM1级规范成为W3C的推荐标准，为基本的文档结构及查询提供了接口。本章主要讨论与浏览器中的HTML页面相关的DOM1级的特性和应用，以及JavaScript对DOM1级的实现。IE、Firefox、Safari、Chrome和Opera都非常完善地实现了DOM。<br></p><blockquote><p>注意，IE中的所有DOM对象都是以COM对象的形式实现的。这意味着IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致。</p></blockquote><h3 id="1-1-节点层次"><a href="#1-1-节点层次" class="headerlink" title="1.1 节点层次"></a>1.1 节点层次</h3><p><br>    DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及(或)标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的HTML为例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;Sample Page&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;p&gt;Hello World!&lt;/p&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><br>    可以将这个简单的HTML文档表示为一个层次结构，如图1-1所示。<br></p><p><br>    文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<html>元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是<html>元素。在XML中，没有预定义的元素，因此任何元素都可能称为文档元素。<br></html></html></p><p><br>    每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素结点表示，特性(attribute)通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。<br></p><p><img src="https://shaoqianheng.github.io/images/h-10-1.png"></p><div style="text-align: center;">图1-1</div><h3 id="1-1-1-Node类型"><a href="#1-1-1-Node类型" class="headerlink" title="1.1.1 Node类型"></a>1.1.1 Node类型</h3><p><br>    DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的；除了IE之外，在其他所有浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。<br></p><p><br>    每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1、Node.ELEMENT_NODE(1);</div><div class="line">2、Node.ATTRIBUTE_NODE(2);</div><div class="line">3、Node.TEXT_NODE(3);</div><div class="line">4、Node.CDATA_SECTION_NODE(4);</div><div class="line">5、Node.ENTITY_REFERENCE_NODE(5);</div><div class="line">6、Node.ENTITY_NODE(6);</div><div class="line">7、Node.PROCESSING_INSTRUCTION_NODE(7);</div><div class="line">8、Node.COMMENT_NODE(8);</div><div class="line">9、Node.DOCUMENT_NODE(9);</div><div class="line">10、Node.DOCUMENT_TYPE_NODE(10);</div><div class="line">11、Node.DOCUMENT_FRAGMENT_NODE(11);</div><div class="line">12、Node.NOTATION_NODE(12).</div></pre></td></tr></table></figure><p><br>    通过比较上面这些常量，可以很容易地确定节点的类型，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (someNode.nodeType == Node.ELEMENT_NODE) &#123;   // 在IE中无效</div><div class="line">    alert(&quot;Node is an element&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个例子比较了someNode.nodeType与Node.ELEMENT_NODE常量。如果二者相等，则意味着someNode确实是一个元素。然而，由于IE没有公开Node类型的构造函数，因此上面的代码在IE中会导致错误。为了确保跨浏览器兼容，最好还是将nodeType属性与数字值进行比较，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (someNode.nodeType == 1) &#123;   // 适用于所有浏览器</div><div class="line">    alert(&quot;Node is an element.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    并不是所有节点类型都受到Web浏览器的支持。开发人员最常用的就是元素和文本节点。后面将详细讨论每个节点类型的受支持情况及使用方法。<br></p><h4 id="1-nodeName和nodeValue属性"><a href="#1-nodeName和nodeValue属性" class="headerlink" title="1.nodeName和nodeValue属性"></a>1.nodeName和nodeValue属性</h4><p><br>    要了解节点的具体信息，可以使用nodeName和nodeValue这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (someNode.nodeType == 1) &#123;</div><div class="line">    value = someNode.nodeName;  // nodeName的值是元素的标签名</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个例子中，首先检查节点类型，看它是不是一个元素。如果是，则取得并保存nodeName的值。对于元素结点，nodeName中保存的始终都是元素的标签名，而nodeValue的值则始终为null。<br></p><h4 id="2-节点关系"><a href="#2-节点关系" class="headerlink" title="2. 节点关系"></a>2. 节点关系</h4><p><br>    文档中所有的节点之间都存在这样或那样的关系。节点间的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。在HTML中，可以将<body>元素看成是<html>元素的子元素；相应地，也就可以将<html>元素看成是<body>元素的父元素。而<head>元素，则可以看成是</head><body>元素的同胞元素，因为它们都是同一个父元素<html>的直接子元素。<br></html></body></body></html></html></body></p><p><br>    每个节点都有一个childNode属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。我们常说，NodeList是有生命、有呼吸的对象，而不是在我们第一次访问它们的某个瞬间拍摄下来的一张快照。<br></p><p><br>    下面的例子展示了如何访问保存在NodeList中的节点——可以通过方括号，也可以使用item()方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var firstChild = someNode.childNodes[0];</div><div class="line">var secondChild = someNode.childNodes.item(i);</div><div class="line">var count = someNode.childNodes.length;</div></pre></td></tr></table></figure><p><br>    无论使用方括号还是使用item()方法都没有问题，但使用方括号语法看起来与访问数组相似，因此颇受一些开发人员的青睐。另外，要注意length属性表示的是访问NodeList的哪一样，其中包含的节点数量。之前介绍过，对arguments对象使用Array.prototype.slice()方法可以将其转换为数组。而采用同样的方法，也可以将NodeList对象转换为数组。来看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 在IE8及之前版本中无效</div><div class="line">var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes, 0);</div></pre></td></tr></table></figure><p><br>    除IE8及更早版本之外，这行代码能在任何浏览器中运行。由于IE8及更早版本将NodeList实现为一个COM对象，而我们不能像使用JScript对象那样使用这种对象，因此上面的代码会导致错误。要想在IE中将NodeList转换为数组，必须手动枚举所有成员。下列代码在所有浏览器中都可以运行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function convertToArray(nodes) &#123;</div><div class="line">    var array = null;</div><div class="line">    try &#123;</div><div class="line">        array = Array.prototype.slice.call(nodes, 0);   // 针对非IE浏览器</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        array = new Array();</div><div class="line">        for (var i = 0; ;len = nodes.length; i &lt; len; i++) &#123;</div><div class="line">            array.push(nodes[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;       </div><div class="line">    return array;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这个convertToArray()函数首先尝试了创建数组的最简单方式。如果导致了错误(说明是在IE8及更早版本中)，则通过try-catch块来捕获错误，然后手动创建数组。这是另一种检测怪癖的形式。<br></p><p><br>    每个节点都有一个parentNode属性，该属性指向文档树中的父节点。包含在childNodes列表中的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点。此外，包含在childNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中的每个节点的previousSibling和nextSibling属性，可以访问同一列表中的其他节点。列表中第一个节点的previousSiblign属性值为null，而列表中最后一个节点的nextSibling属性的值同样也为null，如下面的例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (someNode.nextSibling === null) &#123;</div><div class="line">    alert(&quot;Last node in the parent&apos;s childNodes list.&quot;);</div><div class="line">&#125; else if (someNode.previousSibling === null) &#123;</div><div class="line">    alert(&quot;First node in the parent&apos;s childNodes llist.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    当然，如果列表中只有一个节点，那么该节点的nextSibling和previousSibling都为null。<br></p><p><br>    父节点与其第一个和最后一个子节点之间也存在特殊关系。父节点的firstChild和lastChild属性分别指向其childNodes列表中的第一个和最后一个节点。其中，someNode.firstChild的值始终等于someNode.childNodes[0]，而someNode.lastChild的值始终等于someNode.childNodes[someNode.childNodes.length-1].在只有一个子节点的情况下，firstChild和lastChild指向同一个节点。如果没有子节点，那么firstChild和lastChild的值均为null。明确这些关系能够对我们查找和访问文档结构中的节点提供极大的遍历。图1-2形象地展示了上述关系。<br></p><p><img src="https://shaoqianheng.github.io/images/h-10-2.png"></p><div style="text-align: center;">图1-2</div><p><br>    在反映这些关系的所有属性当中，childNodes属性与其他属性相比更方便一些，因为只须使用简单的关系指针，就可以通过它访问文档树中的任何节点。另外，hasChildNode()也是一个非常有用的方法，这个方法在节点包含一或多个子节点的情况下返回true；应该说，这是比查询childNodes列表的length属性更简单的方法。<br></p><p><br>    所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。<br></p><blockquote><p>虽然所有节点类型都继承自Node，但并不是每种节点都有子节点</p></blockquote><h4 id="3-操作节点"><a href="#3-操作节点" class="headerlink" title="3. 操作节点"></a>3. 操作节点</h4><p><br>    因为关系指针都是只读的，所以DOM提供了一些操作节点的方法。其中，最常用的方法是appendChild()，用于向childNodes()列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()返回新增的节点。来看下面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var returnedNode = someNode.appendChild(newNode);</div><div class="line">alert(returnedNode == newNode);         // true</div><div class="line">alert(someNode.lastChild == newNode);   // true</div></pre></td></tr></table></figure><p><br>    如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。即使可以将DOM树看成是由一系列指针连接起来的，但任何DOM节点也不能同时出现在文档中的多个位置上。因此，如果在调用appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// someNode有多个子节点</div><div class="line">var returnedNode = someNode.appendChild(someNode.firstChild);</div><div class="line"></div><div class="line">alert(returnedNode == someNode.firstChild); // false</div><div class="line">alert(returnedNode == someNode.lastChild);  // true</div></pre></td></tr></table></figure><p><br>    如果需要把节点放在childNodes列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore()方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点(previousSibling)，同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 插入后成为最后一个子节点</div><div class="line">retrunedNode = someNode.insertBefore(newNode, null);</div><div class="line">alert(newNod == someNode.lastChild);    // true</div><div class="line"></div><div class="line">// 插入后成为第一个子节点</div><div class="line">var returnedNode = someNode.insertBefore(newNode, someNode.firstChild);</div><div class="line"></div><div class="line">alert(returnedNode == newNode);         // true</div><div class="line">alert(newNode == someNode.firstChild);  // true</div><div class="line"></div><div class="line">// 插入到最后一个子节点前面</div><div class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild);</div><div class="line">alert(newNode == someNode.childNodes[someNode.childNodes.length-2]);    // true</div></pre></td></tr></table></figure><p><br>    前面介绍的appendChild()和insertBefore()方法都直插入节点、不会移除节点。而下面要介绍的replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由方法返回并从文档树中被移除，同时由要插入的节点占据其位置。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 替换第一个子节点</div><div class="line">var returnedNode = someNode.replaceChild(newNode, someNode.firstChild);</div><div class="line"></div><div class="line">// 替换最后一个子节点</div><div class="line">var formerLastChild = someNode.replaceChild(newNode, someNode.lastChild);</div></pre></td></tr></table></figure><p><br>    在使用replaceChild()插入一个节点时，该节点的所有指针都会从被它替换的节点复制过来。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。<br></p><p><br>    如果只想移除而非替换节点，可以使用removeChild()方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值，如下面的例子所示、<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 移除第一个子节点</div><div class="line">var formerFirstChild = someNode.removeChild(someNode.firstChild);</div><div class="line">// 移除最后一个子节点</div><div class="line">var formerLastChild = someNode.removeChild(someNode.lastChild);</div></pre></td></tr></table></figure><p><br>    与使用replaceChild()方法一样，通过removeChild()移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。<br></p><p><br>    前面介绍的四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点(使用parentNode属性)。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用这些方法，将会导致错误发生。<br></p><h4 id="4-其他方法"><a href="#4-其他方法" class="headerlink" title="4. 其他方法"></a>4. 其他方法</h4><p><br>    有两个方法是所有类型的节点都有的。第一个就是cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为false的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”，除非通过appendChild()、insertBefore()或replaceChild()将它添加到文档中。例如，假设有下面的HTML代码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li&gt;item 1&lt;/li&gt;</div><div class="line">    &lt;li&gt;item 2&lt;/li&gt;</div><div class="line">    &lt;li&gt;item 3&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure><p><br>    如果我们已经将<ul>元素的引用保存在了变量myList中，那么通常下列代码就可以看出使用cloneNode()方法的两种模式。<br></ul></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var deepList = myList.cloneNode(true);</div><div class="line">alert(deepList.childNodes.length);  // 3(IE &lt; 9)或7(其他浏览器)</div><div class="line"></div><div class="line">var shallowList = myList.cloneNode(false);</div><div class="line">alert(shallowList.childNodes.length);   // 0</div></pre></td></tr></table></figure><p><br>    在这个例子中，deepList中保存着一个对myList执行深复制得到的副本。因此，deepList中包含3个列表项，每个列表项中都包含文本。而变量shallowList中保存着对myList执行浅复制得到的副本，因此它不包含子节点。deepList.childNodes.length中的差异主要是因为IE8及更早版本与其他浏览器处理空白字符的方式不一样。IE9之前的版本不会为空白符创建节点。<br></p><blockquote><p>cloneNode()方法不会复制添加到DOM节点中的JavaScript属性，例如事件处理程序等。这个方法只复制特定、(在明确指定的情况下也复制)子节点，其他一切都不会复制。IE在此存在一个bug，即它会复制事件处理程序，所以我们建议在复制之前最好先移除事件处理程序。</p></blockquote><p><br>    要介绍的最后一个方法是normalize()，这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弟子规 （六）</title>
      <link href="/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%886%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%886%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="八、余力学文"><a href="#八、余力学文" class="headerlink" title="八、余力学文"></a>八、余力学文</h3><p><br>    【解】《弟子规》一共讲了七个方面内容，前六个方面讲孝、悌、谨、信、泛爱众、亲仁，这些都是让我们努力去落实而提升自己修养品德的，是讲力行这方面，而学文就是要学习圣贤经典，通过学习能帮助我们力行，这样力行就有了正确的方向，所以学问很重要，文不可不学。文化文化，就是要用文来化我们，学文的目的就是化自己，变化自己的气质，把文化到自己的一举手一投足，化到点点滴滴的生活中去。所以学文和力行是相辅相成、我们学到了圣贤教育，帮助指导我们去生活、工作、处事、待人、接物，这是在力行；真正力行了，对于圣贤的教诲，就会有新的悟处，就会有更深入的体验。力行是行门，学文是解门，解行要并重。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">不力行 &emsp;但学文 &emsp;涨浮华 &emsp;成何人</p><p style="margin-bottom: 0;"><br>    【解】不能身体力行孝、悌、谨、信、泛爱众、亲仁这些本分，一味死读书，纵然有些知识，也只是增长自己浮华不实的习气，怎能成为一个真正有用的人呢？如此读书又有何用？<br></p><p><br>    受教育的目的首先在“做人”，做一个有道德的人。古人读书是志在圣贤，而现在人读书是志在赚钱。很多家长和老师只注重孩子的成绩分数，不注重品行教育，结果小孩越学就越傲慢。讲得头头是道，自己没做到，这样就变成伪君子了，因此品德的提升比什么都重要。孩子学能力的真正目的是什么？为什么要学本事？这个要谨慎于开始！做家长和老师的一定要有正确的引导观念才行。现代社会受西方文化的影响，教育只是传授知识技能的手段，没有道德的指导，科技知识极有可能被滥用而贻害人类。对个人而言，有才无德会给自己和他人带来极大的痛苦，这是有目共睹的事实。所以，当务之急是努力恢复中国传统伦理道德教育，使每一个人都明白先做人、后做事的道理。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">但力行 &emsp;不学文 &emsp;任己见 &emsp;昧理真</p><p style="margin-bottom: 0;"><br>    【解】如果只是一味地做，而不去学习圣贤教诲，那就会变得自以为是，执着自己的见解，违背了真理，这也是不对的。<br></p><p><br>    人的学问，随着你阅历的丰富、人生的历练，应该要相对提升才对。如果你裹足不前，觉得自己已经学得不错了，任凭自己的想法来做一切事情，就很可能会做出许多不合义理之事。所以有空闲时要不忘展开圣贤的典籍，从圣贤的典籍中反观自照，找出内心与圣贤的差距，随顺圣贤的教诲，依教奉行。通过不断地学习，当我们把圣贤之道真正领会了，把圣贤的教诲转化成自己对世界的认识、体悟，转变成自己处理事情的方法，当我们真正有了这样的智慧之后，在生活中出现什么问题都可以得心应手、左右逢源，什么问题都可以解决，这样我们的人生旅途就会愈来愈幸福。这是提醒、勉励所有的人，读书要有恒心。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">读书法 &emsp;有三到 &emsp;心眼口 &emsp;信皆要</p><p style="margin-bottom: 0;"><br>    【解】读书的方法要注重三到：眼到、口到、心到。读书要专注，专注才能够深入领会文章的意思，如此方能收到事半功倍的效果。<br></p><p><br>    有很多孩子每天读到三更半夜，可是考出来的成绩却非常差，原因就是不懂得读书的要领。读书最重要的还是在于心，如果眼睛在看，口也在读，但是心没有专注在课业上，想着其他的事情，也是白看白读。所以古人从小培养孩子的专注力，就是让他背书，这样精神就集中。现在的孩子经常看电视、玩电脑、打游戏，精神不专注，书怎么能读得好呢？<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">方读此 &emsp;勿慕彼 &emsp;此未终 &emsp;彼勿起 </p><p style="margin-bottom: 0;"><br>    【解】研究学问要专一、专精才能深入，不能这本书才开始读没多久，又想看其他的书，或是这段还未读完、读通，就又想读另一段，这样永远也定不下心来。学东西不能一知半解，要精益求精。<br></p><p><br>    读书重要是在掌握纲领、真正落实，最忌贪多、贪快。你太躁进，心很浮动，跟学问就不相应。学东西、求学问甚至于世间的技能都要专而不能杂。现在很多家长让孩子一学就是三、四种才艺，不见得多就一定好。所谓“样样通样样松”，因为多就会乱，杂了就学不扎实，到最后哪一样也没有学精，甚至孩子还会产生厌学的心理。所以，我们做家长的确确实实要给孩子正确的知道。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">宽为限 &emsp;紧用功 &emsp;工夫到 &emsp;滞塞通</p><p style="margin-bottom: 0;"><br>    【解】在定读书计划的时候，不妨宽松一些，这样心里没有压力，但是工夫要用的紧，每天都要努力，不可以懈怠偷懒。日积月累功夫深了，原先窒碍不通、困顿疑惑之处，自然而然就都迎刃而解了。<br></p><p><br>    现在一般孩子读书是为了应付考试，平时不认真学习，不知今日事今日毕，问题累积下来，到临近考试时才开始知道用功，这样就非常被动了。所以读书要有计划，要会规划安排好时间，每天按计划好的内容一定完成，这样才有真正的受用。如果父母能给孩子树立好榜样，每天把家事做完以后就看书而不是看电视，这样孩子从小自然就能养成喜欢看书学习的好习惯了。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">心有疑 &emsp;随札记 &emsp;就人问 &emsp;求确义</p><p style="margin-bottom: 0;"><br>    【解】求学当中，心里有疑问，要马上把问题记录下来，一有机会就向良师益友请教，务必确实明白它的真义，一定要得到正确的答案才可通过，这是认真学习的态度。<br></p><p><br>    知识是学来的，也是问来的，只有在学中问，在问中学，并与观察思考结合起来，才能求得真知。我们从小就要养成勤学好问的习惯，有了问题，随时随地请教别人。只要他确实能给你启发、给你帮助，不管年长年幼、地位高低，都可以成为你的老师，古人所说的“能者为师”就是这个道理。但是，最主要还是靠自己先去探究，实在没有办法的时候，再请问别人，这样印象才会更深刻。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">房室清 &emsp;墙壁净 &emsp;几案洁 &emsp;笔砚正</p><p style="margin-bottom: 0;"><br>    【解】书房、卧室都要保持清洁、干净，墙壁也要干净，给自己创造一个良好的读书环境。桌面上笔墨纸砚等文具要防止整齐，不得凌乱。触目所及皆是井井有条，这样才能静下心来读书。<br></p><p><br>    现在孩子会自己整理房间书桌的非常少，几乎都是父母替他们整理。家长认为只要你学习好，什么都不用你管。这样就造成了孩子的生活自理能力非常差，从而给他以后的家庭、事业、人际关系带来许多的障碍。如果孩子是在这种教育理念下长大成人、结婚生子，婚后夫妻经常会因为家务活谁都不想承担、生活习惯不好而真吵不断，甚至结婚每两年就闹离婚。究其原因，都是家长从小舍不得让孩子学习做家事，不教他们自理，一味地照顾、迁就，最终使孩子养成了懒惰与不知感恩的心理。所以有远见的父母，一定从小就要有意识地锻炼孩子这些基本的生活能力，自己的事必须自己做，以便他们长大后能从容地面对各种挑战。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">墨磨偏 &emsp;心不端 &emsp;字不敬 &emsp;心先病</p><p style="margin-bottom: 0;"><br>    【解】古人写字使用毛笔，写字前先要磨墨，如果心不在焉，墨就会磨偏了。写出来的字如果歪歪斜斜，就表示你浮躁不安，心定不下来。<br></p><p><br>    汉字是传承我们中华文明的重要载体，是我华夏子孙传古颂今的宝贵财富。古人说：“意在笔先，心正则笔正”字如其人，一个人写字不认真，把字写得乱七八糟、歪七扭八，证明他的心没有专注在这个字上。这一笔写到哪里，到哪里该停，到哪里该顿，心里也没个底。同时也反映出他办事不认真、没规矩、心情浮躁。所以一定要把字写好，这样不仅继承发扬了民族的精华，还能培养自己认真严谨的作风。这些都是从我们平常的行为造作当中，看到自己的心态。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">列典籍 &emsp;有定处 &emsp;读看毕 &emsp;还原处</p><p style="margin-bottom: 0;"><br>    【解】书籍课本应分类，排列整齐，放在固定的位置，读诵完毕须归还原处。<br></p><p><br>    “动物归原”，这也是一个必不可少的良好习惯。无论我们用了什么东西，用完之后，要记得随手放回原位，这样不论是下次使用还是别人使用，都知道去哪里找，节省时间，提高效率。这样做事情便会有始有终，有条不紊。做父母的要做出很好的榜样来教导自己的小孩，自己看哪一本，桌上就放哪一本，不看的我们要放回原位，整整齐齐，恭恭敬敬，下一次要看时很快就可以找到。同时也要教导孩子，书要怎么排列比较整齐、好看、好拿，这才是治学的态度。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">虽有急 &emsp;卷束齐 &emsp;有缺坏 &emsp;就补之</p><p style="margin-bottom: 0;"><br>    【解】即使在有急事的时候，看完书也要把它顺手和尚，放回书架原处，要养成这种良好的习惯。遇到书本有残缺损坏时，应立刻修补好，保持完整，这是对书的恭敬、爱护。（古人一书难求，故有修补之举。）<br></p><p><br>    虽然今天得到书比古代容易多了，但是我们也要存着恭敬之心来爱惜这些书籍。在翻阅的时候要轻轻地翻，不要很粗鲁，以免折坏，也不要随便在书里乱画，把课本图的脏兮兮的，从小就要建立起爱护书籍的观念。如果你处处都能仔细小心，无形中就培养了你做事井井有条、少出差错、稳重安详的能力，这都是平时练出来的功夫。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">非圣书 &emsp;屏勿视 &emsp;蔽聪明 &emsp;坏心志</p><p style="margin-bottom: 0;"><br>    【解】不是传述圣贤道理言行的书籍以及有害身心健康的不良书刊，都应该摒弃不看。因为书里面不正当的事理会蒙蔽我们的聪明智慧，会败坏我们纯正的志向，使我们的身心受到污染，心志变得不健康。<br></p><p><br>    当今社会是信息社会，但并不是信息知道的越多就越聪明、人生就越幸福，现在不健康的电脑网络内容画面、电影电视节目以及叫我们杀盗淫妄的小说、故事、报章杂志等一些不良的出版物，污染特别严重，要防止自己受到污染，更要防止孩子受到污染。所以身为父母，一定要经常查看你的子女是否在接触这些不健康的内容，因为这些对孩子的身心伤害的确是非常之大。不必要的信息要尽量摒弃，专心于自己应做之事，才能心情宁静。因此，孔子说：“非礼勿视，非礼勿听，非礼勿言，非礼勿动”是非常科学的。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">勿自暴 &emsp;勿自弃 &emsp;圣与贤 &emsp;可驯致</p><p style="margin-bottom: 0;"><br>    【解】遇到困难或挫折时，不要自暴自弃，也不必愤世嫉俗，看什么都不顺眼，而应该发奋向上，努力学习，不怕挫折，把失败当做成功之母，任何美好的结局都要经过艰辛的努力才能得到。圣贤的境界虽高，循序渐进也是可以达到的。（孟子曰：“舜何人也，予何人也，有为者亦若是！”）<br></p><p style="margin-bottom: 0;"><br>    人对自己要有信心，所谓“天生我材必有用”。人一生首先要立定志向，“学贵立志”，有了目标、方向，在通过精进不懈地努力，成圣贤不是遥不可及的事，只要有心，终有成就的一天。有道是：“天下无难事，只怕有心人。”愿我们彼此相互勉励，共同携手向圣贤之道迈进！<br></p>    <p style="margin-bottom: 0;"><br>    一个为人父母者真正的成功在哪里？当他不在的时候，孩子还是非常懂事，离开父母的时候，孩子还能够遵照父母给予的正确人生态度去做人，这才叫真正的成功。孩子如同父母的心头肉，哪有父母不爱自己孩子的？但给予孩子的爱，是帮他还是害他，的确值得我们省思。可曾想过，当有一天孩子离开父母走入社会，谁又能向父母一样疼爱顺从他呢？纵然父母愿意一辈子照顾着子女，又能呵护到几时呢？这就如同温室里的花儿，一旦搬到室外，恐怕就要枯萎了。所以，孔子说：“人无远虑，必有近忧。”<br></p><p style="margin-bottom: 0;"><br>    所谓“至要莫若教子”，人生第一大事是要把孩子教好。假如我们的孩子没教好，你这一生会不会幸福？一个人有没有福报，一个人的人生能不能够过得自在，他的中、晚年取决于孩子懂不懂事、孝不孝顺。假如养育出来的孩子不懂事，我们后半辈子悔恨难熬！不知道孩子今天又会给我们上演哪一出戏，来让我们收拾残局？<br></p>    <p><br>    试想想，一个孩子如果没有受过《弟子规》的教育，任由自己的习气来成长，长大以后，这个习气已经变得根深蒂固了。所以，当他走入社会，在工作里面跟领导、同事的关系一定不可能处的好，结婚后跟另一半结合在一起，常常都是看别人毛病，又怎么可能有幸福快乐呢？以后如果又生了孩子，这个孩子能教得好吗？因此，要知道一个孩子的成长，如果没有这种良善的教育，吃亏的绝对不只是这一个孩子啊！他会影响身边所有的人，甚至影响到孩子的下一代。所以，一定要学习《弟子规》！<br></p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弟子规 （一）</title>
      <link href="/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84-%E6%80%BB%E5%8F%99/"/>
      <url>/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84-%E6%80%BB%E5%8F%99/</url>
      <content type="html"><![CDATA[<blockquote><p>以弟子规作为我学习传统文化的基础，首先树立良好的道德及情操，再去深入经藏，以期与古人神交。之前谈到《弟子规》总是不屑一顾，那都是小孩学的，我一个20多岁的人，是否太幼稚了。可是偶然的机会让我初识它，读到里面的经句。都会扪心自问到底有没有做到呢？（以一个成年人的姿态），这在古时候可是蒙童养正的书籍，是针对儿童的呀！念此私自愧，尽日不能忘！可是弟子规最后一句说到“勿自暴、勿自弃；圣与贤、可驯致”，故以此勉励自己，任何时候都不晚。发心领悟其中的深刻义理，把它落实到生活中。</p></blockquote><h3 id="一、总叙"><a href="#一、总叙" class="headerlink" title="一、总叙"></a>一、总叙</h3><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">弟子规 &emsp;圣人训 &emsp;首孝弟 &emsp;次谨信</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">泛爱众 &emsp;而亲仁 &emsp;有余力 &emsp;则学文</p><p style="margin-bottom: 0;"><br>    【解】《弟子规》这本书，是依据至圣先师孔子的教诲而编成的生活规范。它教导我们：首先在日常生活中要做到孝顺父母、友爱兄弟姐妹；其次在一切日常言语、行为中，要小心谨慎，要讲信用；与大众相处时要平等博爱，并且亲近有仁德的人，向他学习，这些都是很重要非做不可的事；如果还有多余的时间、精力，就应该好好学习六艺等其他有益的学问。<br></p><p style="margin-bottom: 0;"><br>    孔子教学，讲四门教育：德行、言语、政事、文学。四门教育首重教育，而《弟子规》是最好的德行教育课本，这个教育注重的是家庭教育，家教是最重要的扎根教育。家庭教育对一个人的性格、意志、品质、情操、爱好乃至人生观、世界观都起着根本作用。没有家教的小孩，即使学校教育再优秀，一生都不会有大成就。小孩在三岁以前离不开母亲，母亲的一言一行，小孩都在模仿与记忆，以母亲的一百哦作为自己的行为规范，这叫母仪母教。如果父母自己不自尊、不严格要求自己，你的小孩将向你学习什么呢？所以真正要让家庭教育有很好的进展，必须从家长开始提升。<br></p><br><p style="margin-bottom: 0;"><br>    《易经》里有一句话“蒙以养正，圣功也”，意思是孩子小时候就要给他培植正确处事待人的态度，养他的浩然正气，让他奠定德行的根基。你把小孩教好了，这个功德最神圣。为什么呢？因为祖国的未来就在孩子的手里，如果孩子没有德行，那么将来必定会影响社会和谐稳定，孩子如果是有才无德那是危险品、毒品。《三字经》说：“人之初、性本善。性相近，习相远，苟不教，性乃迁。”人的本性都是一样的，而习性就不一样了。因为人受的教育不同、受的熏染不同，在社会里受不良风气的熏染，他就变成坏人了，如果受到良好的教育，他就变成好人了。所以，我们要坚信品学兼优的孩子是教出来的。<br></p><br><p style="margin-bottom: 0;"><br>    有见识的有智慧的父母，一定是以圣贤之道来作为教育孩子的指导方针，通过学习、落实圣贤的教诲，让小孩能在一生获得幸福成功的人生乃至于成圣成贤。<br></p><h3 id="二、入则孝"><a href="#二、入则孝" class="headerlink" title="二、入则孝"></a>二、入则孝</h3><p><br>    【解】这一篇讲的是为人子之道，子女的本分就是一个孝字。古人云：“百善孝为先。”孝敬父母是中华民族的道德准则，人人皆知父母养育儿女之辛苦，要尽我所能来回报双亲，但这种良善的天性如不及时施以正确的教导，则此种感恩的心情很快会泯灭掉。不知不觉中，习惯了衣来伸手、饭来张口，就会认为父母疼我爱我乃天经地义之事；至于我也要疼爱父母，因无人教无人提醒，乃渐渐遗忘于脑后。没有使孝顺父母成为孩子的自觉行为，长大后埋怨孩子不懂孝道、对他人没有爱心，后悔已迟。所以，从小就要培养孩子的孝道精神。当他在家知道孝敬父母后，在外面才知道尊敬老师、长辈，他才能进一步把这份爱心扩展扩展到周边的一切人。所以，圣人提倡以孝治理天下，以孝治天下必定能得到和睦家庭、和谐社会、和谐世界。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">父母呼 &emsp;应勿缓 &emsp;父母命 &emsp;行勿懒</p><p style="margin-bottom: 0;"><br>    【解】父母叫我们，要马上答应，不能够迟缓。父母有事要我们去做，要立刻行动，不可拖延或推辞偷懒，这是对父母的一种尊敬<br></p><p><br>     孩子对父母讲话的态度，对小孩一生影响很深远。当他在与父母应答之间所形成的是孝心、恭敬心时，就为他以后的发展奠定了良好的基础。如果父母叫我们时拖拖拉拉，那就是一种傲慢，恭敬心就没有了。子游问孔子：以很丰厚的生活奉养父母，这个算不算是尽孝呢？孔子说：“至于犬马，皆能有养。不敬，何以别乎？”如果对父母没有恭敬心，那么养父母跟养狗、养马有什么区别呢？哪能叫尽孝呢？所以孝第一要培养的是敬，一切人伦之道都是以爱敬心为基础的，孝必定要跟恭敬心联系起来。当一个人在家里养成了这种对父母温和柔顺的态度与恭敬的存心后，踏入社会，他的这种修养一定会引起大家对他的重视和尊敬，这种恭敬的存心就是他幸福成功的源泉。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">父母教 &emsp;须敬听 &emsp;父母责 &emsp;须顺承</p><p style="margin-bottom: 0;"><br>    【解】父母教导我们做人处事的道理，是为了我们好，应该恭敬地聆听。做错了事，父母责备教诫时，应当虚心接受，不可强词夺理，使父母生气、伤心。父母的责备大部分都是出自于爱心，所以即使是父母说错了，我们心里明白，也不必跟父母顶嘴，有则改之，无则加勉。<br></p><p><br>    我们要深深感念父母不厌其烦地教导和成就我们的苦心，所谓“爱之深，责之切”，而为人子女者，却很少能体会父母这至深至爱之情。犯了错，不但不能接受父母的教诲，反而阳奉阴违，甚至起厌烦心说出冒犯父母的话，让父母伤心至极。故孔夫子说：“色难。”侍奉父母，难在永远保持和颜悦色。仔细想想，我们是否父母说一句而顶了很多句呢？深信每个人都希望能做一个孝子，因为自古以来孝子是最有福的人，那么就让我们先从事亲、悦亲、让父母心生欢喜开始吧！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">冬则温 &emsp;夏则凊 &emsp;晨则省 &emsp;昏则定</p><p style="margin-bottom: 0;"><br>    【解】为人子女，对父母要时时关心、处处留意。二十四孝的黄香，为了让父亲安心睡眠，夏天睡前会帮父亲把床铺扇凉，冬天寒冷时会为父亲温暖被窝，实在值得我们学习。早晨起来要向父母请安问好，下午回家之后，要将今天在外的情形告诉父母，向父母报平安，使老人家放心。<br></p><p><br>    这些行为虽然都是小事，但出处都表现出一个孝子的那种纯孝之心、知恩报恩的心。我们要知道，从孩子有了生命那天开始，父母就对子女百般呵护，衣食住行照顾得无微不至。作为感恩，子女关注留意父母的冷暖，这是天经地义的，况且子女给予父母的关爱比起父母的付出，万分之一也不及。而当一个人爱护父母养成了习惯后，他待人、处事、接物都有那种温、良、恭、俭、让的态度，这种人自然能得到大家的尊敬、爱戴。这样的人生虽是平凡，确是现今社会中的不凡之人了。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">出必告 &emsp;反必面 &emsp;居有常 &emsp;业无变</p><p style="margin-bottom: 0;"><br>    【解】外出离家时，须告诉父母要到哪里去，父母批准了我们才可以去。回家后还要当面禀报父母回来了，让父母安心，这些都是必要的礼貌。平时起居作息（生活习惯）要保持正常有规律，不要任意改变。长大以后，应居有定所、事业专注、切勿荒废、空过一生，让父母为我们担忧。<br></p><p><br>    这些行为都体现出一个孝子心里常常存着父母，因为心里存着父母，所以他必然就“出必告，反必面”。如果心里面把父母忘了，很可能这些细节他也忽略了。我们要体会到，它主要告诉我们对父母要常常惦记在心，常常有安慰父母、让父母安心的这个意念。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事虽小 &emsp;勿擅为 &emsp;苟擅为 &emsp;子道亏</p><p style="margin-bottom: 0;"><br>    【解】纵然是小事，也不要擅自做主而不向父母禀告。如果任性而为，容易出错，也有损为人子女的本分，因此而让父母担心，是不孝的行为。<br></p><p><br>    孩子第一次犯错，做父母的千万不可以含糊过去，一定要给予正确的纠正，不能迁就和纵容孩子，不能满足孩子的无理要求，不许任性，要让他懂得哭闹毫无意义，做任何事情必须讲道理，这样他会终身记住，不会再犯。所谓“慎于始”，一切都要谨慎于开始，而等他一错再错，再来纠正就不容易了。每个孩子都会犯错，如果我们对孩子的缺点和错误，在仔细分析的基础上给予批评，并心平气和地把道理给他讲清楚，再教他正确的做法，使孩子接受起来口服心服。这种处理孩子不良行为的方法既充满关爱，又不失威严，并且能够加深母子之间的感情。当我们有了这些正确的做法时，孩子犯错，自然而然机会意识到，这正是教育他的最佳时机，就不会因为乱发脾气，而把教育的机会点错过了。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">物虽小 &emsp;勿私藏 &emsp;苟私藏 &emsp;亲心伤</p><p style="margin-bottom: 0;"><br>    【解】东西虽然很小，也不要背着父母，偷偷地私藏起来。一旦被发现，父母心里一定十分伤心生气。<br></p><p><br>    即使小到一颗糖果，如果没有经过主人同意，就私自把它隐藏起来，那就等于是小偷。这种行为会让父母蒙羞，感到是一种羞耻。所以，我们为人父母要在这些方面特别谨慎注意，应该经常查看孩子的书包、口袋，看是否有来路不明的东西，是不是多出了一些文具或用品。如果有的话，可能孩子的手已经犯了不干净的行为。谚云：“小时偷针，大时偷金。”如不及时制止，发展下去就会对品德造成很大的伤害，这很可能就因此而毁了他一生的前途。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲所好 &emsp;力为具 &emsp;亲所恶 &emsp;谨为去</p><p style="margin-bottom: 0;"><br>    【解】父母亲所喜好的东西，当子女的应该尽力去准备齐全，父母亲所厌恶的事情，要小心谨慎地去除掉（包含自己的坏习惯）。<br></p><p style="margin-bottom: 0;"><br>    在日常生活中我们要处处留心、时时在意，一言一行都要以父母作为主要考虑。要从衣食住上细心观察，使父母的口福不缺，按四季更换衣服，卧宿使其安适，行动有人扶持；父母所爱植物，我必爱之，父母所爱之人，我当敬之，父母所愿意的事，我当奉行之，要时时顺着父母的心意，使其心生欢喜。读懂父母的心声、父母的需求，这才是真正的孝道。相反，当我们起一个坏的念头，比如说起了贪心、起了跟人家争斗的心以及不好学进取、种种不善的念头，这都是对不起父母啊！这些我们都要小心地把它去除掉，所以这个孝必要从这点点滴滴去养成。<br></p><p><br>    这让我不禁想到孝经中的一句话“身体发肤，受之父母，不敢损伤，孝之始也；立身行道，扬名于后世，以显父母，孝之终也。”<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">身有伤 &emsp;贻亲羞 &emsp;德有伤 &emsp;贻亲羞</p><p style="margin-bottom: 0;"><br>    【解】要爱护自己的身体，不要使身体受到伤害，让父母忧虑。更要注重自己的品德修养，不可以做出伤风败德的事，使父母亲蒙受耻辱。<br></p><p><br>    有人抱怨说：父母怎么管我这么多？实在是因为你不能让父母放心啊！假如你知道照顾好自己的身体，生活起居饮食有规律，进而让自己更懂事，这样父母就放心了。现在不健康的网络、影视、杂志媒体太发达，人与人之间交流很频繁，假如你没有判断力，又没有理智，就会收到邪恶思想的污染而堕落。到时候不但父母家人蒙羞，甚至连下一代也有可能蒙羞，这是大不孝，所以从小就要学会自尊自爱，保持身心的清净健康很重要。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲爱我 &emsp;孝何难 &emsp;亲憎我 &emsp;孝方贤</p><p style="margin-bottom: 0;"><br>    【解】当父母喜爱我们时，孝顺是很容易地事情。当父母不喜欢我们或者管教过于严厉时，我们一样孝顺，还能够自己反省检点，体会父母的良苦用心，努力改过并且做得更好，这种孝顺的行为最是难能可贵。<br></p><p><br>    父母即使不慈，也不应该称为自己不尽孝的理由。因为父母给予生命并将自己抚育成人，这个恩德太大，做儿女的用任何方法都是无法回报的。但是父母身上可能会有缺点，作为儿女也应该感父母养育之恩而加以包容，不可以以此作为自己不孝的理由，这是功利观，而非道义观。人伦之道的关键是先尽自己一方的责任，而不能以他人尽责与否作为我们是否尽责的前提条件。我们与人相处要记住一个原则，“不管别人对不对，自己一定要做对”，无论是父母还是身边所有的人，纵使他们用不对的态度对我，我依然要用对的态度去面对他们，不然我也是跟他一般见识了，根本没有资格去说别人的错。以怨报怨，结果会造成更加严重的对立矛盾。我们要相信“精诚所至，金石为开”，这样才能上演人生一出又一出的好戏。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲有过 &emsp;谏使更 &emsp;怡吾色 &emsp;柔吾声</p><p style="margin-bottom: 0;"><br>    【解】父母有过失，当子女的应小心劝导改过向善。态度一定要诚恳，声音必须柔和，应做到和颜悦色地把道理讲清楚、讲明白。<br></p><p><br>    孝顺并不是一定要对父母百依百顺，人与人之间所有的行为都要以“道义”为准则，父母子女之间也不例外。人无完人，父母也难免有过错，子女如果对此听之任之、不闻不问，也是一种不孝的表现。因为父母的过错会给自己和家庭带来损失、伤害，作为子女，爱父母，就有劝导帮助父母的责任，而劝导帮助的关键是你的态度和方式、方法。因此，我们在劝谏时绝对不可板着面孔，一派指责的言语，好似在教训父母一样，这样父母肯定是没有办法接受的。而应当见机行事，以虔敬的心、善巧的言语，或请适当的长者来帮忙，这样效果才更好，也会使父母子女之间的亲情更加融洽、家庭更加和睦。为人父母者，我们读到这一条，也更应该警诫、反省自己有无过失及不良的习惯，如果有，就要及时把它改正过来，这样才能做好榜样让子女效法。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">谏不入 &emsp;悦复谏 &emsp;号泣随 &emsp;挞无怨</p><p style="margin-bottom: 0;"><br>    【解】如果父母不听规劝，要耐心等待，一有适当时机，例如父母情绪好转或是高兴的时候，再继续劝导。如果父母仍固执不听，甚至生气，此时我们虽然难过得痛哭流涕，也要恳求父母改过。因为，有孝心的人是不忍心陷父母于不义的。纵然遭到责打，我们也无怨无悔，不能使父母一错再错、铸成大错。<br></p><p><br>    不论我们规劝谁，都要建立在对方对我们有很深信任的基础上，而这个信任绝对不是凭空而来的，你必须要在长期的相处中，时时观察对方的需求，然后真心地去关怀与付出，才能赢得别人的信任。进而再去适当的时机进行规劝，才会有效果。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲有疾 &emsp;药先尝 &emsp;昼夜侍 &emsp;不离床</p><p style="margin-bottom: 0;"><br>    【解】父母亲生病时，子女应当尽心尽力地照顾，古人熬制中药，在给父母服用之前都会先尝一下，看看温度凉热是否适宜。昼夜侍奉在父母的床前，这是一种孝心的流露。<br></p><p><br>    想一想当子女生病时，做父母的恨不得自己去替孩子生病，那心血的付出是世上少有的。如今父母生病了，最需要自己的子女在身边陪伴照顾起居，我们岂能因为工作太忙或没有时间，就放弃这种尽孝的机会呢？所谓“树欲静而风不止，子欲养而亲不待”，故行孝当及时，错过机会，将是终身的遗憾！等父母过世后，才想到要奉养父母，那时就悔之晚矣！孝亲不是难事，只要我们肯承担，只要我们真正生起对父母的报恩之心，就没有做不到的事情。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">丧三年 &emsp;常悲咽 &emsp;居处变 &emsp;酒肉绝</p><p style="margin-bottom: 0;"><br>    【解】当父母亲不幸去世，守孝期间（古礼三年），要常常追思、感怀父母教养的恩德，因而经常悲伤哭泣。自己的生活起居必须调整改变，不能贪图享受，应该戒绝酒肉（请参考《地藏菩萨本愿经》，孝子应如何给往生者修福）。<br></p><p><br>    一个孝子他很难接受父母离去的现实，自然而然就会有这样的情绪：当想到父母一把屎一把尿，用尽心力，累到耳聋眼花，牙也掉了，腿疼腰弯，行动不便，一生辛苦地把我们培育成人；想到父母待我之慈爱真心，而自己尚未报父母之恩于万一；想到以往跟父母在一起的种种情形，眼泪就忍不住掉下来。这种感怀之情，是一个孝子发自内心自然做出来的。父母都离去了，他还会吃好的、穿好的、用好的，去花天酒地吗？不可能的，自然而然对那些挥霍、酒肉就不想。这都是对父母一种哀悼的表现。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">丧尽礼 &emsp;祭尽诚 &emsp;事死者 &emsp;如事生</p><p style="margin-bottom: 0;"><br>    【解】办理父母亲的丧事要哀戚合乎礼节，不可草率马虎，也不要为了面子铺张浪费，才是真孝顺。祭拜时应诚心诚意，对待已经去世的父母，要如同生前一样恭敬。《论语》云：“慎终追远，民德归厚矣。”中国古礼特重葬礼，而重视丧葬之根本目的是在教化活人，以此来培养人们的道德品性和反哺报恩的观念。人与人之间的感情很容易夹杂势利的因素而不纯粹，唯有对死者，没有欲望，只有真情。现在当然可以改革葬礼仪式，不必厚葬，但一定要有对父母的真情，切不可流于形式。<br></p><p style="margin-bottom: 0;"><br>    父母过世以后（父母的祭日、清明节、冬至节）祭祀父母、祭祀祖先，这是一种缅怀父母祖先恩德的活动。父母在生的时候，我们要爱敬自己的父母，父母不在了，我们对父母的那种怀念，也是一生不改啊！特别是要更加努力地来做人、行义，不可以做出亏欠父母、让父母蒙羞的事情，要对得起父母的在天之灵，这也是对父母尽孝啊！<br></p><p style="margin-bottom: 0;"><br>    人生在世，父母与我们最亲，给我们的恩情也最重。所以，人一生最重要的就是对得起自己的父母。努力学习侍奉父母的礼节，把孝养父母当成人生中最重要的一件大事业，用心努力来完成，做到仰不愧于天、俯不怍于地，心胸坦荡地立足于天地之间。千万不要上演“树欲静而风不止，子欲养而亲不待”的人生悲剧，这种心痛一定会缠绕我们一生……使我们的内心经常会在自责与后悔的阴影下痛苦地煎熬着，无法得到安宁。切记，切记！如果生前不尽心奉养，让父母寒心而去，死的时候花一大把钱，那就是太颠倒了，这是大不孝啊！<br></p><p style="margin-bottom: 0;"><br>    所以，我们要把孝深深地根植于我们的心中，尊重、感恩、顶礼我们的父母，是他们给了我们生命，仅此一恩已经足矣，更不用说难以报答的养育之恩。莫论父母的是是非非、恩恩怨怨，他们也是人，岂能事事明理、处处正确？无论如何，当他们老了，糊涂了，脾气古怪了，不通情理了，我们要把他们当孩子疼、当孩子爱。原谅宽容每一位天下的老人，珍惜老人的好心情，哪个不是我们的白发亲人，我们哪个不是会变成别人的白发亲人？<br></p><p><br>    《孝经》云：“立身行道，扬名于后世，以显父母，孝之终也。”孝到了终极，是要立身行道啊！要让父母成为圣贤人的父母，这是大孝啊！大孝的人，要以身济世，救济这个世间，正如古人所讲的“为天地立心，为生民立命，为往圣继绝学，为万世开太平”。<br></p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组(二)</title>
      <link href="/2018/06/27/%E6%95%B0%E7%BB%84%EF%BC%882%EF%BC%89/"/>
      <url>/2018/06/27/%E6%95%B0%E7%BB%84%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-8-数组方法"><a href="#1-8-数组方法" class="headerlink" title="1.8 数组方法"></a>1.8 数组方法</h3><blockquote><p>ECMAScript 3在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。下面将先介绍ECMAScript 3中的这些方法。然后还涉及到ECMAScript 5中新增的一些数组遍历方法。</p></blockquote><h3 id="1-8-1-join"><a href="#1-8-1-join" class="headerlink" title="1.8.1 join()"></a>1.8.1 join()</h3><p><br>    Array.join()方法将数组中的所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。如以下代码所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3];// 创建一个包含三个元素的数组</div><div class="line">a.join();// =&gt; &quot;1, 2, 3&quot;</div><div class="line">a.join(&quot; &quot;);// =&gt; &quot;1 2 3&quot;</div><div class="line">a.join(&quot;&quot;);// =&gt; &quot;123&quot;</div><div class="line">var b = new Array(10);// 长度为10的空数组</div><div class="line">b.join(&apos;-&apos;)// =&gt; &apos;----------&apos;：9个连字号组成的字符串</div></pre></td></tr></table></figure><p><br>    Array.join()方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。<br></p><h3 id="1-8-2-reverse"><a href="#1-8-2-reverse" class="headerlink" title="1.8.2 reverse()"></a>1.8.2 reverse()</h3><p><br>    Array.reverse()方法将数组中的元素颠倒顺序，返回逆序的数组。它采取了替换，换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们。例如，下面的代码使用reverse()和join()方法生成字符串“3, 2, 1”：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3];</div><div class="line">a.reverse().join()// =&gt; &quot;3, 2, 1&quot;,并且现在的a是[3, 2, 1]</div></pre></td></tr></table></figure><h3 id="1-8-3-sort"><a href="#1-8-3-sort" class="headerlink" title="1.8.3 sort()"></a>1.8.3 sort()</h3><p><br>    Array.sort()方法将数组中的元素排序并返回排序后的数组。当不带参数调用sort()时，数组元素以字母表顺序排序(如果有必要将临时转化为字符串进行比较):<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = new Array(&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;);</div><div class="line">a.sort();</div><div class="line">var s = a.join(&quot;, &quot;);// s == &quot;apple, banana, cherry&quot;</div></pre></td></tr></table></figure><p><br>    如果数组包含undefined元素，它们会被排到数组的尾部。为了按照其他方式而非字母表顺序进行数组排序，必须给sort()方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于0的数组。反之，假设第一个参数在后，函数应该返回一个大于0的数值。并且，假设两个值相等(也就是说，它们的顺序无关紧要),函数应该返回0.因此，用数值大小而非字母表顺序进行数组排序，代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = [33, 4, 1111, 222];</div><div class="line">a.sort();// 字母表顺序： 1111, 222, 33, 4</div><div class="line">a.sort(function(a, b) &#123;// 数值顺序：4, 33, 222, 1111</div><div class="line">    return a-b;// 根据顺序，返回负数、0、正数</div><div class="line">&#125;);</div><div class="line">a.sort(function(a, b) &#123; return b-a &#125;);// 数值大小相反的顺序</div></pre></td></tr></table></figure><p><br>    注意，这里使用匿名函数表达式非常方便。既然比较函数只是用一次，就没必要给它们命名了。<br></p><p><br>    另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表顺序，比较函数首先将参数都转化为小写字符串(使用toLowerCase()方法)，再开始比较：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a = [&apos;ant&apos;, &apos;Bug&apos;, &apos;cat&apos;, &apos;Dog&apos;]</div><div class="line">a.sort();// 区分大小写的排序：[&apos;Bug&apos;, &apos;Dog&apos;, &apos;ant&apos;, &apos;cat&apos;]</div><div class="line">a.sort(function(s, t) &#123;// 不区分大小写的排序</div><div class="line">    var a = s.toLowerCase();</div><div class="line">    var b = t.toLowerCase();</div><div class="line">    if (a &lt; b) return -1;</div><div class="line">    if (a &gt; b) return 1;</div><div class="line">    return 0;</div><div class="line">&#125;);// =&gt; [&apos;ant&apos;, &apos;Bug&apos;, &apos;cat&apos;, &apos;Dog&apos;]</div></pre></td></tr></table></figure><h3 id="1-8-4-concat"><a href="#1-8-4-concat" class="headerlink" title="1.8.4 concat()"></a>1.8.4 concat()</h3><p><br>    Array.concat()方法创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连续的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化数组的数组。concat()也不会修改调用的数组。下面有一些示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3];</div><div class="line">a.concat(4, 5)// 返回[1, 2, 3, 4, 5]</div><div class="line">a.concat([4, 5]);// 返回[1, 2, 3, 4, 5]</div><div class="line">a.concat([4, 5], [6, 7])// 返回[1, 2, 3, 4, 5, 6, 7]</div><div class="line">a.concat(4, [5, [6, 7]])// 返回[1, 2, 3, 4, 5, [6, 7]]</div></pre></td></tr></table></figure><h3 id="1-8-5-slice"><a href="#1-8-5-slice" class="headerlink" title="1.8.5 slice()"></a>1.8.5 slice()</h3><p><br>    Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二个参数指定的位置之间的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现负数，它表示相对于数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。注意，slice()不会修改调用的数组。下面有一些示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5];</div><div class="line">a.slice(0, 3);// 返回[1, 2, 3]</div><div class="line">a.slice(3);// 返回[4, 5]</div><div class="line">a.slice(1, -1);// 返回[2, 3, 4]</div><div class="line">a.slice(-3, -2);// 返回[3]</div></pre></td></tr></table></figure><h3 id="1-8-6-splice"><a href="#1-8-6-splice" class="headerlink" title="1.8.6 splice()"></a>1.8.6 splice()</h3><p><br>    Array.splice()方法是在数组中插入或删除元素的通用方法。不同于slice()和concat()，splice()会修改调用的数组。注意，splice()和slice()拥有非常相似的名字，但它们的功能却有本质的区别。<br></p><p><br>    splice()能够从数组中删除元素、插入元素到数组中或者同事完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减少它们的索引值，因此数组的其他部分仍然保持连续的。splice()的第一个参数指定了插入和(或)删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice()返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5, 6, 7, 8];</div><div class="line">a.splice(4);// 返回[5, 6, 7, 8]; a是[1, 2, 3, 4]</div><div class="line">a.splice(1, 2);// 返回[2, 3]; a是[1, 4]</div><div class="line">a.splice(1, 1);// 返回[4]; a是[1]</div></pre></td></tr></table></figure><p><br>    splice()的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5];</div><div class="line">a.splice(2, 0, &apos;a&apos;, &apos;b&apos;);// 返回[]; a是[1, 2, &apos;a&apos;, &apos;b&apos;, 3, 4, 5]</div><div class="line">a.splice(2, 2, [1, 2], 3);// 返回[&apos;a&apos;, &apos;b&apos;]; a是[1, 2, [1, 2], 3, 4, 5]</div></pre></td></tr></table></figure><p><br>    注意，区别于concat(),splice()会插入数组本身而非数组的元素。<br></p><h3 id="1-8-7-push-和pop"><a href="#1-8-7-push-和pop" class="headerlink" title="1.8.7 push()和pop()"></a>1.8.7 push()和pop()</h3><p><br>    push()和pop()方法允许将数组当做栈来调用。push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop()方法则相反：它删除数组的最后一个元素，减少数组长度并返回它删除的值。注意，这两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用push()和pop()能够用JavaScript数组实现先进后出的栈。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var stack = [];// stack：[]</div><div class="line">stack.push(1, 2);// stack: [1, 2]返回2</div><div class="line">stack.pop();// stack: [1]返回2</div><div class="line">stack.push(3);// stack: [1, 3]返回2</div><div class="line">stack.pop();// stack: [1]返回3</div><div class="line">stack.push([4, 5])// stack: [1, [4, 5]] 返回2</div><div class="line">stack.pop() // stack: [1]返回[4, 5]</div><div class="line">stack.pop();// stack: []返回1</div></pre></td></tr></table></figure><h3 id="1-8-8-unshift-和shift"><a href="#1-8-8-unshift-和shift" class="headerlink" title="1.8.8 unshift()和shift()"></a>1.8.8 unshift()和shift()</h3><p><br>    unshift()和shift()方法的行为非常类似于push()和pop(),不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。unshift()在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。shift()删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = [];// a: []</div><div class="line">a.unshift(1);// a: [1]返回：1</div><div class="line">a.unshift(22);// a: [22, 1]返回：2</div><div class="line">a.shift();// a: [1]返回22</div><div class="line">a.unshift(3, [4, 5]);// a: [3, [4, 5], 1]返回3</div><div class="line">a.shift();// a: [[4, 5], 1]返回3</div><div class="line">a.shift();// a: [1]返回：[4, 5]</div><div class="line">a.shift();// a: []返回： 1</div></pre></td></tr></table></figure><p><br>    注意，当使用多个参数调用unshift()时它的行为令人惊讶。参数是一次性插入的(就像splice()方法)而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。<br></p><h3 id="1-8-9-toString-和toLocaleString"><a href="#1-8-9-toString-和toLocaleString" class="headerlink" title="1.8.9 toString()和toLocaleString()"></a>1.8.9 toString()和toLocaleString()</h3><p><br>    数组和其他JavaScript对象一样拥有toString()方法。针对数组，该方法将其每个元素转换为字符串(如有必要将调用元素的toString()方法)并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].toString()// 生成&apos;1, 2, 3&apos;</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].toString()// 生成&apos;a, b, c&apos;</div><div class="line">[1, [2, &apos;c&apos;]].toString()// 生成&apos;1, 2, c&apos;</div></pre></td></tr></table></figure><p><br>    注意，这里与不使用任何参数调用join()方法返回的字符串是一样的。<br></p><p><br>    toLocaleString()是toString()方法的本地化版本。它调用元素的toLocaleString()方法将每个数组元素转化为字符串，并且使用本地化(和自定义实现的)分隔符将这些字符串连接起来生成最终的字符串。<br></p><h3 id="1-9-ECMAScript-5中的数组方法"><a href="#1-9-ECMAScript-5中的数组方法" class="headerlink" title="1.9 ECMAScript 5中的数组方法"></a>1.9 ECMAScript 5中的数组方法</h3><p><br>    ECMAScript 5定义了9个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组，下面将分别介绍这些方法。<br></p><p><br>    但在开始详细介绍之前，很有必要对ECMAScript 5中的数组方法做一个概述。首先，大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，可以忽略后两个参数。大多数ECMAScript 5数组方法的第一个参数是一个函数，第二个参数是可选的。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用的函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript 5中的数组方法都不会修改它们调用的原始数组。当然，传递给这些方法的函数是可以修改这些数组的。<br></p><h3 id="1-9-1-forEach"><a href="#1-9-1-forEach" class="headerlink" title="1.9.1 forEach()"></a>1.9.1 forEach()</h3><p><br>    forEach()方法从头至尾遍历数组，为每个元素调用指定的函数。如上所述，传递的函数作为forEach()的第一个参数。然后forEach()使用三个参数调用该函数：数组元素、元素的索引和数组本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var data = [1, 2, 3, 4, 5];// 要求和的数组</div><div class="line">// 计算数组元素和值</div><div class="line">var sum = 0;// 初始为0</div><div class="line">data.forEach(function(value) &#123; sum += value; &#125;);// 将每个值累加到sum上</div><div class="line">sum // =&gt; 15</div><div class="line">// 每个数组元素的值自加1</div><div class="line">data.forEach(function(v, i, a) &#123; a[i] = v + 1; &#125;);</div><div class="line">data // =&gt; [2, 3, 4, 5, 6]</div></pre></td></tr></table></figure><p><br>    注意，forEach()无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach方法放到一个try块中，并能抛出一个异常。如果forEach()调用的函数抛出foreach.break异常，循环会提前终止：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foreach(a, f, t) &#123;</div><div class="line">    try &#123;</div><div class="line">        a.forEach(f, t);</div><div class="line">    &#125; catch(e) &#123;</div><div class="line">        if (e === foreach.break) return;</div><div class="line">        else throw e;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foreach.break = new Error(&quot;StopInteration&quot;);</div></pre></td></tr></table></figure><h3 id="1-9-2-map"><a href="#1-9-2-map" class="headerlink" title="1.9.2 map()"></a>1.9.2 map()</h3><p><br>    map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3];</div><div class="line">b = a.map(function(x) &#123; return x*x; &#125;);// b是[1, 4, 9]</div></pre></td></tr></table></figure><p><br>    传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该有返回值。注意，map()返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素/<br></p><h3 id="1-9-3-filter"><a href="#1-9-3-filter" class="headerlink" title="1.9.3 filter()"></a>1.9.3 filter()</h3><p><br>    filter()方法返回的数组元素的一个子集。传递的函数是用来逻辑判定的：该函数返回true或false。调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [5, 4, 3, 2, 1];</div><div class="line">smallvalues = a.filter(function(x) &#123; return x &lt; 3 &#125;);// [2, 1]</div><div class="line">everyother = a.filter(function(x, i) &#123; return i % 2 &#125;);// [5, 3, 1]</div></pre></td></tr></table></figure><p><br>    注意，filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var dense = sparse.filter(function() &#123; return true; &#125;);</div></pre></td></tr></table></figure><p><br>    甚至，压缩空缺并删除undefined和null元素，可以这样使用filter():<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = a.filter(function(x) &#123; return x !== undefined &amp;&amp; x != null; &#125;);</div></pre></td></tr></table></figure><h3 id="1-9-4-every-和some"><a href="#1-9-4-every-和some" class="headerlink" title="1.9.4 every()和some()"></a>1.9.4 every()和some()</h3><p><br>    every()和some()方法是数组的逻辑判定：它们对数组应用指定的函数进行判定，返回true或false。<br></p><p><br>    every()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定函数都返回ture，它才返回true：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3, 4, 5];</div><div class="line">a.every(function(x) &#123; return x &lt; 10; &#125;)// =&gt; true：所有的值小于10</div><div class="line">a.every(function(x) &#123; return x % 2 === 0; &#125;)// =&gt; false：不是所有的值都是偶数</div></pre></td></tr></table></figure><p><br>    some()方法就像数学中的“存在”量词：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且仅当数值中的所有元素调用判定函数都返回false，它才返回false：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3, 4, 5];</div><div class="line">a.some(function(x) &#123; return x%2 === 0; &#125;)// =&gt; true：a含有偶数值</div><div class="line">a.some(isNaN)// false：a不包含非数值元素</div></pre></td></tr></table></figure><p><br>    注意，一旦every()和some()确认该返回什么值时它们就会停止遍历数组元素。some()在判定函数第一次返回true就返回true，但如果判定函数一直返回false，它将会遍历整个数组。every()恰好相反：它在判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将遍历整个数组。注意，根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false.<br></p><h3 id="1-9-5-reduce-和reduceRight"><a href="#1-9-5-reduce-和reduceRight" class="headerlink" title="1.9.5 reduce()和reduceRight()"></a>1.9.5 reduce()和reduceRight()</h3><p><br>    reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。举例来说它是如何工作的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5];</div><div class="line">var sum = a.reduce(function(x, y) &#123; return x+y &#125;, 0);// 数组求和</div><div class="line">var product = a.reduce(function(x, y) &#123; return x*y &#125;, 1);// 数组求积</div><div class="line">var max = a.reduce(function(x, y) &#123; return (x&gt;y)?x:y &#125;);// 求最大值</div></pre></td></tr></table></figure><p><br>    reduce()需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。<br></p><p><br>    reduce()使用的函数与forEach()和map()使用的函数不同。比较熟悉的是，数组元素、元素索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止化简操作累积的结果。第一次调用函数时，第一个参数是一个初始值，它就是传递给reduce()的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在上面的第一个例子中，第一次调用化简函数时的参数是0和1.将两者相加并返回1.再次调用时的参数是1和2，它返回3.然后它计算3+3=6、6+4=10，最后计算10+5=15.最后的值是15.reduce()返回这个值。<br></p><p><br>    可能已经注意到了，上面第三次调用reduce()时只有一个参数：没有指定初始值。当不指定初始值调用reduce()时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个数组参数。在上面求和与求积的例子中，可以省略初始值参数。<br></p><p><br>    在空数组上，不带初始值参数调用reduce()将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值——reduce()只是简单地返回那个值而不会调用化简函数。<br></p><p><br>    reduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低(从右到左)处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，你可能想使用它，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4];</div><div class="line">// 计算2^(3^4)。乘方操作的优先顺序是从右到左</div><div class="line">var big = a.reduceRight(function(accumulator, value) &#123;</div><div class="line">    return Math.pow(value, accumulator);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><br>    注意，reduce()和reduceRight()都能接收一个可选的参数，它指定了化简函数调用时this关键字的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，请参看Function.bind()方法。<br></p><p><br>    值得注意的是，上面描述的every()和some()方法是一种类型的数组化简操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。<br></p><p><br>    为了简单起见，到目前位置所展示的例子都是数值的，但数学计算不是reduce()和reduceRight()的唯一意图。union()函数。它计算两个对象的“并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和化简函数一样，并且可以使用reduce()来把它一般化，计算任意数目的对象的“并集”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var objects = [&#123;x: 1&#125;, &#123;y: 2&#125;, &#123;z: 3&#125;];</div><div class="line">var merged = objects.reduce(union);// =&gt; &#123;x: 1, y: 2, z: 3&#125;</div></pre></td></tr></table></figure><p><br>    回想一下，当两个对象拥有同名的属性时，union()函数使用第一个参数的属性值。这样，reduce()和reduceRight()在使用union()时给出了不同的结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var objects = [&#123;x: 1, a: 1&#125;, &#123;y: 2, a: 2&#125;, &#123;z: 3, a: 3&#125;];</div><div class="line">var leftunion = objects.reduce(union);// &#123;x: 1, y: 2, z: 3, a: 1&#125;</div><div class="line">var rightunion = objects.reduceRIght(union);// &#123;x: 1, y: 2, z: 3, a: 3&#125;</div></pre></td></tr></table></figure><h3 id="1-9-6-indexOf-和lastIndexOf"><a href="#1-9-6-indexOf-和lastIndexOf" class="headerlink" title="1.9.6 indexOf()和lastIndexOf()"></a>1.9.6 indexOf()和lastIndexOf()</h3><p><br>    indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1.indexOf()从头至尾搜索，而lastIndexOf()则反向搜索。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [0, 1, 2, 1, 0];</div><div class="line">a.indexOf(1)// =&gt; 1：a[1]是1</div><div class="line">a.lastIndexOf(1)// =&gt; 3：a[3]是1</div><div class="line">a.indexOf(3)// =&gt; -1：没有值为3的元素</div></pre></td></tr></table></figure><p><br>    不同于本节描述的其他方法，indexOf()和lastIndexOf()方法不接收一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索。如果省略该参数，indexOf()从头开始搜索，而lastIndexOf()从末尾开始搜索。第二个参数也可以是负数，它代表相对数组末尾的偏移量，对于splice()方法：例如，-1指定数组的最后一个元素。<br></p><p><br>    如下函数在第一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用indexOf()的第二个参数来查找除了第一个以外匹配的值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组</div><div class="line">function findall(a, x) &#123;</div><div class="line">    var results = [],</div><div class="line">        len = a.length,</div><div class="line">        pos = 0;</div><div class="line">    while(pos &lt; len) &#123;</div><div class="line">        pos = a.indexOf(x, pos);</div><div class="line">        if (pos === -1) break;</div><div class="line">        results.push(pos);</div><div class="line">        pos = pos + 1;</div><div class="line"> &#125;</div><div class="line"> return results;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    注意，字符串也有indexOf()和lastIndexOf()方法，它们和数组方法的功能类似。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弟子规</title>
      <link href="/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84/"/>
      <url>/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84/</url>
      <content type="html"><![CDATA[<p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">总叙</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">弟子规 &emsp;圣人训 &emsp;首孝弟 &emsp;次谨信</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">泛爱众 &emsp;而亲仁 &emsp;有余力 &emsp;则学文</p><p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">入则孝</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">父母呼 &emsp;应勿缓 &emsp;父母命 &emsp;行勿懒</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">父母教 &emsp;须敬听 &emsp;父母责 &emsp;需顺承</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">冬则温 &emsp;夏则凊 &emsp;晨则省 &emsp;昏则定</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">出必告 &emsp;反必面 &emsp;居有常 &emsp;业无变</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事虽小 &emsp;勿擅为 &emsp;苟擅为 &emsp;子道亏</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">物虽小 &emsp;勿私藏 &emsp;苟私藏 &emsp;亲心伤</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲所好 &emsp;力为具 &emsp;亲所恶 &emsp;谨为去</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">身有伤 &emsp;贻亲忧 &emsp;德有伤 &emsp;贻亲羞</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲爱我 &emsp;孝何难 &emsp;亲憎我 &emsp;孝方贤</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲有过 &emsp;谏使更 &emsp;怡吾色 &emsp;柔吾声</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">谏不入 &emsp;悦复谏 &emsp;号泣随 &emsp;挞无怨</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">亲有疾 &emsp;药先尝 &emsp;昼夜侍 &emsp;不离床</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">丧三年 &emsp;常悲咽 &emsp;居处变 &emsp;酒肉绝</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">丧尽礼 &emsp;祭尽诚 &emsp;事死者 &emsp;如事生</p><p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">出则弟</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">兄道友 &emsp;弟道恭 &emsp;兄弟睦 &emsp;孝在中</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">财物轻 &emsp;怨何生 &emsp;言语忍 &emsp;忿自泯</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">或饮食 &emsp;或坐走 &emsp;长者先 &emsp;幼者后</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">长呼人 &emsp;即代叫 &emsp;人不在 &emsp;己即到</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">称尊长 &emsp;勿呼名 &emsp;对尊长 &emsp;勿见能</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">路遇长 &emsp;疾趋揖 &emsp;长无言 &emsp;退恭立</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">骑下马 &emsp;乘下车 &emsp;过犹待 &emsp;百步余</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">长者立 &emsp;幼勿坐 &emsp;长者坐 &emsp;命乃坐</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">尊长前 &emsp;声要低 &emsp;低不闻 &emsp;却非宜</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">进必趋 &emsp;退必迟 &emsp;问起对 &emsp;视勿移</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事诸父 &emsp;如事父 &emsp;事诸兄 &emsp;如事兄</p><p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">谨</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">朝起早 &emsp;夜眠迟 &emsp;老易至 &emsp;惜此时</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">晨必盥 &emsp;兼漱口 &emsp;便溺回 &emsp;辄净手</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">冠必正 &emsp;纽必结 &emsp;袜与履 &emsp;俱紧切</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">置冠服 &emsp;有定位 &emsp;勿乱顿 &emsp;致污秽</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">衣贵洁 &emsp;不贵华 &emsp;上循分 &emsp;下称家</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">对饮食 &emsp;勿拣择 &emsp;食适可 &emsp;勿过则</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">年方少 &emsp;勿饮酒 &emsp;饮酒醉 &emsp;最为丑</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">步从容 &emsp;立端正 &emsp;揖深圆 &emsp;拜恭敬</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">勿践阈 &emsp;勿跛倚 &emsp;勿箕踞 &emsp;勿摇髀</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">缓揭帘 &emsp;勿有声 &emsp;宽转弯 &emsp;勿触棱</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">执虚器 &emsp;如执盈 &emsp;入虚室 &emsp;如有人</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事勿忙 &emsp;忙多错 &emsp;勿畏难 &emsp;勿轻略</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">斗闹场 &emsp;绝勿近 &emsp;邪僻事 &emsp;绝勿问</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">将入门 &emsp;问孰存 &emsp;将上堂 &emsp;声必扬</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">人问谁 &emsp;对以名 &emsp;吾与我 &emsp;不分明</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">用人物 &emsp;须明求 &emsp;倘不问 &emsp;即为偷</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">借人物 &emsp;及时还 &emsp;后有急 &emsp;借不难</p><p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">信</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡出言 &emsp;信为先 &emsp;诈与妄 &emsp;奚可焉</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">话说多 &emsp;不如少 &emsp;惟其是 &emsp;勿佞巧</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">奸巧语 &emsp;秽污词 &emsp;市井气 &emsp;切戒之</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">见未真 &emsp;勿轻言 &emsp;知未的 &emsp;勿轻传</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事非宜 &emsp;勿轻诺 &emsp;苟轻诺 &emsp;进退错</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡道字 &emsp;重且舒 &emsp;勿急疾 &emsp;勿模糊</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">彼说长 &emsp;此说短 &emsp;不关己 &emsp;莫闲管</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">见人善 &emsp;即思齐 &emsp;纵去远 &emsp;以渐跻</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">见人恶 &emsp;即内省 &emsp;有则改 &emsp;无加警</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">唯德学 &emsp;唯才艺 &emsp;不如人 &emsp;当自砺</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">若衣服 &emsp;若饮食 &emsp;不如人 &emsp;勿生戚</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">闻过怒 &emsp;闻誉乐 &emsp;损友来 &emsp;益友却</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">闻誉恐 &emsp;闻过欣 &emsp;直谅士 &emsp;渐相亲</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">无心非 &emsp;名为错 &emsp;有心非 &emsp;名为恶</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">过能改 &emsp;归于无 &emsp;倘掩饰 &emsp;增一辜</p><p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">泛爱众</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡是人 &emsp;皆须爱 &emsp;天同覆 &emsp;地同载</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">行高者 &emsp;名自高 &emsp;人所重 &emsp;非貌高</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">才大者 &emsp;望自大 &emsp;人所服 &emsp;非言大</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">己有能 &emsp;勿自私 &emsp;人所能 &emsp;勿轻訾</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">勿谄富 &emsp;勿骄贫 &emsp;勿厌故 &emsp;勿喜新</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">人不闲 &emsp;勿事搅 &emsp;人不安 &emsp;勿话扰</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">人有短 &emsp;切莫揭 &emsp;人有私 &emsp;切莫说</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">道人善 &emsp;即是善 &emsp;人知之 &emsp;愈思勉</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">扬人恶 &emsp;即是恶 &emsp;疾之甚 &emsp;祸且作</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">善相劝 &emsp;德皆建 &emsp;过不规 &emsp;道两亏</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">凡取与 &emsp;贵分晓 &emsp;与宜多 &emsp;取宜少</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">将加人 &emsp;先问己 &emsp;己不欲 &emsp;即速已</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">恩欲报 &emsp;怨欲忘 &emsp;报怨短 &emsp;报恩长</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">待婢仆 &emsp;身贵端 &emsp;虽贵端 &emsp;慈而宽</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">势服人 &emsp;心不然 &emsp;理服人 &emsp;方无言</p><p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">亲仁</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">同是人 &emsp;类不齐 &emsp;流俗众 &emsp;仁者希</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">果仁者 &emsp;人多畏 &emsp;言不讳 &emsp;色不媚</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">能亲仁 &emsp;无限好 &emsp;德日进 &emsp;过日少</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">不亲仁 &emsp;无限害 &emsp;小人进 &emsp;百事坏</p><p style="text-align: center;font-size: 16px;font-weight: bold; margin-bottom: 0;">余力学文</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">不力行 &emsp;但学文 &emsp;长浮华 &emsp;成何人</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">但力行 &emsp;不学文 &emsp;任己见 &emsp;昧理真</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">读书法 &emsp;有三到 &emsp;心眼口 &emsp;信皆要</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">方读此 &emsp;勿慕彼 &emsp;此未终 &emsp;彼勿起</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">宽为限 &emsp;紧用功 &emsp;工夫到 &emsp;滞塞通</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">心有疑 &emsp;随札记 &emsp;就人问 &emsp;求确义</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">房室清 &emsp;墙壁净 &emsp;几案洁 &emsp;笔砚正</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">墨磨偏 &emsp;心不端 &emsp;字不敬 &emsp;心先病</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">列典籍 &emsp;有定处 &emsp;读看毕 &emsp;还原处</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">虽有急 &emsp;卷束齐 &emsp;有缺坏 &emsp;就补之</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">非圣书 &emsp;屏勿视 &emsp;蔽聪明 &emsp;坏心志</p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">勿自暴 &emsp;勿自弃 &emsp;圣与贤 &emsp;可驯致</p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>引用类型（三）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><br>    当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必须的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。<br></p><p><br>    Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = new Object(&quot;some text&quot;);</div><div class="line">alert(obj instanceof String);   // true</div></pre></td></tr></table></figure><p><br>    把字符串传给Object构造函数，就会创建String的实例；而传入数值参数会得到Number的实例，传入布尔值参数就会得到Boolean的实例。<br></p><p><br>    要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var value = &quot;25&quot;;</div><div class="line">var number = Number(value);    // 转型函数</div><div class="line">alert(typeof number);          // &quot;number&quot;</div><div class="line"></div><div class="line">var obj = new Number(value);   // 构造函数</div><div class="line">alert(typeof obj);             // &quot;object&quot;</div></pre></td></tr></table></figure><p><br>    在这个例子中，变量number中保存的是基本类型的值25，而变量obj中保存的是Number的实例。<br></p><p><br>    尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。<br></p><h3 id="1-5-1-Boolean类型"><a href="#1-5-1-Boolean类型" class="headerlink" title="1.5.1 Boolean类型"></a>1.5.1 Boolean类型</h3><p><br>    Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true或false。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var booleanObject = new Boolean(true);</div></pre></td></tr></table></figure><p><br>    Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false。可是，Boolean对象在ECMAScript中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是布尔表达式中使用Boolean对象，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var falseObject = new Object(false);</div><div class="line">var result = falseObject &amp;&amp; true;</div><div class="line">alert(result);    // true</div><div class="line"></div><div class="line">var falseValue = false;</div><div class="line">result = falseValue &amp;&amp; true;</div><div class="line">alert(result);    // false</div></pre></td></tr></table></figure><p><br>    在这个例子中，我们使用false值创建了一个Boolean对象。然后，将这个对象与基本类型值true构成了逻辑与表达式。在布尔运算中，false &amp;&amp; true等于false。可是，示例中的这行代码是对falseObject对象而不是对它的值(false)进行求值。前面讨论过，布尔表达式中的所有对象都会被转换为true，因此falseObject对象在布尔表达式中代表的是true。结果，true &amp;&amp; true当然就等于true了。<br></p><p><br>    基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(typeof falseObject);    // object</div><div class="line">alert(typeof falseValue);     // boolean</div><div class="line">alert(falseObject instanceof Boolean);    // true</div><div class="line">alert(falseValue instanceof Boolean);     // false</div></pre></td></tr></table></figure><p><br>    理解基本类型的布尔值与Boolean对象之间的区别非常重要——当然，建议是永远不要使用Boolean对象。<br></p><h3 id="1-5-2-Number类型"><a href="#1-5-2-Number类型" class="headerlink" title="1.5.2 Number类型"></a>1.5.2 Number类型</h3><p><br>    Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递相应的数值。下面是一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var numberObject = new Number(10);</div></pre></td></tr></table></figure><p><br>    与Boolean类型一样，Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。我们可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString());    // &quot;10&quot;</div><div class="line">alert(num.toString(2));   // &quot;1010&quot;</div><div class="line">alert(num.toString(8));   // &quot;12&quot;</div><div class="line">alert(num.toString(10));  // &quot;10&quot;</div><div class="line">alert(num.toString(16));  // &quot;a&quot;</div></pre></td></tr></table></figure><p><br>    除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toFixed(2));    // &quot;10.00&quot;</div></pre></td></tr></table></figure><p><br>    这里给toFixed()方法传入了数值2，意思是显示几位小数。于是，这个方法返回了“10.00”，即以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就舍入，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10.005;</div><div class="line">alert(num.toFixed(2));    // &quot;10.01&quot;</div></pre></td></tr></table></figure><p><br>    能够自动舍入的特性，使得toFixed()方法很适合处理货币值。但需要注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同。在给toFixed()传入0的情况下，IE8及之前版本不能正确舍入范围在{(-0.94, -0.5], [0.5, 0.94)}之间的值。对于这个范围内的值，IE会返回0，而不是-1或1；其他浏览器都能返回正确的值。IE9修复了这个问题。<br></p><blockquote><p>toFixed()方法可以表示带有0到20个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数。</p></blockquote><p><br>    另外可用于格式化数值的方法是toExponential()，该方法返回以指数表示法(也称e表示法)表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数。看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toExponential(1));    // &quot;1.0e+1&quot;</div></pre></td></tr></table></figure><p><br>    以上代码输出了“1.0e+1”;不过，这么小的数值一般不必使用e表示法。如果你想得到表示某个数值的最合适的格式，就应该使用toPrecision()方法，<br></p><p><br>    对于一个数值来说，toPrecision()方法可能会返回固定大小(fixed)格式，也可能返回指数(exponential)格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数(不包括指数部分)。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var num = 99;</div><div class="line">alert(num.toPrecision(1));    // &quot;1e+2&quot;</div><div class="line">alert(num.toPrecision(2));    // &quot;99&quot;</div><div class="line">alert(num.toPrecision(3));    // &quot;99.0&quot;</div></pre></td></tr></table></figure><p><br>    以上代码首先完成的任务是以一位数来表示99，结果是“1e+2”,即100.因为一位数无法准确地表示99，因此toPrecision()就将它向上舍入为100，这样就可以使用一位数来表示它。而接下来的用两位数表示99，当然还是“99”。最后，在想以三位数表示99时，toPrecision()方法返回“99.0”。实际上，toPrecision()会根据要处理的数值决定到底是调用toFixed()还是调用toExponential()。而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。<br></p><blockquote><p>toPrecision()方法可以表现1到21位小数。某些浏览器支持的范围更大，但这是典型实现的范围。</p></blockquote><p><br>    与Boolean对象类似，Number对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化Number类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var numberObject = new Number(10);</div><div class="line">var numberValue = 10;</div><div class="line">alert(typeof numberObject);    // &quot;object&quot;</div><div class="line">alert(typeof numberValue);     // &quot;object&quot;</div><div class="line">alert(numberObject instanceof Number);    // true</div><div class="line">alert(numberValue instanceof Number);     // false</div></pre></td></tr></table></figure><p><br>    在使用typeof操作符测试基本类型数值时，始终会返回“number”，而在测试Number对象时，则会返回“object”。类似地，Number对象时Number类型的实例，而基本类型的数值则不是。<br></p><h3 id="1-5-3-String类型"><a href="#1-5-3-String类型" class="headerlink" title="1.5.3 String类型"></a>1.5.3 String类型</h3><p><br>    String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var stringObject = new String(&quot;hello world&quot;);</div></pre></td></tr></table></figure><p><br>    String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocaleString()和toString()方法，都返回对象所表示的基本字符串值。<br></p><p><br>    String类型的每个实例都有一个length属性，表示字符串中包含多个字符。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.length);    // &quot;11&quot;</div></pre></td></tr></table></figure><p><br>    这个例子输出了字符串“hello world”中的字符数量，即“11”。应该注意的是，即使字符串中包含双字节字符(不是占一个字节的ASCII字符)，每个字符也仍然算一个字符。<br></p><p><br>    String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。<br></p><p>####1、字符方法</p><p><br>    两个用于访问字符串中特定字符的方法是：charAt()和chatCodeAt()。这两个方法都接收一个参数，即基于0的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符(ECMAScript中没有字符类型)。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charAt(1));    // &quot;e&quot;</div></pre></td></tr></table></figure><p><br>    字符串“hello world”位置1处的字符是“e”，因此调用charAt(1)就返回了“e”。如果你想得到的不是字符而是字符编码，那么就像下面这样使用charCodeAt()了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charCodeAt(1));    // 输出&quot;101&quot;</div></pre></td></tr></table></figure><p><br>    这个例子输出的是“101”，也就是小写字母“e”的字符编码。<br></p><p><br>    ECMAScript 5还定义了另一个访问个别字符的方法，在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue(1));    // &quot;e&quot;</div></pre></td></tr></table></figure><p><br>    使用方括号表示法访问个别字符的语法得到了IE8及Firefox、Safari、Chrome和Opera所有版本的支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值(尽管根本不是特殊的undefined值)。<br></p><h4 id="2、字符串操作方法"><a href="#2、字符串操作方法" class="headerlink" title="2、字符串操作方法"></a>2、字符串操作方法</h4><p><br>    下面介绍与操作字符串有关的几个方法。第一个就是concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。先来看一个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello &quot;;</div><div class="line">var result = stringValue.concat(&quot;world&quot;);</div><div class="line">alert(result);         // &quot;hello world&quot;</div><div class="line">alert(stringValue);    // &quot;hello&quot;</div></pre></td></tr></table></figure><p><br>    在这个例子中，通过stringValue调用concat()方法返回的结果是“hello world”——但stringValue的值则保持不变。实际上，concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。再看一个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello &quot;;</div><div class="line">var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);</div><div class="line"></div><div class="line">alert(result);        // &quot;hello world!&quot;</div><div class="line">alert(stringValue);   // &quot;hello&quot;</div></pre></td></tr></table></figure><p><br>    这个例子将“world”和“！”拼接到了“hello”的末尾。虽然concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符(+)。而且，使用加号操作符在大多数情况下都比使用concat()方法要简便易行(特别是在拼接多个字符串的情况下)。<br></p><p><br>    ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(3));        // &quot;lo world&quot;</div><div class="line">alert(stringValue.substring(3));    // &quot;lo world&quot;</div><div class="line">alert(stringValue.substr(3));       // &quot;lo world&quot;</div><div class="line">alert(stringValue.slice(3, 7));     // &quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, 7)); // &quot;lo w&quot;</div><div class="line">alert(stringValue.substr(3, 7));    // &quot;lo worl&quot;</div></pre></td></tr></table></figure><p><br>    这个例子比较了以相同方式调用slice()、substr()和substring()得到的结果，而且多数情况下的结果是相同的。在只指定一个参数3的情况下，这三个方法都返回“lo world”，因为“hello”中的第二个“1”处于位置3.而在指定两个参数3和7的情况下，slice()和substring()返回“lo w”(“world”中的“o”处于位置7，因此结果中不包含“o”)，但substr()返回“lo worl”，因为它的第二个参数指定的是要返回的字符个数.<br></p><p><br>    在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.下面来看例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(-3));    // &quot;rld&quot;</div><div class="line">alert(stringValue.substring(-3));    // &quot;hello world&quot;</div><div class="line">alert(stringValue.substr(-3));       // &quot;rld&quot;</div><div class="line">alert(stringValue.slice(3, -4));     // &quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, -4)); // &quot;hel&quot;</div><div class="line">alert(stringValue.substr(3, -4));    // &quot;&quot;(空字符串)</div></pre></td></tr></table></figure><p><br>    这个例子清晰地展示了上述三个方法之间的不同行为。在给slice()和substr()传递一个负值参数时，它们的行为相同。这是因为-3会被转换为8(字符串长度加参数11+(-3)=8),实际上相当于调用slice(8)和substr(8).但substring()方法则返回了全部字符串，因为它将-3转换成了0.<br></p><blockquote><p>IE的JavaScript实现在处理向substr()方法传递负值的情况时存在问题，它会返回原始的字符串。IE9修复了这个问题。</p></blockquote><p><br>    当第二个参数是负值时，这三个方法的行为各不相同。slice()方法会把第二个参数转换为7，这就相当于调用了slice(3, 7),因此返回“lo w”。substring()方法会把第二个参数转换为0，使调用变成了substring(3, 0),而由于这个方法将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了substring(0, 3).substr()也会将第二个参数转换为0，这也就意味着返回包含零个字符的字符串，也就是一个空字符串。<br></p><h4 id="3、字符串位置方法"><a href="#3、字符串位置方法" class="headerlink" title="3、字符串位置方法"></a>3、字符串位置方法</h4><p><br>    有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf().这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置(如果没有找到该字符串，则返回-1)。这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。还是来看一个例子吧。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;));        // 4</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));    // 7</div></pre></td></tr></table></figure><p><br>    子字符串“o”第一次出现的位置是4，即“hello”中的“o”；最后一次出现的位置是7，即“world”中的“o”。如果“o”在这个字符串中仅出现了一次，那么indexOf()和lastIndexOf()会返回相同的位置值。<br></p><p><br>    这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;, 6));        // 7</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6));    // 4</div></pre></td></tr></table></figure><p><br>    在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于indexOf()是从位置6(字母”w”)开始向后搜索，结果在位置7找到了“o”，因此它返回7.而lastIndexOf()是从位置6开始向前搜索。结果找到了“hello”中的“o”，因此它返回4.在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串，如下面的例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;</div><div class="line">var positions = new Array();</div><div class="line">var pos = stringValue.indexOf(&quot;e&quot;);</div><div class="line"></div><div class="line">while(pos &gt; -1) &#123;</div><div class="line">positions.push(pos);</div><div class="line">pos = stringValue.indexOf(&quot;e&quot;, pos + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(positions);    // &quot;3, 24, 32, 35, 52&quot;</div></pre></td></tr></table></figure><p><br>    这个例子通过不断增加indexOf()方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找到了“e”在字符串中的初始位置；而进入循环之后，则每次都给indexOf()传递上一次的位置加1.这样，就确保了每次新搜索都从上一次找到的子字符串的后面开始。每次搜索返回的位置依次被保存在数组positions中，以便将来使用。<br></p><h4 id="4-trim-方法"><a href="#4-trim-方法" class="headerlink" title="4.trim()方法"></a>4.trim()方法</h4><p><br>    ECMAScript 5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;   hello world    &quot;;</div><div class="line">var trimmedStringValue = stringValue.trim();</div><div class="line">alert(stringValue);           // &quot;    hello world   &quot;</div><div class="line">alert(trimmedStringValue);    // &quot;hello world&quot;</div></pre></td></tr></table></figure><p><br>    由于trim()返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。此外，Firefox 3.5+、Safari 5+和Chrome 8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。<br></p><h4 id="5、字符串大小写转换方法"><a href="#5、字符串大小写转换方法" class="headerlink" title="5、字符串大小写转换方法"></a>5、字符串大小写转换方法</h4><p><br>    接下来要介绍的是一组与大小写转换有关的方法。ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase().其中，toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语)会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.toLocaleUpperCase());    // &quot;HELLO WORLD&quot;</div><div class="line">alert(stringValue.toUpperCase());          // &quot;HELLO WORLD&quot;</div><div class="line">alert(stringValue.toLocaleLowerCase());    // &quot;hello world&quot;</div><div class="line">alert(stringValue.toLowerCase());          // &quot;hello world&quot;</div></pre></td></tr></table></figure><p><br>    以上代码调用的toLocaleUpperCase()和toUpperCase()都返回了“HELLO WORLD”，就像调用toLocaleLowerCase()和toLowerCase()都返回“hello world”一样。一般来说，在不知道自己的代码将在那种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。<br></p><h4 id="6、字符串的模式匹配方法"><a href="#6、字符串的模式匹配方法" class="headerlink" title="6、字符串的模式匹配方法"></a>6、字符串的模式匹配方法</h4><p><br>    String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pattern = /.at/;</div><div class="line"></div><div class="line">// 与pattern.exec(text)相同</div><div class="line">var matches = text.match(pattern);</div><div class="line">alert(matches.index);        // 0</div><div class="line">alert(matches[0]);           // &quot;cat&quot;</div><div class="line">alert(pattern.lastIndex);    // 0</div></pre></td></tr></table></figure><p><br>    本例中的match()方法返回了一个数组；如果是调用RegExp对象的exec()方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串。<br></p><p><br>    另一个用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中的第一个匹配项的索引；如果没有找到匹配项，则返回-1.而且，search()方法始终是从字符串的开头向后查找模式。看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pos = text.search(/at/);</div><div class="line">alert(pos);    // 1</div></pre></td></tr></table></figure><p><br>    这个例子中的search()方法返回1，即“at”在字符串中第一次出现的位置。<br></p><p><br>    为了简化替换子字符串的操作，ECMAScript提供了replace()方法。这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串(这个字符串不会被转换成正则表达式)，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局(g)标志，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var result = text.replace(&quot;at&quot;, &quot;ond&quot;);</div><div class="line">alert(result);    // &quot;cond, bat, sat, fat&quot;</div><div class="line"></div><div class="line">result = text.replace(/at/g, &quot;ond&quot;);</div><div class="line">alert(result);    // &quot;cond, bond, sond, fond&quot;</div></pre></td></tr></table></figure><p><br>    在这个例子中，首先传入replace()方法的是字符串“at”和替换用的字符串“ond”。替换的结果是把“cat”变成了“cond”，但字符串中的其他字符并没有受到影响。然后，通过将第一个参数修改为带有全局标志的正则表达式，就将全部“at”都替换成了“ond”。<br></p><p><br>    如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">字符序列       替换文本</div><div class="line">$$             $</div><div class="line">$&amp;             匹配整个模式的子字符串。与RegExp.lastMatch的值相同</div><div class="line">$&apos;             匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</div><div class="line">$`             匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</div><div class="line">$n             匹配第n个捕获组的子字符串，其中n等于0-9.例如，$1是匹配第一个捕获组的子字符串，$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</div><div class="line">$nn            匹配第nn个捕获组的子字符串，其中nn等于01-99.例如，$01是匹配第一个捕获组的子字符串，$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</div></pre></td></tr></table></figure><p><br>    通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">result = text.replace(/(.at)/g, &quot;word ($1)&quot;);</div><div class="line">alert(result);    // word(cat), word(bat), word(sat), word(fat)</div></pre></td></tr></table></figure><p><br>    在此，每个以“at”结尾的单词都被替换了，替换结果是“word”后跟一对圆括号，而圆括号中是被字符序列$1所替换的单词。<br></p><p><br>    replace()方法的第二个参数也可以是一个函数。在只有一个匹配项(即与模式匹配的字符串)的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作，请看下面这个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function htmlEscape(text) &#123;</div><div class="line">    return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText) &#123;</div><div class="line">        switch(match) &#123;</div><div class="line">            case &quot;&lt;&quot;:</div><div class="line">                return &quot;&amp;lt;&quot;;</div><div class="line">            case &quot;&gt;&quot;:</div><div class="line">                return &quot;&amp;gt;&quot;;</div><div class="line">            case &quot;&amp;&quot;:</div><div class="line">                return &quot;&amp;amp;&quot;;</div><div class="line">            case &quot;\&quot;&quot;:</div><div class="line">                return &quot;&amp;quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(htmlEscape(&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;));</div><div class="line">// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</div></pre></td></tr></table></figure><p><br>    这里，我们为插入HTML代码定义了函数htmlEscape()，这个函数能够转义4个字符：小于号、大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定HTML实体的函数。<br></p><p><br>    最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方法不会将字符串看成正则表达式)。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。请看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colorText = &quot;red, blue, green, yellow&quot;;</div><div class="line">var colors1 = colorText.split(&quot;,&quot;);    // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</div><div class="line">var colors2 = colorText.split(&quot;,&quot;, 2); // [&quot;red&quot;, &quot;blue&quot;]</div><div class="line">var colors3 = colorText.split(/[^\,]+/);    // [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</div></pre></td></tr></table></figure><p><br>    在这个例子中，colorText是逗号分隔的颜色名字符串。基于该字符串调用split(“,”)会得到一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可以为split()方法传递第二个参数2.最后，通过使用正则表达式，还可以取得包含逗号字符的数组。需要注意的是，在最后一次调用split()返回的数组中，第一项和最后一项是两个空字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头(即子字符串“red”)和末尾(即子字符串“yellow”)。<br></p><p><br>    对split()中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1) IE8及之前版本会忽略捕获组。ECMAScript-262规定应该把捕获组拼接到结果数组中。IE9中能正确地在结果中捕获组。</div><div class="line">2) Firefox 3.6及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262规定没有匹配项的捕获组在结果数组中应该用undefined表示。</div></pre></td></tr></table></figure><p><br>    在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览器下多做一些测试。<br></p><h4 id="7-localeCompare-方法"><a href="#7-localeCompare-方法" class="headerlink" title="7.localeCompare()方法"></a>7.localeCompare()方法</h4><p><br>    与操作字符串有关的最后一个方法是localeCompare(),这个方法比较两个字符串，并返回下列值中的一个：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数(大多数情况下是-1，具体的值要视实现而定)；</div><div class="line">2) 如果字符串等于字符串参数，则返回0；</div><div class="line">3) 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是1，具体的值同样要视实现而定)。</div></pre></td></tr></table></figure><p><br>    下面是几个例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;yellow&quot;;</div><div class="line">alert(stringValue.localeCompare(&quot;brick&quot;));    // 1</div><div class="line">alert(stringValue.localeCompare(&quot;yellow&quot;));   // 0</div><div class="line">alert(stringValue.localeCompare(&quot;zoo&quot;));      // -1</div></pre></td></tr></table></figure><p><br>    这个例子比较了字符串“yellow”和另外几个值：“brick”、“yellow”和“zoo”。因为“brick”在字母表中排在“yellow”之前，所以localeCompare()返回1；而“yellow”等于“yellow”，所以localeCompare()返回了0；最后，“zoo”在字母表中排在“yellow”后面，所以localeCompare()返回了-1.再强调一次，因为localeCompare()返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function determineOrder(value) &#123;</div><div class="line">    var result = stringValue.localeCompare(value);</div><div class="line">    if (result &lt; 0) &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; comes before the string &apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125; else if (result &gt; 0) &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; comes after the string &apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; is equal to the string&apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line">determineOrder(&quot;brick&quot;);</div><div class="line">determineOrder(&quot;yellow&quot;);</div><div class="line">determineOrder(&quot;zoo&quot;);</div></pre></td></tr></table></figure><p><br>    使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。<br></p><h3 id="1-6-单体内置对象"><a href="#1-6-单体内置对象" class="headerlink" title="1.6 单体内置对象"></a>1.6 单体内置对象</h3><p><br>    ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array和String。ECMA-262还定义了两个单体内置对象：Global和Math。<br></p><h3 id="1-6-1-Global对象"><a href="#1-6-1-Global对象" class="headerlink" title="1.6.1 Global对象"></a>1.6.1 Global对象</h3><p><br>    Global(全局)对象可以说是ECMAScript中最特别的一个独享了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。像isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global对象还包含其他一些方法。<br></p><h4 id="1-URI编码方法"><a href="#1-URI编码方法" class="headerlink" title="1.URI编码方法"></a>1.URI编码方法</h4><p><br>    Global对象的encodeURI()和encodeURIComponent()方法可以对URI(Uniform Resource Identifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如，空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。<br></p><p><br>    其中，encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;</div><div class="line"></div><div class="line">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</div><div class="line">alert(encodeURI(uri));</div><div class="line"></div><div class="line">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</div><div class="line">alert(encodeURIComponent(uri));</div></pre></td></tr></table></figure><p><br>    使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20.而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正式可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。<br></p><blockquote><p>一般来说，我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。</p></blockquote><p><br>    与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。例如，它可将%20替换成一个空格，但不会对%23作任何处理，因为%23表示井字号(#)，而井字号不是使用encodeURI()替换的。同样地，decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。<br></p><h4 id="2-Global对象的属性"><a href="#2-Global对象的属性" class="headerlink" title="2.Global对象的属性"></a>2.Global对象的属性</h4><p><br>    特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下面列出了Global对象的所有属性。<br></p><p><img src="https://shaoqianheng.github.io/images/h-5-3.png"></p><p><br>    ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。<br></p><h4 id="4-window对象"><a href="#4-window对象" class="headerlink" title="4.window对象"></a>4.window对象</h4><p><br>    ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都称为了window对象的属性。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var color = &quot;red&quot;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">alert(window.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.sayColor();    // &quot;red&quot;</div></pre></td></tr></table></figure><p><br>    这里定义了一个名为color的全局变量和一个名为sayColor()的全局函数。在sayColor()内部，我们通过window.color来访问color变量，以说明全局变量是window对象的属性。然后，又使用window.sayColor()来直接通过window对象调用这个函数，结果显示在警告框中。<br></p><p><br>    另一种取得Global对象的方法是使用以下代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var global = function() &#123;</div><div class="line">    return this;</div><div class="line">&#125;();</div></pre></td></tr></table></figure><p><br>    以上代码创建了一个立即调用的函数表达式，返回this的值。。如前所述，在没有给函数明确指定this值的情况下(无论是通过将函数添加为对象的方法，还是通过调用call()或apply()),this值等于Global对象。而像这样通过简单地返回this来取得Global对象，在任何执行环境下都是可行的。<br></p><h3 id="1-6-2-Math对象"><a href="#1-6-2-Math对象" class="headerlink" title="1.6.2 Math对象"></a>1.6.2 Math对象</h3><p><br>    ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们在JavaScript直接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。Math对象中还提供了辅助完成这些计算的属性和方法。<br></p><h4 id="1-Math对象的属性"><a href="#1-Math对象的属性" class="headerlink" title="1.Math对象的属性"></a>1.Math对象的属性</h4><p><br>    Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。<br></p><p><img src="https://shaoqianheng.github.io/images/h-5-4.png"></p><h4 id="2-min-和max-方法"><a href="#2-min-和max-方法" class="headerlink" title="2.min()和max()方法"></a>2.min()和max()方法</h4><p><br>    Math对象还包含许多方法，用于辅助完成简单和复杂的数学计算。<br></p><p><br>    其中，min()和max()方法用于确定一组数值中的最大值和最小值。这两个方法都可以接收任意多个数值参数，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var max = Math.max(3, 54, 32, 16);</div><div class="line">alert(max);    // 54</div><div class="line"></div><div class="line">var min = Math.min(3, 54, 32, 16);</div><div class="line">alert(min);    // 3</div></pre></td></tr></table></figure><p><br>    对于3、54、32和16，Math.max()返回54，而Math.min()返回3.这两个方法经常用于避免多余的循环和在if语句中确定一组数的最大值。<br></p><p><br>    要找到数组中的最大或最小值，可以像下面这样使用apply()方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var values = [1, 2, 3, 4, 5, 6, 7, 8];</div><div class="line">var max = Math.max.apply(Math, values);</div></pre></td></tr></table></figure><p><br>    这个技巧的关键是把Math作为apply()的第一个参数，从而正确地设置this值。然后，可以将任何数组作为第二个参数。<br></p><h4 id="3-舍入方法"><a href="#3-舍入方法" class="headerlink" title="3. 舍入方法"></a>3. 舍入方法</h4><p><br>    下面介绍将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round().这三个方法分别遵循下列舍入规则：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</div><div class="line">2) Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</div><div class="line">3) Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</div></pre></td></tr></table></figure><h4 id="4-random-方法"><a href="#4-random-方法" class="headerlink" title="4. random()方法"></a>4. random()方法</h4><p><br>    Math.random()方法返回大于等于0小于1的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。<br></p><p><br>    值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)<br></p><p><br>    公式中用到了Math.floor()方法，这是因为Math.random()总返回一个小数值。而用这个小数值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个1到10之间的数值，可以像下面这样编写代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = Math.floor(Math.random() * 10 + 1);</div></pre></td></tr></table></figure><p><br>    总共有10个可能的值（1到10），而第一个可能的值是1.而如果想要选择一个介于2到10之间的值，就应该将上面的代码改成这样：<br></p><p><br>    var num = Math.floor(Math.random() * 9 + 2);<br></p><p><br>    从2数到10要数9个数，因此可能值的总数就是9，而第一个可能的值就是2.多数情况下，其实都可以通过一个函数来计算可能值的总数和第一个可能的值，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function selectFrom(lowerValue, upperValue) &#123;</div><div class="line">    var choices = upperValue - lowerValue + 1;</div><div class="line">    return Math.floor(Math.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var num = selectFrom(2, 10);</div><div class="line">alert(num);    // 介于2和10之间(包括2和10)的一个数值</div></pre></td></tr></table></figure><p><br>    函数selectFrom()接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加1得到了可能值的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用selectFrom(2, 10)就可以得到一个介于2和10之间(包括2和10)的数值了。利用这个函数，可以方便地从数组中随机取出一项。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];</div><div class="line">var color = colors[selectFrom(0, colors.length-1)];</div><div class="line">alert(color);    // 可能是数组中包含的任何一个字符串</div></pre></td></tr></table></figure><p><br>    在这个例子中，传递给selectFrom()的第二个参数是数组的长度减1，也就是数组中最后一项的位置。<br></p><h4 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5. 其他方法"></a>5. 其他方法</h4><p><br>    Math对象中还包含其他一些与完成各种简单或复杂计算有关的方法。下图，列出了这些没有介绍到的Math对象的方法。<br></p><p><img src="https://shaoqianheng.github.io/images/h-5-5.png"></p><p><br>    虽然ECMA-262规定了这些方法，但不同实现可能会对这些方法采用不同的算法。毕竟，计算某个值的正弦、余弦和正切的方式多种多样。也正是因为如此，这些方法在不同的实现中可能会有不同的精度。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浮动概述</title>
      <link href="/2018/06/27/%E6%B5%AE%E5%8A%A8%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/06/27/%E6%B5%AE%E5%8A%A8%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p><br>    最后一种定位模型是浮动模型。浮动的框可以左右移动，直到它的外边缘碰到包含框或另一个浮动框的边缘。因为浮动框不在文档的普通流中，<br></p><p><br>    如图1-13所示，当把框1向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘。<br></p><p><br>    在图1-14中，当把框1向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框2，使框2从视图中消失。如果把3个框都向左浮动，那么框1向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。<br></p><p><img src="https://shaoqianheng.github.io/images/1-13.png"></p><div style="text-align: center;">图1-13 向右浮动的元素</div><p><img src="https://shaoqianheng.github.io/images/1-14.png"></p><div style="text-align: center;">图1-14 向左浮动的元素</div><p><br>    如果包含块太窄，无法容纳水平排列的3个浮动元素，那么其他浮动块向下移动，直到有足够空间的地方（见图1-15）.如果浮动元素的高度不同，那么当它们向下移动时可能会被其他浮动元素“卡住”。<br></p><p><img src="https://shaoqianheng.github.io/images/1-15.png"></p><div style="text-align: center;">图1-15 如果没有足够的水平空间，浮动元素将向下移动，直到有足够空间的地方</div><h3 id="行框和清理"><a href="#行框和清理" class="headerlink" title="行框和清理"></a>行框和清理</h3><p><br>    前一节指出，浮动会让元素脱离文档流，不再影响不浮动的元素。实际上，并不完全如此。如果浮动的元素后面有一个文档流中的元素，那么这个元素的框会表现得像浮动根本不存在一样。但是，框的文本内容会受到浮动元素的影响，会移动以留出空间。用技术术语来说，浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。实际上，创建浮动框使文本可以围绕图像（1-16）.<br></p><p><img src="https://shaoqianheng.github.io/images/1-16.png"></p><div style="text-align: center;">图1-16 浮动框旁边的行框被缩短</div><p><br>    要想阻止行框围绕在浮动框的外边，需要对包含这些行框的元素应用clear属性。clear属性的值可以是left、right、both或none，它表示框的那些边不应该挨着浮动框。我以前总是认为clear属性会自动地抵消前面的浮动。但是，实际情况有意思很多。在清理元素时，浏览器在元素顶上添加足够的外边距，使元素的顶边缘垂直下降到浮动框下面（见图1-17）.<br></p><p><img src="https://shaoqianheng.github.io/images/1-17.png"></p><div style="text-align: center;">图1-17 清理元素的顶外边距，为前一个浮动框留出足够的垂直空间</div><p><br>    浮动元素脱离了文档流，不影响周围的元素。但是，对元素进行清理实际上为前面的浮动元素留出了垂直空间。<br></p><p><br>    这是一个有用的布局工具，它让周围的元素为浮动元素留出空间。这解决了前面你看到的绝对定位的问题——垂直高度的改变不影响周围的元素，从而破坏了设计。<br></p><p><br>    我们来更详细地看看浮动和清理。假设有一个图片，你希望让它浮动到一个文本块的左边。你想将这个图片和文本包含在另一个具有背景颜色和边框的元素中。你可能会编写下面这样的代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.news &#123;</div><div class="line">    background-color: gray;</div><div class="line">    border: solid 1px black;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news img &#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news p &#123;</div><div class="line">    float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;news&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p><br>    但是，因为浮动元素脱离了文档流，所以包围图片和文本的div不占据空间。如何让包围元素在视觉上包围浮动元素呢？需要在这个元素中的某个地方应用clear（见图1-18）.可惜这个示例中没有现有的元素可以清理，所以需要在最后一个段落下面添加一个空元素并且清理它。<br></p><p><img src="https://shaoqianheng.github.io/images/1-18.png"></p><div style="text-align: center;">图1-18 因为浮动元素不占据空间，所以容器元素不包围它们。添加一个进行清理的空元素可以迫使容器元素包围浮动元素</div><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">.news &#123;</div><div class="line">    background-color: gray;</div><div class="line">    border: solid 1px black;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news img &#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news p &#123;</div><div class="line">    float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.clear &#123;</div><div class="line">    clear: both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;news&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">    &lt;br class=&quot;clear&quot; /&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p><br>    这会实现我们希望的效果，但是要添加不必要的代码。常常有现成的元素可以应用clear，但是有时候不得不忍受巨大通过布局添加无意义的标记。<br></p><p><br>    还可以不对浮动的文本和图像进行清理，而是选择浮动容器div：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">.news &#123;</div><div class="line">    background-color: gray;</div><div class="line">    border: solid 1px black;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news img &#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news p &#123;</div><div class="line">    float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;news&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p><br>    这也会产生我们想要的结果。但是，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择浮动布局中的几乎所有东西，然后使用合适的元素（常常是站点的页脚）对这些浮动元素进行清理。这有助于减少或消除不必要的标记。但是，浮动会变得复杂，而且一些老式浏览器在处理有许多浮动元素的布局时有困难。因此，许多人喜欢添加少量的额外标记。<br></p><p><br>    overflow属性定义在包含的内容对于指定的尺寸太大的情况下元素应该怎么样。在默认情况下，内容会溢出到框外，进入相邻的空间。应用值为hidden或auto的overflow属性有一个有用的副作用，这会自动地清理包含的任何浮动元素。因此这是一种有用的元素清理方法，不需要添加额外的标记。这个方法并不适合所有情况，因为设置框的overflow属性会影响它的表现。更具体地说，这种方法在某些情况下会产生滚动条或截断内容。<br></p><p><br>    然后，一些人使用CSS生成的内容或JavaScript对浮动元素进行清理。这两种方法的基本概念是相同的，并不直接向标记中添加进行清理的元素，而是将它动态添加到页面中。对于这两种方法，需要指定进行清理的元素应该出现在哪里，而且常常需要添加一个类名：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;news clear&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p><br>    在使用CSS方法时，结合使用:after伪类和内容声明在指定的现有内容的末尾添加新的内容。在这个示例中，我添加了一个点，因为它是个非常小的不引人注意的字符。因为不希望新内容占据垂直空间或者在页面上显示，所以需要将height设置为0，将visibility设置为hidden。因为被清理的元素在它们的顶外边距上添加了空间，所以生成的内容需要将它的display属性设置为block。这样设置之后，就可以对生成的内容进行清理：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.clear:after &#123;</div><div class="line">    content: &quot;.&quot;;</div><div class="line">    height: 0;</div><div class="line">    visibility: hidden;</div><div class="line">    display: block;</div><div class="line">    clear: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Window对象(一)</title>
      <link href="/2018/06/27/window%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/06/27/window%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h3 id="1-1-计时器"><a href="#1-1-计时器" class="headerlink" title="1.1 计时器"></a>1.1 计时器</h3><p><br>    setTimeout()和setInterval()可以用来注册在指定的时间之后单次或重复调用的函数。它们都是客户端JavaScript中重要的全局函数，所以定义为Window对象的方法，但作为通用函数，其实不会对窗口做什么事情。<br></p><p><br>    Window对象的setTimeout()方法用来实现一个函数在指定的毫秒数之后运行。setTimeout()返回一个值，这个值可以传递给clearTimeout()用于取消这个函数的执行。<br></p><p><br>    setInterval()和setTimeout()一样，只不过这个函数会在指定毫秒数的间隔里重复调用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setInterval(updateClock, 60000);// 每60秒调用一次updateClock()</div></pre></td></tr></table></figure><p><br>    和setTimeout()一样，setInterval()也返回一个值，这个值可以传递给clearInterval()，用于取消后续函数的调用。<br></p><p><br>    例1-1定义的应用函数会在等待指定的时间之后，开始重复调用某个函数，然后又过了一段时间之后取消函数调用。该例子演示了setTimeout()、setInterval()和clearInterval()的用法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">例1-1：定时器应用函数</div><div class="line">/*</div><div class="line">  安排函数f()在未来的调用模式在等待了若干毫秒</div><div class="line">  之后调用f()，如果设置了interval并没有设置end</div><div class="line">  参数，则对f()调用将不会停止，如果没有设置interval</div><div class="line">  和end，只在若干毫秒后调用f()一次，只有指定了</div><div class="line">  f(),才会从start=0的时刻开始。注意，调用invoke()</div><div class="line">  不会阻塞，它会立即返回。</div><div class="line">*/</div><div class="line">function invoke(f, start, interval, end) &#123;</div><div class="line">    if (!start) start = 0;// 默认设置为0毫秒</div><div class="line">    if (arguments.length &lt;= 2)// 单次调用模式</div><div class="line">        setTimeout(f, start);// 若干毫秒后的单次调用模式</div><div class="line">    else &#123;// 多次调用模式</div><div class="line">        setTimeout(repeat, start);// 在若干毫秒后调用repeat()</div><div class="line">        function repeat () &#123;// 在上一行所示的setTimeout()中调用</div><div class="line">            var h = setInterval(f, interval);// 循环调用f()</div><div class="line">            // 在end毫秒后停止调用，前提是end已经定义了</div><div class="line">            if (end) setTimeout(function () &#123; clearInterval(h); &#125;, end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    由于历史原因，setTimeout()和setInterval()的第一个参数可以作为字符串传入。如果这么做，那这个字符串会在指定的超时时间或间隔时间之后进行求值(相当于执行eval())，除前两个参数之外，HTML5规范(除IE之外的所有浏览器)还允许setTimeout()和setInterval()传入额外的参数，并在调用函数时把这些参数传递过去，然而，如果需要支持IE的话，就不要应用此特性了。<br></p><p><br>    如果以0毫秒的超时时间来调用setTimeout(),那么指定的函数不会立刻执行。相反，会把它放到队列中，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。<br></p><h3 id="1-2-浏览器定位和导航"><a href="#1-2-浏览器定位和导航" class="headerlink" title="1.2 浏览器定位和导航"></a>1.2 浏览器定位和导航</h3><p><br>    Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL，并定义了方法来使窗口载入新的文档。<br></p><p><br>    Document对象的location属性也引用到Location对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.location === document.location // 总是返回true</div></pre></td></tr></table></figure><p><br>    Document对象也有一个URL属性，是文档首次载入后保存该文档的URL的静态字符串。如果定位到文档中的片段标识符(如#table-of-contents),Location对象会做相应的更新，而document.URL属性却不会改变。<br></p><h3 id="1-2-1-解析URL"><a href="#1-2-1-解析URL" class="headerlink" title="1.2.1 解析URL"></a>1.2.1 解析URL</h3><p><br>    Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL。Location对象的href属性是一个字符串，后者包含URL的完整文本。Location对象的toString()方法返回href属性的值，因此在会隐式调用toString()的情况下，可以使用location代替location.href.<br></p><p><br>    这个对象的其他属性——protocol，host，hostname，port，pathname和search，分别表示URL的各个部分。它们称为“URL分解”属性，同时被Link对象(通过HTML文档中的<a>和<area>元素创建)支持。<br></a></p><p><br>    Location对象的hash和search属性比较有趣。如果有的话，hash属性返回URL中的“片段标识符”部分。search属性也类似，它返回的是问好之后的URL，这部分通常是某种类型的查询字符串。一般来说，这部分内容是用来参数化URL并在其中嵌入参数的。虽然这些参数通常用于运行在服务器上的脚本，但在启用JavaScript的页面中当然也可以使用它们。例1-2展示了一个通用函数urlArgs()的定义，可以用这个函数将参数从URL的search属性中提取出来。该例子用到了decodeURIComponent(),后者是在客户端JavaScript定义的全局函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">例1-2：提取URL的搜索字符串中的参数</div><div class="line">/*</div><div class="line">  这个函数用来解析来自URL的查询串中的name=value参数对</div><div class="line">  它将name=value对存储在一个对象的属性中，并返回该对象</div><div class="line">  这样来使用它</div><div class="line"></div><div class="line">  var args = urlArgs();// 从URL中解析参数</div><div class="line">  var q = args.q || &quot;&quot;;// 如果参数定义了的话就使用参数；否则使用一个默认值</div><div class="line">  var n = args.n ? parseInt(args.n) : 10;</div><div class="line">*/</div><div class="line">function urlArgs () &#123;</div><div class="line">    var args = &#123;&#125;;// 定义一个空对象</div><div class="line">    var query = location.search.substring(1);// 查找到查询串，并去掉&apos;?&apos;</div><div class="line">    var pairs = query.split(&apos;&amp;&apos;);// 根据“&amp;”符号将查询字符串分隔开</div><div class="line">    for (var i = 0; i &lt; pairs.length; i++) &#123;// 对于每个片段</div><div class="line">        var pos = pairs[i].indexOf(&apos;=&apos;);// 查找“name=value”</div><div class="line">        if (pos === -1) continue;// 如果没有找到的话，就跳过</div><div class="line">        var name = pairs[i].substring(0, pos);// 提取name</div><div class="line">        var value = pairs[i].substring(pos + 1);// 提取value</div><div class="line">        value = decodeURIComponent(value);// 对value进行解码</div><div class="line">        args[name] = value;// 存储为属性</div><div class="line">    &#125;</div><div class="line">    return args;// 返回解析后的参数</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2-2-载入新的文档"><a href="#1-2-2-载入新的文档" class="headerlink" title="1.2.2 载入新的文档"></a>1.2.2 载入新的文档</h3><p><br>    Location对象的assign()方法可以使窗口载入并显示你指定的URL中的文档。replace()方法也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。如果脚本无条件地载入一个新文档，replace()方法可能是比assign()方法更好的选择。否则，“后退”按钮会把浏览器带回到原始文档，而相同的脚本则会再次载入新文档。如果检测到用户的浏览器不支持某些特性来显示功能齐全的版本，可以用location.replace()来载入动态的HTML版本。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 如果浏览器不支持XMLHttpRequest对象</div><div class="line">// 则将其重定向到一个不需要Ajax的静态页面</div><div class="line">if (!XMLHttpRequest) location.replace(&apos;staticpage.html&apos;);</div></pre></td></tr></table></figure><p><br>    注意，在这个例子中传入replace()的是一个相对URL。相对URL是相对于当前页面所在的目录来解析的，就像它们用于一个超链接中。<br></p><p><br>    除了assign()和replace()方法，location对象还定义了reload()方法，后者可以让浏览器重新载入当前文档。<br></p><p><br>    使浏览器跳转到新页面的一种更传统的方法是直接把新的URL赋给location属性：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = &quot;http://www.oreilly.com&quot;;</div></pre></td></tr></table></figure><p><br>    还可以把相对URL赋给location，它们会相对当前URL进行解析：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = &quot;page2.html&quot;;// 载入下一个页面</div></pre></td></tr></table></figure><p><br>    纯粹的片段标识符是相对URL的一种类型，它不会让浏览器载入新文档，但只会使它滚动到文档的某个位置。#top标识符是个特殊的例子：如果文档中没有元素的ID是“top”，它会让浏览器跳到文档开始处。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = “#top”;// 跳转到文档的顶部</div></pre></td></tr></table></figure><p><br>    Location对象的URL分解属性是可写的，对它们重新赋值会改变URL的位置，并且导致浏览器载入一个新的文档(如果改变的是hash属性，则在当前文档中进行跳转)：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.search = &quot;?page=&quot; + (pagenum + 1);// 载入下一个页面</div></pre></td></tr></table></figure><h3 id="1-3-浏览历史"><a href="#1-3-浏览历史" class="headerlink" title="1.3 浏览历史"></a>1.3 浏览历史</h3><p><br>    Window对象的history属性引用的是该窗口的History对象。History对象是用来把窗口的浏览历史用文档和文档状态列表的形式表示。History对象的length属性表示浏览历史列表中的元素数量，但出于安全的因素，脚本不能访问已保存的URL。(如果允许，则任意脚本都可以窥探你的浏览历史.)<br></p><p><br>    History对象的back()和forward()方法与浏览器的“后退”和“前进”按钮一样：它们使浏览器在浏览历史中前后跳转一格。第三个方法——go()接受一个整数参数，可以在历史列表中向前(正参数)或向后(负参数)跳过任意多个页。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.go(-2);// 后退两个历史记录，相当于单击“后退”按钮两次</div></pre></td></tr></table></figure><p><br>    如果窗口包含多个子窗口(比如iframe元素)，子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用history.back()(举例)可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。<br></p><p><br>    现代Web应用可以不通过载入新文档而动态地改变自身内容。这么做可能希望用户能用“后退”和“前进”按钮在这些动态创建的应用状态之间进行跳转。HTML5将这种技术标准化。<br></p><p><br>    HTML5之前的历史管理是个更复杂的难题。应用程序必须要在窗口浏览历史中创建一个新的条目来管理自身的历史记录，用历史条目关联自身的状态信息，判断什么时候用户使用了“后退”按钮来移动到不同的历史条目，联合那个条目获取状态信息，并且重新创建应用程序之前的状态。一种方式是用隐藏的iframe来保存状态信息并在浏览器的历史中创建条目。为了创建新的历史条目，需要用Document对象的open()和write()方法动态地把一个新文档写入这个隐藏的窗体。不管怎样，文档内容应该包含重新创建应用状态所需要的状态信息。当用户点击“后退”按钮，隐藏的窗体的内容会改变。在HTML5之前，没有生成事件来通知你这个改变，因此，为了检测用户是否单击了“后退”按钮，可能要用setInterval()每秒对隐藏的窗体检测两到三次，来看它是否改变了。<br></p><h3 id="用HTML5进行历史管理"><a href="#用HTML5进行历史管理" class="headerlink" title="用HTML5进行历史管理"></a>用HTML5进行历史管理</h3><p><br>    Web浏览器会记录一个窗口中载入的所有文档，同时提供了“后退”和“前进”按钮，允许用户在这些文档之间切换浏览。这种浏览器历史记录模型最早在“文档都是被动的，所有的计算都在服务器上完成”那个时期就已经存在了。如今，Web应用通常都是动态地生成或载入页面内容，并在无须刷新页面的情况下就显示新的应用状态。如果想要提供用户能够通过浏览器的“后退”和“前进”按钮，直观的切换应用状态，像这类应用就必须自己处理应用的历史记录管理。HTML5定义了两种用于历史记录管理的机制。<br></p><p><br>    其中比较简单的历史记录管理技术就是利用location.hash和hashchange事件。截至撰写本书时，这种技术一直也是比较广泛实现的：浏览器甚至在HTML5标准化之前就已经开始实现该技术了。在绝大多数浏览器中(IE早期版本除外)，设置location.hash属性会更新显示在地址栏中的URL，同时会在浏览器的历史记录中添加一条记录。hash属性设置URL的片段标识符，通常用于指定要滚动到的文档中某一部分的ID。但是location.hash不一定非要设置为一个元素的ID：它可以设置成任何的字符串。如果能够将应用状态编码成一个字符串，就可以使用该字符串作为片段标识符。<br></p><p><br>    设置了location.hash属性后，接下来要实现允许用户通过“后退”和“前进”按钮来切换不同的文档状态。这个时候，应用必须要想办法检测状态变化，以便它能够读取出存储在片段标识符中的状态并相应地更新自己的状态。支持HTML5的浏览器一旦发现片段标识符发生了改变，就会在Window对象上触发一个hashchange事件。这样，在支持hashchange事件的浏览器中，就可以通过设置window.onhashchange为一个处理程序函数，使得每次由于切换历史记录导致片段标识符变化的时候，都会调用该处理程序函数。当调用该处理程序函数的时候，就可以对location.hash的值进行解析，然后使用该值包含的状态信息来重新显示应用。<br></p><p><br>    HTML5还定义了一个相对更复杂和强健的历史记录管理方法，该方法包含history。pushState()方法和popstate事件。当一个Web应用进入一个新的状态的时候，它会调用history.pushState()方法将该状态添加到浏览器的浏览历史记录中。该方法的第一个参数是一个对象，该对象包含用于恢复当前文档状态所需的所有信息。该对象可以是任何能够通过JSON.stringify()方法转换成相应字符串形式的对象，也可以是其他类似Date和RegExp这样特定的本地类型。该方法的第二个可选参数是一个可选的标题(普通的文本字符串)，浏览器可以使用它(比如，在一个<back>菜单中)来标识浏览历史记录中保存的状态。该方法的第三个参数是一个可选的URL，表示当前状态的位置。相对的URL都是以文档的当前位置为参照，通常该URL只是简单地指定URL(诸如#state)这样的hash(或者“片段标识符”)部分。将一个URL和状态关联，可以允许用户将应用的内部状态作为书签添加到浏览器中，并当URL中包含足够信息的时候，应用可以在从书签中载入的时候就恢复它的状态。<br></back></p><p><br>    除了pushState()方法之外，History对象还定义了replaceState()方法，该方法和pushState()方法接收同样的参数，但是不同的是，它不是将新的状态添加到浏览器的历史记录中，而是用新的状态代替当前的历史状态。<br></p><p><br>    当用户通过“后退”和“前进”按钮浏览保存的历史状态时，浏览器会在Window对象上触发一个popstate事件。与该事件相关联的事件对象有一个state属性，该属性包含传递给pushState()方法的状态对象的副本(另一种结构性复制)。<br></p><blockquote><p>结构性复制：正如上面提到的，pushState()方法接受一个状态对象并为该对象创建一份私有副本。这是对一个对象进行深拷贝或者深复制：它会递归地复制所有嵌套对象或者数组的内容。HTML5标准将这类复制称为“结构性复制”(structured clone)。创建一个结构性复制的过程就好比是将一个对象传递给JSON.stringify()方法，然后再将结果字符串传递给JSON.parse()方法。但是JSON只支持JavaScript的基础类型和对象以及数组。在HTML5标准中提到，结构性复制算法必须还能够复制Date对象、RegExp对象、ImageData对象、FileList对象、File对象以及Blob对象。但是在结构性复制算法中会显式排除JavaScript中的函数和错误以及绝大部分诸如窗口、文档、元素等这类宿主对象。</p></blockquote><h3 id="1-4-浏览器和屏幕信息"><a href="#1-4-浏览器和屏幕信息" class="headerlink" title="1.4 浏览器和屏幕信息"></a>1.4 浏览器和屏幕信息</h3><blockquote><p>脚本有时候需要获取和它们所在的Web浏览器或浏览器所在的桌面相关信息。将要介绍Window对象的navigator和screen属性。它们分别引用的是Navigator和Screen对象，而这些对象提供的信息允许脚本来根据环境定制自己的行为。</p></blockquote><h3 id="1-4-1-Navigator对象"><a href="#1-4-1-Navigator对象" class="headerlink" title="1.4.1 Navigator对象"></a>1.4.1 Navigator对象</h3><p><br>    Window对象的navigator属性引用的是包含浏览器厂商和版本信息的Navigator对象。Navigator对象的命名是为了纪念Netscape之后Navigator浏览器，不过所有其他的浏览器也支持它(IE还支持clientInformation属性，它作为navigator的厂商中立同义词。遗憾的是，其他浏览器并不支持这一更直观的属性命名)。<br></p><p><br>    过去，Navigator对象通常被脚本用来确定它们是在IE中还是在Netscape中运行。这种浏览器嗅探方法有问题，因为它要求随着新浏览器和现有浏览器的新版本的引入而不断地调整。如今，有一种更好的功能测试方法，只需要测试所需要的功能(即，方法或属性)，而不是假设特定的浏览器版本及其功能。<br></p><p><br>    然而，浏览器嗅探有时候仍然有价值。这样的一种情况是，当需要解决存在于某个特定的浏览器的特定版本中的特殊的bug时。Navigator对象有4个属性用于提供关于运行中的浏览器的版本信息，并且可以使用这些属性进行浏览器嗅探。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">appName</div><div class="line">    Web浏览器的全称。在IE中，这就是“Microsoft Internet Explorer”。在Firefox中，该属性就是“Netscape”。为了兼容现存的浏览器的嗅探代码，其他浏览器通常也取值为“Netscape”。</div><div class="line"></div><div class="line">appVersion</div><div class="line">    此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是4.0或5.0，表示它是第4或第5代兼容的浏览器。appVersion字符串没有标准的格式，所以，没有办法直接用它来判断浏览器的类型。</div><div class="line"></div><div class="line">userAgent</div><div class="line">    浏览器在它的USER-AGENT HTTP头部中发送的字符串。这个属性通常包含appVersion中的所有信息，并且常常也可能包含其他的细节。和appVersion一样，它也没有标准的格式。由于这个属性包含绝大部分信息，因此浏览器嗅探代码通常用它来嗅探。</div><div class="line"></div><div class="line">platform</div><div class="line">    在其上运行浏览器的操作系统(并且可能是硬件)的字符串。</div></pre></td></tr></table></figure><p><br>    Navigator属性的复杂性正说明了浏览器嗅探对于处理客户端兼容性问题是没有太大帮助的。在Web的早期，人们写了大量的浏览器特定代码用于测试类似于navigator.appName的属性。在开发新浏览器的时候，浏览器厂商发现为了让现有网站显示正确，它们需要把appName设置为“Netscape”。类似的做法使得appVersion的起始数字失去了意义，而现在的浏览器嗅探代码必须要依赖于比之前复杂很多的navigator.userAgent字符串。例1-3展示了如何使用正则表达式(摘自jQuery)从navigator.userAgent中抽取浏览器名称和版本号的方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">例1-3：使用navigator.userAgent来进行浏览器嗅探</div><div class="line">// 为客户端嗅探定义browser.name和browser.version,这里使用了jQuery1.4.1中的代码</div><div class="line">// name和number都是字符串，对于不同的浏览器输出的结果也是不一样的，检测结果如下：</div><div class="line">//</div><div class="line">// &quot;webkit&quot;：Safari或Chrome;版本号是Webkit的版本号</div><div class="line">// &quot;opera&quot;：Opera;版本号就是软件的版本号</div><div class="line">// &quot;mozilla&quot;：Firefox或者其他基于gecko内核的浏览器;版本号是Gecko的版本</div><div class="line">// &quot;msie&quot;：IE;版本号就是软件的版本</div><div class="line">//</div><div class="line">// 比如Firefox 3.6返回：&#123; name：“mozilla”，version：“1.9.2” &#125;</div><div class="line">var browser = (function() &#123;</div><div class="line">    var s = navigator.userAgent.toLowerCase();</div><div class="line">    var match = /(webkit)[\/]([\w.]+)/.exec(s) ||</div><div class="line">    /(opera)(?:.*version)?[\/]([\w.]+)/.exec(s) ||</div><div class="line">    /(mise)([\w.]+)/.exec(s) ||</div><div class="line">    !/compatible/.test(s) &amp;&amp; /(mozilla)(?:.*? rv:([\w.]+))?/.exec(s) ||</div><div class="line">    [];</div><div class="line"></div><div class="line">    return &#123; name: match[1] || &quot;&quot;, version: match[2] || &quot;0&quot; &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p><br>    除了浏览器厂商和版本信息的属性之外，Navigator对象还包含一些杂项的属性和方法。以下是一些标准化的属性以及广泛应用但未标准化的属性：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">onLine</div><div class="line">    navigator.onLine属性(如果存在的话)表示浏览器当前是否连接到网络。应用程序可能希望在离线状态下把状态保存在本地。</div><div class="line"></div><div class="line">geolocation</div><div class="line">    Geolocation对象定义用于确定用户地理位置信息的接口。</div><div class="line"></div><div class="line">javaEnabled()</div><div class="line">    一个非标准的方法，当浏览器可以运行Java小程序时返回true。</div><div class="line">    </div><div class="line">cookieEnable()</div><div class="line">    非标准的方法，如果浏览器可以保存永久的cookie时，返回true。当cookie配置为“视具体情况而定”时可能会返回不正确的值。</div></pre></td></tr></table></figure><h3 id="1-4-2-Screen对象"><a href="#1-4-2-Screen对象" class="headerlink" title="1.4.2 Screen对象"></a>1.4.2 Screen对象</h3><p><br>    Window对象的screen属性引用的是Screen对象。它提供有关窗口显示的大小和可用的颜色数量的信息。属性width和height指定的是以像素为单位的窗口大小。属性availWidth和availHeight指定的实际可用的显示大小，它们排除了像桌面任务栏这样的特性所占用的空间。属性colorDepth指定的是显示BPP(bits-per-pixel)值,典型的值有16、24和32.<br></p><p><br>    window.screen属性和它引用的Screen对象都是非标准但广泛实现的。可以用Screen对象来确定Web应用是否运行在一个小屏幕的设备上，比如上网本。如果屏幕空间有限，可能要选择用更小的字体和图片等。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组(三)</title>
      <link href="/2018/06/27/%E6%95%B0%E7%BB%84%EF%BC%883%EF%BC%89/"/>
      <url>/2018/06/27/%E6%95%B0%E7%BB%84%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-10-数组类型"><a href="#1-10-数组类型" class="headerlink" title="1.10 数组类型"></a>1.10 数组类型</h3><p><br>    给定一个未知的对象，判定它是否为数组通常非常有用。在ECMAScript 5中，可以使用Array.isArray()函数来做这件事情：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Array.isArray([])// =&gt; true</div><div class="line">Array.isArray(&#123;&#125;)// =&gt; false</div></pre></td></tr></table></figure><p><br>    但是，在ECMAScript 5之前，要区分数组和非数组对象却令人惊讶地困难。typeof操作符在这里帮不上忙：对数组它返回“对象”(并且对于除了函数以外的所有对象都是如此)。instanceof操作符只能用于简单的情形：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[] instanceof Array // =&gt; true</div><div class="line">(&#123;&#125;) instanceof Array // =&gt; false</div></pre></td></tr></table></figure><p><br>    使用instanceof的问题是在Web浏览器中有可能有多个窗口或窗体(frame)存在。每个窗口都有自己的JavaScript环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明instanceof操作符不能视为一个可靠的数组检测方法。<br></p><p><br>    解决方案是检查对象的类属性。对数组而言该属性的值总是“Array”，因此在ECMAScript 3中isArray()函数的代码可以这样书写：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var isArray = Function.isArray || function(o) &#123;</div><div class="line">    return typeof o === &quot;object&quot; &amp;&amp;</div><div class="line">    Object.prototype.toString.call(o) === &quot;[object Array]&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><br>    实际上，此处类属性的检测就是ECMAScript 5中的Array.isArray()函数所做的事情。获得对象类属性的技术使用了Object.prototype.toString()方法。<br></p><h3 id="1-11-类数组对象"><a href="#1-11-类数组对象" class="headerlink" title="1.11 类数组对象"></a>1.11 类数组对象</h3><p><br>    我们已经看到，JavaScript数组的有一些特性是其他对象所没有的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) 当有新的元素添加到列表中时，自动更新length属性。</div><div class="line">b) 设置length为一个较小值将截断数组。</div><div class="line">c) 从Array.prototype中继承一些有用的方法。</div><div class="line">d) 其类属性为“Array”。</div></pre></td></tr></table></figure><p><br>    这些特性让JavaScript数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法把拥有一个数值length属性和对应的非负整数属性的对象看做一种类型的数组。<br></p><p><br>    实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望length属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。<br></p><p><br>    以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&#125;;// 从一个常规空对象开始</div><div class="line">// 添加一些属性，称为“类数组”</div><div class="line">var i = 0;</div><div class="line">while(i &lt; 10) &#123;</div><div class="line">    a[i] = i * i;</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line">a.length = i;</div><div class="line">// 现在，当做真正的数组遍历它</div><div class="line">var total = 0;</div><div class="line">for(var j = 0; j &lt; a.length; j++)</div><div class="line">    total += a[j];</div></pre></td></tr></table></figure><p><br>    像Arguments对象就是一个类数组对象。在客户端JavaScript中，一些DOM方法(如document.getElementsByTagName())也返回类数组对象。下面有一个函数可以用来检测类数组对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 判定o是否是一个类数组对象</div><div class="line">// 字符串和函数有length属性，但是它们</div><div class="line">// 可以用typeof检测将其排除。在客户端JavaScript中，DOM文本节点</div><div class="line">// 也有length属性，需要额外判断o.nodeType != 3将其排除</div><div class="line">function isArrayLike(o) &#123;</div><div class="line">    if (o &amp;&amp;// o非null、undefined等</div><div class="line">        typeof o === &quot;object&quot; &amp;&amp;// o是对象</div><div class="line">        isFinite(o.length) &amp;&amp;// o.length是有限数值</div><div class="line">        o.length &gt;= 0 &amp;&amp;// o.length为非负值</div><div class="line">        o.length === Math.floor(o.length) &amp;&amp;// o.length是整数</div><div class="line">        o.lenght &lt; 4294967296// o.length &lt; 2^32</div><div class="line">    )</div><div class="line">        return true;// o是类数组对象</div><div class="line">    else</div><div class="line">        return false;// 否则它不是</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在后面看到在ECMAScript 5中字符串的行为与数组类似(并且有些浏览器在ECMAScript 5之前已经让字符串变成可索引的了)。然而，类似上述的类数组对象的检测方法针对字符串常常返回false——它们通常最好当做字符串处理，而非数组。<br></p><p><br>    JavaScript数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。在ECMAScript 5中，所有的数组方法都是通用的。在ECMAScript 3中，除了toString()和toLocaleString()以外的所有方法也是通用的(concat()方法是一个特例：虽然可以用在类数组对象上，但它没有将那个对象扩充进返回的数组中。)既然类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。尽管如此，可以间接地使用Function.call方法调用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;, length: 3&#125;;// 类数组对象</div><div class="line">Array.prototype.join.call(a, &quot;+&quot;)// =&gt; &quot;a+b+c&quot;</div><div class="line">Array.prototype.slice.call(a, 0)// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]：真正数组的副本</div><div class="line">Array.prototype.map.call(a, function(x) &#123;</div><div class="line">    return x.toUpperCase();</div><div class="line">&#125;)// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</div></pre></td></tr></table></figure><p><br>    ECMAScript 5数组方法是在Firefox 1.5中引入的。由于它们的写法的一般性，Firefox还将这些方法的版本在Array构造函数上直接定义为函数。使用这些方法定义的版本，上述例子就可以这样重写：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;, length: 3&#125;;// 类数组对象</div><div class="line">Array.join(a, &quot;+&quot;)</div><div class="line">Array.slice(a, 0)</div><div class="line">Array.map(a, function(x) &#123; return x.toUpperCase(); &#125;)</div></pre></td></tr></table></figure><p><br>    当用在类数组对象上时，数组方法的静态函数版本非常有用。但既然它们不是标准的，不能期望它们在所有的浏览器中都有定义。可以这样书写代码来保证使用它们之前是存在的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Array.join = Array.join || function(a, sep) &#123;</div><div class="line">    return Array.prototype.join.call(a, sep);</div><div class="line">&#125;;</div><div class="line">Array.slice = Array.slice || function(a, from, to) &#123;</div><div class="line">    return Array.prototype.slice.call(a, from, to);</div><div class="line">&#125;;</div><div class="line">Array.map = Array.map || function(a, f, thisArg) &#123;</div><div class="line">    return Array.prototype.map.call(a, f, thisArg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-12-作为数组的字符串"><a href="#1-12-作为数组的字符串" class="headerlink" title="1.12 作为数组的字符串"></a>1.12 作为数组的字符串</h3><p><br>    在ECMAScript 5(在众多最近的浏览器实现——包括IE8——早于ECMAScript 5)中，字符串的行为类似于只读的数组。除了用charAt()方法来访问单个的字符以外，还可以使用方括号：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s = test;</div><div class="line">s.chatAt(0)// =&gt; &quot;t&quot;</div><div class="line">s[1]// =&gt; &quot;e&quot;</div></pre></td></tr></table></figure><p><br>    当然，针对字符串的typeof操作符仍然返回“string”，但是如果给Array.isArray()传递字符串，它将返回false。<br></p><p><br>    可索引的字符串的最大的好处就是简单，用方括号代替了chatAt()调用，这样更加简洁、可读并且可能更高效。不仅如此，字符串的行为类似于数组的事实使得通用的数组方法可以用到字符串上。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = &quot;JavaScript&quot;</div><div class="line">Array.prototype.join.call(s, &quot;&quot;)// =&gt; &quot;J a v a S c r i p t&quot;</div><div class="line">Array.prototype.filter.call(s,// =&gt; 过滤字符串中的字符</div><div class="line">    function(x) &#123;</div><div class="line">        return x.match(/[^aeiou]/);// =&gt; 只匹配非元音字母</div><div class="line"> &#125;).join(&quot;&quot;)// =&gt; &quot;JvScrpt&quot;</div><div class="line">)</div></pre></td></tr></table></figure><p><br>    请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()和splice()等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。<br></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弟子规 （三）</title>
      <link href="/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%883%EF%BC%89/"/>
      <url>/2018/06/27/%E5%BC%9F%E5%AD%90%E8%A7%84%20%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="四、谨"><a href="#四、谨" class="headerlink" title="四、谨"></a>四、谨</h3><p><br>    【解】所谓“谨”，就是一种生活态度，我们做人要谨慎小心才不至于犯错误。“谨”这部分的教诲可以培养一个人三方面的能力：第一是自制力，第二是独立生活的能力，第三是做事的能力。现在孩子大部分都缺乏这三方面的能力，也就是《论语》中所说的“洒扫、应对、进退”这种生活规范教育。可不要小看这六个字，它既是生活教育也是人品教育，这是中国文化教育一贯的传统。现在孩子大部分都是娇生惯养，从小就饭来张口、衣来伸手，家长都不肯让小孩去吃苦。这样就连最基本的洒扫庭除都不会，试想今后他们将如何面对生活呢？要知道“责任的承担是成长的开始”，一个孩子有责任心，他才能有所担当。所以，如果爱你的孩子，一定要让他们多承担一些家务。所谓“习劳知感恩”，只有通过亲身实践，他们才能真正体会到父母的辛劳、人生的艰苦，才会懂得尊重别人的劳动成果。这样他们自然也就养成了忍让、克己吃苦耐劳和善解人意的品格。培养出了坚强的意志力，长大以后才能经受住人生的艰难困苦，才能在逆境中奋起，才能挑重任、成大器。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">朝起早 &emsp;夜眠迟 &emsp;老易至 &emsp;惜此时</p><p style="margin-bottom: 0;"><br>    【解】为人子应早起，把握光阴及时努力，若经常晚睡甚至熬夜，不但对身体健康不好，也影响白天正常的作息。因为人生的岁月很有限，不要等到年纪老了，才悔恨自己浪费了宝贵的青春时光。<br></p><p><br>    “为中华之崛起而读书”是我们敬爱的周总理12岁那年立下的鸿鹄之志，为实现自己的崇高理想，他艰苦奋斗、努力拼搏，用坚强的意志，一生来实践自己所发的誓言，并使之成真，正是因为周总理少年立大志、立长志，才使他的人生如此灿烂辉煌。所以王阳明先生说：“志不立，无以成事。”一个人没有立志，这一生不可能把事情做好。所以要珍惜时间，首先要先立定人生的志向。人生很短暂，我们利用这个短暂的生命，要对得起父母的养育之恩，要对得起兄弟姐妹的关照，要对得起成长过程中诸多长者的提携，要对得起国家对我们的诸多照顾。所以，当一个人念念都是念着这些恩德，想着要去完成他人生的本分、使命，他一定是尽心尽力孝顺父母、友爱兄弟，进一步去奉献社会，没有人去推他，他也会快步向前。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">晨必盥 &emsp;兼漱口 &emsp;便溺回 &emsp;辄净手</p><p style="margin-bottom: 0;"><br>    【解】早晨起床后，务必洗脸、刷牙、漱口，使精神清爽，有一个好的开始。大小便后，一定要洗手，养成良好的卫生习惯，才能确保身体健康。（防止肠病毒，要学会洗手，手心、手背、指缝间均要仔细搓洗。）<br></p><p><br>    人与人每天彼此间的交谈很多，假如你不刷牙又有口臭，那别人还没有跟你交往，就已经对你有所轻视、排斥而不愿意靠近你了。所以，当别人有意躲着我们时，先不要责怪别人，要先反观自照，看看自己是不是这些礼节当中有所缺失，才造成别人对我们的反感。培养良好的卫生习惯是件平凡而细致的工作，孩子良好习惯和正确认识的养成，离不开日常具体事务中对其行为的约束和训练，都不是靠短时间内的说教便能奏效的，因此要持之以恒、坚持一贯地要求孩子，通过不断地训练和巩固，使之习惯成自然。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">冠必正 &emsp;纽必结 &emsp;袜与履 &emsp;俱紧切</p><p style="margin-bottom: 0;"><br>    【解】要注重服装仪容的整齐清洁，帽子要戴端正，衣服拉链、扣子要扣好，袜子穿平整，鞋带应系紧，否则容易被绊倒。注重生活细节，不仅有助于形成自身的威仪，还能逐渐养成做事严谨的习惯。<br></p><p><br>    一个人的穿戴表示了他的身份和地位，展示出他的气质和修养，反映了他的爱好和追求。穿戴整洁、优美、高雅还是脏污、丑陋、庸俗，可不是一件小事，一个人的仪容仪表不仅关系自身的形象，有时还关系到工作前途，同时也关系到对他人的尊重。很多大学生去应聘时，穿着邋遢不修边幅，随随便便，看起来很没有精神，这样常常不会被录取。纵使有好的才华，假如衣着不当，很可能就已经把这个机会挡在门外了。所以不能忽视孩子的仪表，它对孩子的心理变化和发展有很大的影响。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">置冠服 &emsp;有定位 &emsp;勿乱顿 &emsp;致污秽</p><p style="margin-bottom: 0;"><br>    【解】回家后脱下来的衣、帽、鞋、袜都要放置在固定的位置，以免弄皱弄脏，要找的时候又要找半天。<br></p><p><br>    当东西都有固定的位置，生活就会有条不紊，做起事来就能够循规蹈矩。我们从生活起居里面，就可以看出一个人真正的修养品德，这些素质要从小就开始培养，就在整理房间、衣物的时候，培养这颗恭敬、谨慎之心。虽然这些物品没有生命，但是你善待它，它也会用得愈久，所谓“爱人者人恒爱之，爱物者物恒爱之”。所以我们希望这一生能成功，现在就要把这些根基打好，大处着眼，小处着手，养成良好的生活习惯是成功的一半。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">衣贵洁 &emsp;不贵华 &emsp;上循分 &emsp;下称家</p><p style="margin-bottom: 0;"><br>    【解】穿衣服须注重整洁，不必讲究昂贵、名牌、华丽。穿着应考量自己的身份及场合，更要衡量家中的经济状况，才是持家之道。不要为了面子，更不要让虚荣心做主，无谓的开销就是浪费。<br></p><p><br>    爱美之心，人皆有之，服饰之美在于内在气质与外在形式的和谐统一。如果只追求外表光鲜靓丽，忽视内在修养，不仅浪费大量的金钱和精力，时间久了，也会因金玉其外、败絮其中而失去真正的魅力。况且一味追求名牌或奇装异服，强迫家长购买力所不能及的服装，这样不仅有损自己的形象，更是增加了父母的经济负担。父母养育我们已够辛苦，懂事的孩子只盼望自己能早一天为父母分忧解难，怎么能忍心再给父母添烦恼呢？其实穿衣服最重要的目的是保暖、遮羞，可是我们在买的过程当中，已经忘记了它本来的目的，反而沾上了虚荣的习性，仔细想一想实在是不应该呀！<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">对饮食 &emsp;勿拣择 &emsp;食适可 &emsp;勿过则</p><p style="margin-bottom: 0;"><br>    【解】日常饮食要注意营养均衡，多吃蔬菜水果，少吃肉，不要挑食，不可以偏食，三餐常吃八分饱，避免过量，以免增加身体的负担，危害健康。<br></p><p><br>    一个人真正活得怎么样、生命的质量如何，都与生活有没有常态紧密联系，暴饮暴食，夜不睡、晨不起，这都是生活没有规律的表现。老子说：“圣人为腹不为目。”饮食是为了吃饱肚子，而不是为了满足口目。当今社会的文明病，例如：癌症、糖尿病……等等，很多都是因为营养过剩与营养失衡所造成，要注意那些过分加工和太精致的食品，大都还有化学添加物，有害健康，不宜食用。<br></p><p><br>    世界卫生组织公布的全球十大垃圾食品：油炸类食品、腌制类食品、加工类肉食品（肉干、肉松、香肠等）、饼干类食品（不含低温烘烤和全麦饼干）、汽水可乐类食品、方便类食品（主要指方便面和膨化食品）、罐头类食品（包括鱼肉类和水果类）、话梅蜜饯类食品（果脯）、冷冻甜品类食品（冰淇淋、冰棒和各种雪糕）、烧烤类食品。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">年方少 &emsp;勿饮酒 &emsp;饮酒醉 &emsp;最为丑</p><p style="margin-bottom: 0;"><br>    【解】饮酒有害健康，要守法，青少年未成年不可以饮酒，成年人饮酒也不要过量。试看醉汉疯言疯语，丑态毕露，最容易表现出不当的言行，惹出多少是非？<br></p><p><br>    酒后无德、酒后乱性，人在这种不清醒的状态下，会说错话、做错事，往往做出很多丧失理智的事情，造成不可收拾的后果，所以从小就不要饮酒。这个酒也包括所有让我们沉迷的东西，像现在流行的游戏机、电脑游戏、赌博、酒吧、KTV，还包括更不好的抽烟、吸毒等，这些东西让人玩物丧志、沉迷不醒，要坚决把它戒除，一旦养成，后果不堪设想。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">步从容 &emsp;立端正 &emsp;揖深圆 &emsp;拜恭敬</p><p style="margin-bottom: 0;"><br>    【解】走路时步伐应当从容，要稳重大方、不慌不忙、不急不缓。站立时要端正、有站相，须抬头挺胸、精神饱满，不可以弯腰驼背、垂头丧气，所谓“立如松，行如风，坐如钟，卧如弓”。问候他人时，不论鞠躬或拱手作揖都要真诚恭敬，不能敷衍了事。<br></p><p><br>    一个人外在行为表现是他修养和素质的具体反映。走路稳重，站立端正，说明他具有沉稳、正直、不慌乱、不毛躁的性格；行礼时恭敬、谦和，说明他从内心深处尊重对方使受礼者感到被尊重，产生好感，很容易形成融洽和谐的气氛，所以不能轻视这些行为。《了凡四训》里面讲：“大都吉凶之兆，萌乎心而动乎体。其过于厚者常获福，过于薄者常近祸。”这是告诉我们一个人的吉凶祸福，通过这些身体的礼节、行为就可以预测他的将来如何。如果一个人的行为非常恭敬、厚道，那么他必定有福报；如果是轻薄、傲慢、懒惰，那么这种人必定会招惹祸患的。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">勿践阈 &emsp;勿跛倚 &emsp;勿箕踞 &emsp;勿摇髀</p><p style="margin-bottom: 0;"><br>    【解】进门时脚不要踩在门槛上，站立时身体不要歪道斜靠在墙边，这样看起来很不庄重。坐的时候不可以两条腿像畚箕一样，更不可以养成抖脚的坏习惯。有些人一坐下来腿就拼命地摇，这些都是心很浮躁、不安定、轻浮、傲慢、非常不雅观的举动。<br></p><p><br>    俗话说：“男抖穷，女抖贱。”做父母的看到子女有这些不好的举动要特别注意，一定要从小予以纠正，不然等他习惯养成，长大以后就会有很大的负面影响，人家看你一副轻浮的样子，一定得不到别人的喜欢和尊重。所谓“教儿教女先教己”，做父母的更应该首先以身作则，去除这些坏毛病。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">缓揭帘 &emsp;勿有声 &emsp;宽转弯 &emsp;勿触棱</p><p style="margin-bottom: 0;"><br>    【解】在古代房门口都会有布帘或竹帘，就等于我们现在的门一样，这是教我们开关门时，动作要轻，太大声有时会吓到人，而且我们的动作如果太大，有时帘子或门会打到后面的人。在走路转弯时，要与物品的棱角保持较宽的距离，除了避免使自己受伤外，也不会把东西弄乱或弄坏。<br></p><p><br>    这是告诉我们，做任何事情动作都要细腻、轻柔，不可以很粗鲁，要缓缓地做，不能够急躁，急于求成往往容易败事。特别是大事当前，更要心里安定，这样考虑问题就能够周详，做事就容易成功。一个人是否有学问，在哪里看？我们说替人着想是第一等学问，替人着想可不是嘴巴说的，而是要点点滴滴落实在生活之中。我们除了走路声、关门声不可以太大外，假如你吃饭的时候很大声，同样也会让人觉得很不舒服。所以我们要处处提醒自己，所作所为是否考虑到了他人的感受，要懂得在日常生活这些小事上，锻炼我们的大气质。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">执虚器 &emsp;如执盈 &emsp;入虚室 &emsp;如有人</p><p style="margin-bottom: 0;"><br>    【解】拿东西时要注意，即使是拿着空的器具，也要像里面装满东西一样小心谨慎，以防跌倒或打破。进入无人的房间，也要像有人在一样，不可以随便。<br></p><p><br>    这种专注的精神、细心的行为从小就要养成。这句话用在求学、工作中也非常适用，事情没来的时候，对待自己要谨慎，防范过失的发生，真正有事情来了，你就有了一种豁然大度的那种风度出来。崇高的节义、真实的道德学问，都是从暗室屋漏中来，我们要教导子女在没有人看到的地方更要懂得尊敬别人、谨慎自己的内心，不要随便碰别人的东西，不要起偷盗之心及不应该起的念头，因为这些都是很不尊重别人的态度，所以“慎独”非常重要。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">事勿忙 &emsp;忙多错 &emsp;勿畏难 &emsp;勿轻略</p><p style="margin-bottom: 0;"><br>    【解】做事不要急急忙忙、慌慌张张，因为忙中容易出错，做事情不要急于求成，要稳稳当当、按部就班地进行。遇到该办的事情不要畏苦怕难而犹豫退缩，也不可以草率、随便应付了事。<br></p><p><br>    《大学》里面讲：“物有本末，事有终始，知其先后，则近道矣。”这句话是告诉我们在处事接物当中要懂得先后顺序，要看清楚事情的轻重缓急，那些事要现在做，那些事可以暂缓一步做，哪些事并不必要去做。所以临事从容不迫，真正能够懂得事情的轻重缓急、先后顺序，那么这就是一个成功的人。当我们人生面临挫折、逆境、挑战时，要把它当成是一种锻炼，要有“责任的承担是成长的开始”的这种意识，在此境缘当中磨练我们的耐心、毅力以及处理问题的能力。所以我们要感谢挑战、感谢逆境，坚信只要不怕困难，通过努力，一定能成功。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">斗闹场 &emsp;绝勿近 &emsp;邪僻事 &emsp;绝勿问</p><p style="margin-bottom: 0;"><br>    【解】凡是容易发生争吵打斗不健康的场所，如赌博、色情、网吧等是非之地，要勇于拒绝，不要接近，以免受到不良的影响。一些邪恶下流、荒诞不经的事也要谢绝，不听、不看，不要好奇地去追问，以免污染了善良的心性。孔夫子说：“非礼勿视，非礼勿听，非礼勿言，非礼勿动。”就是此意。<br></p><p><br>    孩子倒不好的环境去，交到不好的朋友，根源还是在于善恶不明。假如从小就能把孩子德行的根基扎稳，善恶分明，当他接触到不善的人和环境，自然就会敬而远之。因为他心中那把做人的尺度清清楚楚、明明白白，这叫先入为主。所以，一定要在孩子还没有养成、染上这些恶习的时候就要制止，这样您的中晚年才能够高枕无忧。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">将入门 &emsp;问孰存 &emsp;将上堂 &emsp;声必扬</p><p style="margin-bottom: 0;"><br>    【解】将要入门之前应先问：“有人在吗？”进入办公室或客厅之前，应先提高声音，让里面的人知道有人要进来了，这个除了显示行为光明正大之外，也是避免吓到别人。<br></p><p><br>    不管你到什么样的房间，不论里面有没有人，都要养成先敲门的习惯，这是对人的尊重。假如我们问都不问，一下子贸然闯入，这就是对主人的不恭敬了。屋子里如果没人，绝对不能进去，假如人家刚好丢东西，你就百口莫辩了。所以，人一生要很注重自己的名节、信誉，不要因为自己的不谨慎而招惹没必要的麻烦。这些都是基本的礼节，要从小教导孩子。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">人问谁 &emsp;对以名 &emsp;吾与我 &emsp;不分明</p><p style="margin-bottom: 0;"><br>    【解】现代家庭都有门铃，我们按了门铃，对方拿起听筒一定会问：“你是谁？”这个时候我们应该报出自己的姓名并表明来意，而不是说“我！我！”，让人无法分辨“我”是谁？<br></p><p><br>    如果只回答“是我”，这种回答等于没说。我们以为对方一定记得我们、认出我们的声音，结果对方有可能根本搞不清楚你究竟是谁，反而弄得双方都很尴尬，这样就很失礼。另外，我们按门铃时不要拼命一直按，按了以后要稍微停二十秒左右，再按第二下，要给屋里人走到门口开门的时间。当这些细微之处你都能时时替对方着想，就会给人留下很好的印象，觉得你是一个有礼貌的人。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">用人物 &emsp;须明求 &emsp;倘不问 &emsp;即为偷</p><p style="margin-bottom: 0;"><br>    【解】当我们要用别人的东西时，一定要先经过主人的同意。如果事先没有经过主人的同意就擅自动用，这种行为就叫作偷盗。<br></p><p><br>    如果我们随便拿别人的东西来用，当主人找不到时就会生烦恼，很多的争执、冲突就是因为这些小节没注意到而引起的。还有一些人出于好奇心，经常去翻别人的抽屉、柜子等，看看有些什么东西，这种行为一旦让人知道，将来别人丢东西了，第一个就会想到你。所以，不该我们拿的或用的，连动都不要动，以免招惹没必要的嫌疑，给自己带来没必要的麻烦，我们不要因为这些小事而亏欠了德行。<br></p><p style="text-align: center;font-size: 14px;font-weight: bold; margin-bottom: 0;">借人物 &emsp;及时还 &emsp;后有急 &emsp;借不难</p><p style="margin-bottom: 0;"><br>    【解】借用他人的物品，要爱惜使用并准时归还。这样以后若有急用，再借就不难了（谚云：“好借好还，再借不难。”）<br></p><p style="margin-bottom: 0;"><br>    要借别人的东西，即使是再近的亲人，都要当面向他讲清理由，有礼貌地提出请求，如果人家拒绝了，要理解人家。当人家借给我们之后要心存感恩，因为这是人家在帮助你。说好了什么时候归还，一定要及时归还而且要答谢，这是讲信用、有礼貌的表现。假如不准时归还，就太没有道义了。所以，当我们确定哪个时间要还时，一定要写在日历或记事本上，以免忘记。使用别人东西时要比对自己的东西还要爱惜，做到完璧归赵，这样人家才会信任你。万一有损坏，要向人家说明，主动提出赔偿。当你每次借人家的东西都这么谨慎时，往后借再多的东西，人家也会很欢喜地把东西借给你了。<br></p><p><br>    有人说现代社会要敢想敢干，谨慎已经过时了，此种看法非常浅薄。做事既要有胆略，也要有谨慎，缺一不可，所谓胆大而心细，做人讲道德，更要“吾日三省吾身”，在细微处下手。社会生产生活方式常变，而人性千古不变，古人“谨”字的训导，永不过时。<br></p>]]></content>
      
      
        <tags>
            
            <tag> 古文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>变量、作用域和内存变量（二）——JavaScript高级程序设计</title>
      <link href="/2018/06/27/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/06/27/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-3-垃圾收集"><a href="#1-3-垃圾收集" class="headerlink" title="1.3 垃圾收集"></a>1.3 垃圾收集</h3><p><br>    JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在C和C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写JavaScript程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。<br></p><p><br>    下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈(或堆)内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有的情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。<br></p><h3 id="1-3-1-标记清除"><a href="#1-3-1-标记清除" class="headerlink" title="1.3.1 标记清除"></a>1.3.1 标记清除</h3><p><br>    JavaScript中最常用的垃圾收集方式是标记清除(mark-and-sweep).当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。<br></p><p><br>    可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。<br></p><p><br>    垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记(当然，可以使用任何标记方式)。然后，它会去掉环境中的变量以及被环境中的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br></p><p><br>    到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略(或类似的策略)，只不过垃圾收集的时间间隔互有不同。<br></p><h3 id="1-3-2-引用计数"><a href="#1-3-2-引用计数" class="headerlink" title="1.3.2 引用计数"></a>1.3.2 引用计数</h3><p><br>    另一种不太常见的垃圾收集策略叫做引用计数(reference counting)。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋给该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，这说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。<br></p><p><br>    Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。请看下面这个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function problem() &#123;</div><div class="line">    var objectA = new Object();</div><div class="line">    var objectB = new Object();</div><div class="line"></div><div class="line">    objectA.someOtherObject = objectB;</div><div class="line">    objectB.anotherObject = objectA;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在这个例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2.在采用标记清除策略的实现中，但函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不会是0.假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，NetScape在Navigator4.0中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。<br></p><p><br>    我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM(Component Object Model，组件对象模型)对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的JavaScript引擎是使用标记清除策略来实现的，但JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用COM对象导致的循环引用问题：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var element = document.getElementById(&quot;some_element&quot;);</div><div class="line">var myObject = new Object();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure><p><br>    这个例子在一个DOM元素(element)与一个原生JavaScript对象(myObject)之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个属性名叫someObject回指myObject。由于存在这个循环引用，即使将例子中的DOM从页面中移除，它也永远不会被回收。<br></p><p><br>    为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生JavaScript对象与DOM元素之间的链接。例如，可以使用下面的代码消除前面例子创建的循环引用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = null;</div><div class="line">element.someObject = null;</div></pre></td></tr></table></figure><p><br>    将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。<br></p><p><br>    为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄露现象。<br></p><h3 id="1-3-3-性能问题"><a href="#1-3-3-性能问题" class="headerlink" title="1.3.3 性能问题"></a>1.3.3 性能问题</h3><p><br>    垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一次，不禁让人联想到IE因此而声名狼藉的性能问题。IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象(或数组)字面量和数组元素(slot)或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。<br></p><p><br>    随着IE7的发布，其JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和(或)数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和(或)数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置或默认值。这一看似简单的调整，极大地提升了IE在运行包含大量JavaScript的页面时的性能。<br></p><h3 id="1-3-4-管理内存"><a href="#1-3-4-管理内存" class="headerlink" title="1.3.4 管理内存"></a>1.3.4 管理内存</h3><p><br>    使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是处于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。<br></p><p><br>    因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用(dereferencing)。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被接触引用，如下面这个例子所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function createPerson(name) &#123;</div><div class="line">    var localPerson = new Object();</div><div class="line">    localPerson.name = name;</div><div class="line">    return localPerson;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var globalPerson = createPerson(&quot;Nicholas&quot;);</div><div class="line"></div><div class="line">// 手工解除globalPerson的引用</div><div class="line">globalPerson = null;</div></pre></td></tr></table></figure><p><br>    在这个例子中，变量globalPerson取得了createPerson()函数返回的值。在createPerson()函数内部，我们创建了一个对象并将其赋给局部变量localPerson，然后又为该对象添加了一个名为name的属性。最后，当调用这个函数时，localPerson以函数值的形式返回并赋给全局变量globalPerson。由于localPerson在createPerson()函数执行完毕后就离开了其执行环境，因此，无须我们显式地去为它解除引用。但是对于全局变量globalPerson而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。<br></p><p><br>    不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。<br></p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><br>    JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1) 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</div><div class="line">2) 从一个变量向另一个变量复制基本类型的值，会创建这个值的副本；</div><div class="line">3) 引用类型的值是对象，保存在堆内存中；</div><div class="line">4) 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</div><div class="line">5) 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都会指向同一个对象；</div><div class="line">6) 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。</div></pre></td></tr></table></figure><p><br>    所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) 执行环境有去全局执行环境(也称为全局环境)和函数执行环境之分；</div><div class="line">2) 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</div><div class="line">3) 函数的局部环境不仅有权访问函数作用域中变量，而且有权访问其包含(父)环境，乃至全局环境；</div><div class="line">4) 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</div><div class="line">5) 变量的执行环境有助于确定应该何时释放内存。</div></pre></td></tr></table></figure><p><br>    JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</div><div class="line">2) &quot;标记清除&quot;是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。</div><div class="line">3) 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象(如DOM元素)时，这种算法仍然可能会导致问题。</div><div class="line">4) 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</div><div class="line">5) 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组(一)</title>
      <link href="/2018/06/27/%E6%95%B0%E7%BB%84/"/>
      <url>/2018/06/27/%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。JavaScript数组的索引是基于零的32位数值：第一个元素的索引为0，最大可能的索引为4 294 967 294（2^32-2）,数组最大能容纳4 294 967 295个元素。JavaScript数组是动态的：根据需要他们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个JavaScript数组都有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length比所有元素的索引都要大。</p><p>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规对象属性要快很多。</p><p>数组继承自Array.prototype中的属性，它定义了一套丰富的数组操作方法。大多数这些方法是通用的，这意味着它们不仅对真正的数组有效，而且对“类数组对象”同样有效。 </p></blockquote><h3 id="1-1-创建数组"><a href="#1-1-创建数组" class="headerlink" title="1.1 创建数组"></a>1.1 创建数组</h3><p><br>    使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var empty = [];// 没有元素的数组</div><div class="line">var primes = [2, 3, 5, 7, 11];// 有5个数值的数组</div><div class="line">var misc = [1.1, true, &apos;a&apos;,];// 3个不同类型的元素和结尾的逗号</div></pre></td></tr></table></figure><p><br>    数组直接量中的值不一定要是常量；它们可以是任意的表达式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var base = 1024;</div><div class="line">var table = [base, base+1, base+2, base+3];</div></pre></td></tr></table></figure><p><br>    它可以包含对象直接量或其他数组直接量：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var b = [[1, &#123;x: 1, y:2 &#125;], [2, &#123;x: 3, y: 4 &#125;]];</div></pre></td></tr></table></figure><p><br>    如果省略数组直接量中的某个值，省略的元素将被赋予undefined值：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var count = [1,,3];// 数组有3个元素，中间的哪个元素值为undefined</div><div class="line">var undefs = [,,];// 数组有2个元素，都是undefined</div></pre></td></tr></table></figure><p><br>    数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。<br></p><p><br>    调用构造函数Array()是创建数组的另一种方法。可以用三种方式调用构造函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">a) 调用时没有参数</div><div class="line">var a = new Array();</div><div class="line">该方法创建一个没有任何元素的空数组，等同于数组直接量[].</div><div class="line"></div><div class="line">b) 调用时有一个数值参数，它指定长度：</div><div class="line">var a = new Array(10);</div><div class="line">该技术创建指定长度的数组。当预先知道所需元素个数时，这种形式的Array()构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还未定义。</div><div class="line"></div><div class="line">c) 显式指定两个或多个数组元素或者数组的一个非数值元素：</div><div class="line">var a = new Array(5, 4, 3, 2, 1, &quot;testing, testing&quot;);</div><div class="line">以这种形式，构造函数的参数将会成为新数组的元素。使用数组字面量比这样使用Array()构造函数要简单多了。</div></pre></td></tr></table></figure><h3 id="1-2-数组元素的读和写"><a href="#1-2-数组元素的读和写" class="headerlink" title="1.2 数组元素的读和写"></a>1.2 数组元素的读和写</h3><p><br>    使用[]操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的JavaScript语句：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [&quot;world&quot;];// 从一个元素的数组开始</div><div class="line">var value = a[0];// 读第0个元素</div><div class="line">a[1] = 3.14;// 写第一个元素</div><div class="line">i = 2;</div><div class="line">a[i] = 3;// 写第二个元素</div><div class="line">a[i + 1] = &quot;hello&quot;;// 写第三个元素</div><div class="line">a[a[i]] = a[0];// 读第0个元素和第2个元素，写第三个元素</div></pre></td></tr></table></figure><p><br>    请记住，数组是对象的特殊形式。使用方括号访问数组元素就像方括号访问对象的属性一样。JavaScript将指定的数字索引值转换成字符串——索引值1变成“1”——然后将其作为属性名来使用。关于索引值从数字转换为字符串没有什么特别支持：对常规对象也可以这么做：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">o = &#123;&#125;;// 创建一个普通对象</div><div class="line">o[1] = &quot;one&quot;;// 用一个整数来索引它</div></pre></td></tr></table></figure><p><br>    数组的特别之处在于，当使用小于2^32的非负整数作为属性名时数组会自动维护其length属性值。如上，创建仅有一个元素的数组。然后，在索引1、2和3处分别进行赋值。当我们这么做时数组的length属性值变为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.length // =&gt; 4</div></pre></td></tr></table></figure><p><br>    清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有0~2^32-2之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但是如果使用的属性是数组的索引，数组的特殊性为就是将根据需要更新它们的length属性值。<br></p><p><br>    注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果碰巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性，当使用的一个浮点数和一个整数相等时情况也是一样的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[-1.23] = true;// 这将创建一个名为“-1.23”的属性</div><div class="line">a[&quot;1000&quot;] = 0;// 这是数组的第1001个元素</div><div class="line">a[1.000]// 和a[1]相等</div></pre></td></tr></table></figure><p><br>    事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着JavaScript数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到undefined值。类似于对象，对于对象同样存在这种情况。<br></p><p><br>    既然数组是对象，那么它们可以从原型中继承元素。在ECMAScript 5中，数组可以定义元素的getter和setter方法，你应该期望它使用非优化的代码路径：访问这种数组的元素时间会与常规对象属性的查找相近。<br></p><h3 id="1-3-稀疏数组"><a href="#1-3-稀疏数组" class="headerlink" title="1.3 稀疏数组"></a>1.3 稀疏数组</h3><p><br>    稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。可以用Array()构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = new Array(5);// 数组没有元素，但是a.length是5</div><div class="line">a = [];// 创建一个空数组，length=0</div><div class="line">a[1000] = 0;// 赋值添加一个元素，但是设置length为1001</div></pre></td></tr></table></figure><p>后面会看到你也可以用delete操作符来生产稀疏数组。</p><p><br>    足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。<br></p><p><br>    注意，当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为undefined。这和数组元素根本不存在时有一些微妙的区别的。可以用in操作符检测两者之间的区别：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a1 = [,,,];// 数组是[undefined, undefined, undefined]</div><div class="line">var a2 = new Array(3);// 该数组根本没有元素</div><div class="line">0 in a1// =&gt; true：a1在索引0处有一个元素</div><div class="line">0 in a1// =&gt; false：a2在索引0处没有元素</div></pre></td></tr></table></figure><p>当使用for/in循环时，a1和a2之间的区别也很明显。</p><p><br>    在一些旧版本的实现中（比如Firefox），在存在连续逗号的情况下，插入undefined值的操作则与此不同，在这些实现中，[1,,3]和[1,undefined,3]是一模一样的。<br></p><p><br>    了解稀疏数组是了解JavaScript数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数JavaScript数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能向对待非稀疏数组一样来对待它们，只不过它们包含一些undefined值。<br></p><h3 id="1-4-数组长度"><a href="#1-4-数组长度" class="headerlink" title="1.4 数组长度"></a>1.4 数组长度</h3><p><br>    每个数组有一个length属性，就是这个属性使其区别于常规的JavaScript对象。针对稠密(也就是非稀疏)数组,length属性值代表数组中元素的个数。其值比数组中最大的索引大1：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[].length // =&gt; 0: 数组没有元素</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].length // =&gt; 3: 最大的索引为2，length为3</div></pre></td></tr></table></figure><p><br>    当数组是稀疏的时，length属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中(无论稀疏与否)肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1。<br></p><p><br>    第二个特殊行为就是设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3, 4, 5];// 从5个元素的数组开始</div><div class="line">a.length = 3;// 现在a为[1, 2, 3]</div><div class="line">a.length = 0;// 删除所有的元素。a为[]</div><div class="line">a.length = 5;// 长度为5，但是镁元素，就像new Array(5)</div></pre></td></tr></table></figure><p><br>    还可以将数组的length属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。<br></p><p>在ECMAScript 5中，可以用Object.defineProperty()让数组的length属性值变成只读的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3];// 从3个元素的数组开始</div><div class="line">Object.defineProperty(a, &quot;length&quot;, &#123; writable: false &#125;);// 让length属性只读</div><div class="line">a.length = 0;// a不会改变</div></pre></td></tr></table></figure><p><br>    类似地，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，length属性不能设置为小于不可配置元素的索引值。<br></p><h3 id="7-5-数组元素的添加和删除"><a href="#7-5-数组元素的添加和删除" class="headerlink" title="7.5 数组元素的添加和删除"></a>7.5 数组元素的添加和删除</h3><p>我们已经见过添加数组元素最简单的方法：为新索引赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = []// 开始是一个空数组</div><div class="line">a[0] = &quot;zero&quot;;// 然后向其中添加元素</div><div class="line">a[1] = &quot;one&quot;;</div></pre></td></tr></table></figure><p>也可以使用push()方法在数组末尾增加一个或多个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [];// 开始是一个空数组</div><div class="line">a.push(&quot;zero&quot;)// 在末尾添加一个元素。a = [&quot;zero&quot;]</div><div class="line">a.push(&quot;one&quot;, &quot;two&quot;)// 再添加两个元素。a = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</div></pre></td></tr></table></figure><p><br>    在数组尾部压入一个元素与给数组a[a.length]赋值是一样的。可以使用unshift()方法在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。<br></p><p>可以像删除对象属性一样使用delete运算符来删除数组元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3];</div><div class="line">delete a[1];// a在索引1的位置不再有元素</div><div class="line">1 in a // =&gt; false：数组索引1并未在数组中定义</div><div class="line">a.length // =&gt; 3：delete操作并不影响数组长度</div></pre></td></tr></table></figure><p><br>    删除数组元素与为其赋undefined值是类似的(但有一些微妙的区别).注意，对一个数组元素使用delete不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，他就变成稀疏数组。<br></p><p><br>    上面我们看到，也可以简单地设置length属性为一个新的期望长度来删除数组尾部的元素。数组有pop()方法(它和push()一起使用)，后者一次使减少长度1并返回被删除元素的值。还有一个shift()方法(它和unshift()一起使用)，从数组头部删除一个元素。和delete不同的是shift()方法将所有元素下移到比当前索引低1的地方。<br></p><p><br>    最后，splice()是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改length属性并移动元素到更高或更低的索引处。<br></p><h3 id="1-6-数组遍历"><a href="#1-6-数组遍历" class="headerlink" title="1.6 数组遍历"></a>1.6 数组遍历</h3><p>使用for循环时遍历数组元素最常见的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var keys = Object.keys(o);// 获取对象属性名组成的数组</div><div class="line">var values = []// 在数组中存储匹配属性的值</div><div class="line">for (var i = 0; i &lt; keys.length; i++) &#123;// 对于数组中每个索引</div><div class="line">var key = keys[i];// 获取索引处的键值</div><div class="line">values[i] = o[key];// 在values数组中保存属性值</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">    // 循环体仍然不变</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    这些例子假设数组是稠密的，并且多有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。如果想要排除null、undefined和不存在的元素，代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; a.length; i++) &#123;</div><div class="line">    if (!a[i]) continue;// 跳过null、undefined和不存在的元素</div><div class="line">    // 循环体</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    如果指向跳过undefined和不存在的元素，代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; a.length; i++) &#123;</div><div class="line">    if (a[i] === undefined) continue;// 跳过undefined+不存在的元素</div><div class="line">    // 循环体</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    还可以使用for/in循环处理稀疏数组。循环每次将一个可枚举的属性名(包括数组索引)赋值给循环变量。不存在的索引将不会遍历到：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var index in sparseArray) &#123;</div><div class="line">    var value = sparseArrayp[index];</div><div class="line">    // 此处可以使用索引和值做一些事情</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    我们已经注意到了for/in循环能够枚举继承的属性名，如添加到Array.prototype中的方法。由于这个原因，在数组上不应该使用for/in循环，除非使用额外的检测方法来过滤不想要的属性。如下检测代码取其一即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for(var i in a) &#123;</div><div class="line">    if (!a.hasOwnProperty(i)) continue;// 跳过继承的属性</div><div class="line">    // 循环体</div><div class="line">&#125;</div><div class="line">for(var i in a) &#123;</div><div class="line">    // 跳过不是非负整数的i</div><div class="line">    if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br>    ECMAScript规范允许for/in循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。特别地，如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如果处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用for/in而用常规的for循环。<br></p><p><br>    ECMAScript 5定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数。这些方法中最常用的就是forEach()方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var data = [1, 2, 3, 4, 5];// 这是需要遍历的数组</div><div class="line">var sumOfSquares = 0;// 要得到数据的平方和</div><div class="line">data.forEach(function(x) &#123;// 把每个元素传递给此函数</div><div class="line">    sumOfSquares += x*x;// 平方相加</div><div class="line">&#125;);</div><div class="line">sumOfSquares// =&gt; 55: 1+4+9+16+25</div><div class="line"></div><div class="line">forEach()和相关的遍历方法使得数组拥有简单而强大的函数式编程风格。</div></pre></td></tr></table></figure><h3 id="1-7-多维数组"><a href="#1-7-多维数组" class="headerlink" title="1.7 多维数组"></a>1.7 多维数组</h3><p><br>    JavaScript不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次[]操作符即可。例如，假设变量matrix是一个数组的数组，它的基本元素是数值，那么matrix[x]的每个元素是包含一个数值数组，访问数组中特定数值的代码为matrix[x][y].这里有一个具体的例子,它使用二维数组作为一个九九乘法表：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 创建一个多维数组</div><div class="line">var table = new Array(10);// 表格有10行</div><div class="line">for (var i = 0; i &lt; table.length; i++) &#123;</div><div class="line">    table[i] = new Array(10);// 每列有10行</div><div class="line">&#125;</div><div class="line">// 初始化数组</div><div class="line">for (var row = 0; row &lt; table.length; row++) &#123;</div><div class="line">    for (col = 0; col &lt; table[row].length; col++) &#123;</div><div class="line">        table[row][col] = row * col;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 使用多为数组来计算(查询)5*7</div><div class="line">var product = table[5][7];// 35</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>定位概述</title>
      <link href="/2018/06/27/%E5%AE%9A%E4%BD%8D%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/06/27/%E5%AE%9A%E4%BD%8D%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>既然已经熟悉了盒模型，就来看看可视化格式模型和定位模型。理解这两个模型的细微差异是非常重要的，因为它们一起控制着如何在页面上布置每个元素。</p></blockquote><h3 id="一、可视化模型"><a href="#一、可视化模型" class="headerlink" title="一、可视化模型"></a>一、可视化模型</h3><p><br>    p、h1或div等元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，strong和span等元素称为行内元素，因为它们的内容显示在行中，即“行内框”。<br></p><p><br>    可以使用display属性改变生成的框的类型。这意味着，通过将display属性设置为block，可以让行内元素（比如锚）表现得像块级元素一样。还可以通过将display属性设置为none，让生成的元素根本没有框。<br>    这样，这个框及其所有内容就不再显示，不占用文档中的空间。<br></p><p><br>    CSS中有3种基本的定位机制：普通流、浮动和绝对定位。除非专门指定，否则所有框都在普通流中定位。顾名思义，普通流中元素框的位置由元素在HTML中的位置决定。<br></p><p><br>    块级框从上到下一个接一个地垂直排列，框之间的垂直距离由框的垂直外边距计算出来。<br></p><p><br>    行内框在一行中水平排列。可以使用水平内边距、边框和外边距调整它们的水平间距（图1-9）。但是，垂直内边距、边框和外边距不影响行内框的高度。同样，在行内框上设置显式的高度或宽度也没有影响。<br>    由一行形成的水平框称为行框，行内框的高度总是足以容纳它包含的所有行内框。但是，设置行高可以增加这个框的高度。因此，修改行内框尺寸的唯一方法是修改行高或者水平边框、内边距或外边距。<br></p><p><img src="https://shaoqianheng.github.io/images/1-9.png"></p><div style="text-align: center;">图1-9 行框中的行内元素</div><p><br>    好在CSS2.1允许把元素的display属性设置为inline-block。顾名思义，这个声明让元素像行内元素一样水平地依次排列。但是，框的内容仍然符合块级框的行为，例如能够显式地设置高度、宽度、垂直外边距和<br>    内边距。过去，浏览器对这个属性的支持很差，所以很少使用它。现在，Firefox3.0及更高版本、IE8以及Safari和Opera的最新版本支持inline-block。<br></p><p><br>    框可以按照HTML元素的嵌套方式包含其他框。大多数框由显式定义的元素形成。但是，在一种情况下，即使没有进行显式定义，也会创建块级元素。这种情况发生在将一些文本添加到一个块级元素（比如div）的开头时。即使没有把这些文本定义为块级元素，它也会被当成块级元素对待：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">some text</div><div class="line">&lt;p&gt;Some more text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p><br>    在这种情况下，这个框称为匿名块框，因为它不与专门定义的元素相关联。<br></p><p><br>    块级元素内的文本行也会发生类似的情况。假设有一个包含3行文本的段落。每行文本形成一个匿名行框。无法直接对匿名块或行框应用样式，除非使用不常用的：first-line伪元素。但是，这有助于理解在屏幕上看到的所有东西都形成某种框。<br></p><h3 id="二、相对定位"><a href="#二、相对定位" class="headerlink" title="二、相对定位"></a>二、相对定位</h3><p><br>    相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点移动。如果将top设置为20像素，那么框将出现在原位置顶部下面20像素的地方。如果将left设置为20像素，那么会在元素左边创建20像素的空间，也就是将元素向右移动（图1-10）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#myBox &#123;</div><div class="line">position: relative;</div><div class="line">left: 20px;</div><div class="line">top: 20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://shaoqianheng.github.io/images/1-10.png"></p><div style="text-align: center;">图1-10 对元素进行相对定位</div><p><br>    在使用相对定位时，无论是否移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框。<br></p><h3 id="三、绝对定位"><a href="#三、绝对定位" class="headerlink" title="三、绝对定位"></a>三、绝对定位</h3><p><br>    相对定位实际上被看做普通流定位模型的一部分，因为元素的位置是相对于它的普通流中的位置的。与之相反，绝对定位使元素与文档流无关，因此不占据空间。普通文档流中其他元素的布局就像绝对定位的元素不存在时一样。（图1-11）<br></p><p><img src="https://shaoqianheng.github.io/images/1-11.png"></p><div style="text-align: center;">图1-11 对元素进行绝对定位</div><p><br>    绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。如果元素没有已定位的祖先元素，那么它的位置是相对于初始包含块的。根据用户代理的不同，初始包含块可能是画布或HTML元素。<br></p><p><br>    与相对定位的框一样，绝对定位的框可以从它的包含块向上、下、左、右移动。这提供了很大的灵活性，你可以直接将元素定位在页面上的任何位置。<br></p><blockquote><p>对于定位的主要问题是要记住每种定位的意义。相对定位是“相对于”元素在文档流中的初始位置，而绝对定位是“相对于”距离它最近的已定位的祖先元素，如果不存在已定位的祖先元素，那么相对于初始包含块。</p></blockquote><p><br>    因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其他元素。可以通过设置z-index属性来控制这些框的叠放次序。z-index值越高，框在栈中的位置就越高。<br></p><p><br>    相对于最近的已定位祖先元素来定位绝对定位的元素，能够实现一些非常有意思的效果。例如，假设希望让一个文本段落对准一个大框的右下角，只需对包含框进行相对定位，然后相对于这个框对段落进行绝对定位：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#branding &#123;</div><div class="line">width: 70em;</div><div class="line">height: 10em;</div><div class="line">position: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#branding .tel &#123;</div><div class="line">position: absolute;</div><div class="line">right: 1em;</div><div class="line">bottom: 1em;</div><div class="line">text-align: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div id=&quot;branding&quot;&gt;</div><div class="line">&lt;p class=&quot;tel&quot;&gt;Tel: 0845 838 6163&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p><br>    在进行页面布局时，绝对定位是非常有用的，尤其是在使用相对定位的祖先元素的情况下。你完全可能只使用绝对定位就创建出整个设计。为此，这些元素需要具有固定尺寸，这样就能够将它们定位在任何地方而不会有重叠的风险。<br></p><p><br>    因为绝对定位的元素与文档流无关，所以它们不影响普通流中的框。如果扩大绝对定位的框（例如，通过增加字号），周围的框不会重新定位。因此，尺寸的任何改变都会导致绝对定位的框产生重叠，从而破坏精心调整过的布局。<br></p><h3 id="3-2-固定定位"><a href="#3-2-固定定位" class="headerlink" title="3.2 固定定位"></a>3.2 固定定位</h3><p><br>    固定定位是绝对定位的一种。差异在于固定元素的包含块是视口(viewport)。这使我们能够创建总是出现在窗口中相同位置的浮动元素。<br></p><blockquote><p>不过，IE6和更低版本不支持固定定位。IE 7部分支持这个属性，但是实现中有许多bug。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/06/27/DOM%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/06/27/DOM%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>type: “tags”   —<br>title: DOM（二）——JavaScript高级程序设计<br>tags: JavaScript<br>categories: []<br>type: “tags”   —</p><h3 id="1-1-2-Document类型"><a href="#1-1-2-Document类型" class="headerlink" title="1.1.2 Document类型"></a>1.1.2 Document类型</h3><p><br>    JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。Document节点具有下列特征：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">（1）nodeType的值为9</div><div class="line">（2）nodeName的值为“#document”</div><div class="line">（3）nodeValue的值为null</div><div class="line">（4）parentNode的值为null</div><div class="line">（5）ownerDocument的值为null</div><div class="line">（6）其子节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment。</div></pre></td></tr></table></figure><p><br>    Document类型可以表示HTML页面或者其他基于XML的文档。不过，最常见的应用还是作为HTMLDocument实例的document对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。<br></p><blockquote><p>在Firefox、Safari、Chrome和Opera中，可以通过脚本访问Document类型的构造函数和原型。但在所有浏览器中都可以访问HTMLDocument类型的构造函数和原型，包括IE8及后续版本。</p></blockquote><h4 id="1-文档的子节点"><a href="#1-文档的子节点" class="headerlink" title="1. 文档的子节点"></a>1. 文档的子节点</h4><p><br>    虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是documentElement属性，该属性始终指向HTML页面中的<html>元素。另一个就是通过childNodes列表访问文档元素，但通过documentElement属性则能更快捷、更直接地访问该元素。以下面这个简单的页面为例。<br></html></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">    </div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p><br>    这个页面在经过浏览器解析后，其文档中只包含一个子节点，即<html>元素。可以通过documentElement或childNodes列表来访问这个元素，如下所示。<br></html></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var html = document.documentElement;    // 取得对&lt;html&gt;的引用</div><div class="line">alert(html === document.childNodes[0]); // true</div><div class="line">alert(html === document.firstChild);    // true</div></pre></td></tr></table></figure><p><br>    这个例子说明，documentElement、firstChild和childNodes[0]的值相同，都指向<html>元素。<br></html></p><p><br>    作为HTMLDocument的实例，document对象还有一个body属性，直接指向<body>元素。因为开发人员经常要使用这个元素，所以document.body在JavaScript代码中出现的频率非常高，其用法如下。<br>    var body = document.body;   // 取得对<body>的引用<br></body></body></p><p><br>    所有浏览器都支持document.documentElement和document.body属性。<br></p><p><br>    Document另一个可能的子节点是DocumentType。通常&lt;!DOCTYPE&gt;标签看成一个与文档其他部分不同的实体，可以通过doctype属性(在浏览器中是document.doctype)来访问它的信息。<br><br>    var doctype = document.doctype;     // 取得对&lt;!DOCTYPE&gt;的引用<br></p><p><br>    浏览器对document.doctype的支持差别很大，可以给出如下总结。<br>    （1）IE8及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当做Comment节点；而document.doctype的值始终为null。<br>    （2）IE9+及Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点：document.doctype是一个DocumentType节点，也可以通过document.firstChild或document.childNodes[0]访问同一个节点。<br>    （3）Safari、Chrome和Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype是一个DocumentType节点，但该节点不会出现在document.childNodes中。<br></p><p><br>    由于浏览器对document.doctype的支持不一致，因此这个属性的用处很有限。<br></p><p><br>    从技术上说，出现在<html>元素外部的注释应该算是文档的子节点。然而，不同的浏览器在是否解析这些注释以及能否正确处理它们等方面，也存在很大差异。以下面简单的HTML页面为例。<br></html></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!--第一条注释 --&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;body&gt;</div><div class="line"></div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">&lt;!--第二条注释 --&gt;</div></pre></td></tr></table></figure><p><br>    看起来这个页面应该有3个子节点：注释、<html>元素、注释。从逻辑上讲，我们会认为document.childNodes中应该包含与这3个节点对应的3项。但是，现实中的浏览器在处理位于<html>外部的注释方面存在如下差异。<br></html></html></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（1）IE8及之前版本、Safari 3.1及更高版本、Opera和Chrome只为第一条注释创建节点，不为第二条注释创建节点。结果，第一条注释就会成为document.childNodes中的第一个子节点。</div><div class="line">（2）IE9及更高版本会将第一条注释创建为document.childNodes中的一个注释节点，也会将第二条注释创建为document.childNodes中的注释子节点。</div><div class="line">（3）Firefox以及Safari 3.1之前的版本会完全葫芦这两条注释。</div></pre></td></tr></table></figure><p><br>    同样，浏览器间的这种不一致性也导致了位于<html>元素外部的注释没有什么用处。<br></html></p><p><br>    多数情况下，我们都用不着在document对象上调用appendChild()、removeChild()和replaceChild()方法，因为文档类型(如果存在的话)是只读的，而且它只能有一个元素子节点(该节点通常早就已经存在了)。<br></p><h4 id="2-文档信息"><a href="#2-文档信息" class="headerlink" title="2. 文档信息"></a>2. 文档信息</h4><p><br>    作为HTMLDocument的一个实例，document对象还有一些标准的Document对象所没有的属性。这些属性提供了document对象所表现的网页的一些信息。其中第一个属性就是title，包含着<title>元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改title属性的值不会改变<title>元素。来看下面的例子。<br></title></title></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 取得文档标题</div><div class="line">var originalTitle = document.title;</div><div class="line">// 设置文档标题</div><div class="line">document.title = &quot;New page title&quot;;</div></pre></td></tr></table></figure><p><br>    接下来要介绍的3个属性都与对网页的请求有关，它们是URL、domain和referrer。URL属性中包含页面完整的URL(即地址栏中显示的URL)，domain属性中包含页面的域名，而referrer属性中则保存着链接到当前页面的那个页面的URL。在没有来源页面的情况下，referrer属性中可能会包含空字符串。所有这些信息都存在于请求的HTTP头部，只不过是通过这些属性让我们能够在JavaScript中访问它们而已，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 取得完整的URL</div><div class="line">var url = document.URL;</div><div class="line"></div><div class="line">// 取得域名</div><div class="line">var domain = document.domain;</div><div class="line"></div><div class="line">// 取得来源页面的URL</div><div class="line">var referrer = document.referrer;</div></pre></td></tr></table></figure><p><br>    URL与domain属性是相互关联的。例如，如果document.URL等于<a href="http://www.wrox.com/……，那么document.domain就等于www.wrox.com" target="_blank" rel="external">http://www.wrox.com/……，那么document.domain就等于www.wrox.com</a>.<br></p><p><br>    在这3个属性中，只有domain是可以设置的。但由于安全方面的限制，也并非可以给domain设置任何值。如果URL中包含一个子域名，例如p2p.wrox.com，那么就只能将domain设置为wrox.com.不能将这个属性设置为URL中不包含的域，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//假设页面来自 p2p.wrox.com 域</div><div class="line">document.domain = &quot;wrox.com&quot;;       // 成功</div><div class="line">document.domain = &quot;nczonline.net&quot;;  // 出错！</div></pre></td></tr></table></figure><p><br>    当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain就非常方便了。由于跨域安全限制，来自不同子域的页面无法通过JavaScript通信。而通信将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。例如，假设有一个页面加载自www.wrox.com，其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com。由于document.domain字符串不一样，内外两个页面之间无法相互访问对方的JavaScript对象。但如果将这两个页面的document.domain值都设置为wrox.com。它们之间就可以通信了。<br></p><p><br>    浏览器对domain属性还有一个限制，即如果域名一开始是松散的(loose)，那么不能将它再设置为紧绷的(tight)。换句话说，在将document.domain设置为wrox.com之后，就不能再将其设置回p2p.wrox.com，否则将会导致错误，如下面的例子所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//假设页面来自于 p2p.wrox.com 域</div><div class="line">document.domain = &quot;wrox.com&quot;;       //松散的（成功）</div><div class="line">document.domain = &quot;p2p.wrox.com&quot;;   //紧绷的（出错！）</div></pre></td></tr></table></figure><p><br>    所有浏览器中都存在这个限制，但IE8是实现这一限制的最早的IE版本。<br></p><h4 id="3-查找元素"><a href="#3-查找元素" class="headerlink" title="3. 查找元素"></a>3. 查找元素</h4><p><br>    说到最常见的DOM应用，恐怕就要数取得特定的某个或某组元素的引用，然后再执行一些操作了。取得元素的操作可以使用document对象的几个方法来完成。其中，Document类型为此提供了两个方法：getElementById()和getElementByTagName().<br></p><p><br>    第一个方法，getElementById()，接收一个参数：要取得的元素的ID。如果找到相应的元素则返回该元素，如果不存在带有相应ID的元素，则返回null。注意，这里的ID必须与页面中元素的id特性严格匹配，包括大小写。以下面的元素为例。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;myDiv&quot;&gt;Some text&lt;/div&gt;</div><div class="line">可以使用下面的代码取得这个元素：</div><div class="line">var div = document.getElementById(&quot;myDiv&quot;); //取得&lt;div&gt;元素的引用</div></pre></td></tr></table></figure><p><br>    但是，下面的代码在除IE7及更早版本之外的所有浏览器中都将返回null。<br><br>    var div = document.getElementById(“mydiv”); //无效的 ID（在 IE7 及更早版本中可以）<br></p><p><br>    IE8及较低版本不区分ID的大小写，因此“myDiv”和“mydiv”会被看做相同的元素ID。<br></p><p><br>    如果页面中多个元素的ID值相同，getElementById()只返回文档中第一次出现的元素。IE7及较低版本还为此方法添加了一个有意思的“怪癖”：name特性与给定ID匹配的表单元素(input、textarea、button及select)也会被该方法返回。如果有哪个表单元素的name特性等于指定的ID，而且该元素在文档中位于带有给定ID的元素前面，那么IE就会返回哪个表单元素。来看下面的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; name=&quot;myElement&quot; value=&quot;Text field&quot;&gt;</div><div class="line">&lt;div id=&quot;myElement&quot;&gt;A div&lt;/div&gt;</div></pre></td></tr></table></figure><p><br>    基于这段HTML代码，在IE7中调用document.getElementById(“myElement”)，结果会返回input元素；而在其他所有浏览器中，都会返回对div元素的引用。为了避免IE中存在的这个问题，最好的办法是不让表单字段的name特性与其他元素的ID相同。<br></p>]]></content>
      
      
    </entry>
    
  
  
</search>
