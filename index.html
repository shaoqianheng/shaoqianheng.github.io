<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="苟日新 日日新 又日新">
<meta property="og:type" content="website">
<meta property="og:title" content="谦恒-个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="谦恒-个人博客">
<meta property="og:description" content="苟日新 日日新 又日新">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谦恒-个人博客">
<meta name="twitter:description" content="苟日新 日日新 又日新">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>谦恒-个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谦恒-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/函数表达式（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/函数表达式（一）/" itemprop="url">函数表达式（一）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T19:57:28+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><br>    函数表达式是JavaScript中的一个既强大又容易令人困惑的特性。前面介绍过，定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法是这样的。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function functionName(arg0, arg1, arg2) &#123;</div><div class="line">    // 函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    首先是function关键字，然后是函数的名字，这就是指定函数名的方式。Firefox、Safari、Chrome和Opera都给函数定义了一个非标准的name属性，通过这个属性可以访问到给函数指定的名字。这个属性的值永远等于跟在function关键字后面的标识符。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 只在Firefox、Safari、Chrome和Opera有效</div><div class="line">alert(functionName.name);    // &quot;functionName&quot;</div></pre></td></tr></table></figure>
<p><br>    关于函数声明，它的一个重要特征就是函数声明提升(function declaration hoisting)，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sayHi();</div><div class="line">function sayHi() &#123;</div><div class="line">    alert(&quot;Hi!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个例子不会抛出错误，因为在代码执行之前会先读取函数声明。<br></p>

<p><br>    第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var functionName = function(arg0, arg1, arg2) &#123;</div><div class="line">    // 函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。这种情况下创建的函数叫做匿名函数(anonymous function)，因为function关键字后面没有标识符。(匿名函数有时候也叫做拉姆达函数。)匿名函数的name属性是空字符串。<br></p>

<p><br>    函数表达式与其他表达式一样，在使用前必须先赋值。以下代码会导致错误。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sayHi();    // 错误：函数还不存在</div><div class="line">var sayHi = function() &#123;</div><div class="line">    alert(&quot;Hi!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。例如，执行以下代码的结果可能会让人意想不到。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 不要这样做</div><div class="line">if(condition) &#123;</div><div class="line">    function sayHi() &#123;</div><div class="line">        alert(&quot;Hi!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    function sayHi() &#123;</div><div class="line">        alert(&quot;Yo!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    表面上看，以上代码表示在condition为true时，使用一个sayHi()的定义；否则，就使用另一个定义。实际上，这在ECMAScript中属于无效语法，JavaScript引擎会尝试修正错误，将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略condition；Firefox会在condition为true时返回第一个声明。因此这种使用方式很危险，不应该出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 可以这样做</div><div class="line">var sayHi;</div><div class="line"></div><div class="line">if(condition) &#123;</div><div class="line">    sayHi = function() &#123;</div><div class="line">        alert(&quot;Hi!&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125; else &#123;</div><div class="line">    sayHi = function() &#123;</div><div class="line">        alert(&quot;Yo!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个例子不会有什么意外，不同的函数会根据condition被赋值给sayHi。<br></p>

<p><br>    能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。还记得之前中的那个createComparisonFunction()函数吗：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">    return function(object1, object2) &#123;</div><div class="line">        var value1 = object1[propertyName];</div><div class="line">        var value2 = object2[propertyName];</div><div class="line"></div><div class="line">        if(value1 &lt; value2) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125; else if(value1 &gt; value2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    createComparisonFunction()就返回了一个匿名函数。返回的函数可能会被赋值给一个变量，或者以其他方式被调用；不过，在createComparisonFunction()函数内部，它是匿名的。在把函数当成值来使用的情况下，都可以使用匿名函数。不过，这并不是匿名函数唯一的用途。<br></p>

<h3 id="1-1-递归"><a href="#1-1-递归" class="headerlink" title="1.1 递归"></a>1.1 递归</h3><p><br>    递归函数是在一个函数通过名字调用自身的情况下构成的，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if(num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * factorial(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var anotherFactorial = factorial;</div><div class="line">factorial = null;</div><div class="line">alert(anotherFactorial(4));    // 出错！</div></pre></td></tr></table></figure>
<p><br>    以上代码先把factorial()函数保存在变量anotherFactorial中，然后将factorial变量设置为null，结果指向原始函数的引用只剩下一个。但在接下来调用anotherFactorial()时，由于必须执行factorial()，而factorial已经不再是函数，所以就会导致错误。在这种情况下，使用arguments.callee可以解决这个问题。<br></p>

<p><br>    我们知道，arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用，例如。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if(num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    最后一行代码显示，通过使用arguments.callee代替函数名，可以确保无论怎样调用函数都不会出问题。因此，在编写递归函数时，使用arguments.callee总比使用函数名更保险。<br></p>

<p><br>    但在严格模式下，不能通过脚本访问arguments.callee,访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var factorial = (function f(num) &#123;</div><div class="line">    if(num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * f(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正常完成。这种方式在严格模式和非严格模式下都行得通。<br></p>

<h3 id="1-2-闭包"><a href="#1-2-闭包" class="headerlink" title="1.2 闭包"></a>1.2 闭包</h3><p><br>    有不少开发人员总是搞不清匿名函数和闭包这两个概念，因此经常混用。闭包是指有权访问另个一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数，仍以前面的createComparisonFunction()函数为例，注意两个var语句。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">    return function(object1, object2) &#123;</div><div class="line">        var value1 = object1[propertyName];</div><div class="line">        var value2 = object2[propertyName];</div><div class="line"></div><div class="line">        if(value1 &lt; value2) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125; else if(value1 &gt; value2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，var的那两行代码是内部函数(一个匿名函数)中的代码，这两行代码访问了外部函数中的变量propertyName。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可以访问变量propertyName。之所以还能够访问这个变量，是因为内部函数的作用域链中包含createComparisonFunction()的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候都会发生什么入手。<br></p>

<p><br>    了解有关如何创建作用域链以及作用域链有什么作用的细节，对彻底理解闭包至关重要。当某个函数被调用时，会创建一个执行环境(execution context)及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。<br></p>

<p><br>    在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2) &#123;</div><div class="line">    if(value1 &lt; value2) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125; else if(value1 &gt; value2) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">var result = compare(5, 10);</div></pre></td></tr></table></figure>
<p><br>    以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当调用compare()时，会创建一个包含arguments、value1和Value2的活动对象。全局执行环境的变量对象(包括result和compare)在compare()执行环境的作用域链中则处于第二位。图1-1展示了包含上述关系的compare()函数执行时的作用域链。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-7-1.png"></p>
<div style="text-align: center;">图1-1</div>

<p><br>    后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过赋值函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。<br></p>

<p><br>    无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。但是，闭包的情况又有所不同。<br></p>

<p><br>    在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。图1-2展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var compare = createComparisionFunction(&quot;name&quot;);</div><div class="line">var result = compare(&#123;name: &quot;Nicholas&quot;&#125;, &#123;name: &quot;Greg&quot;&#125;);</div></pre></td></tr></table></figure>
<p><br>    在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 创建函数</div><div class="line">var compareNames = createComparisonFunction(&quot;name&quot;);</div><div class="line">// 调用函数</div><div class="line">var result = compareNames(&#123;name: &quot;Nicholas&quot;&#125;, &#123;name: &quot;Greg&quot;&#125;);</div><div class="line">// 解除对匿名函数的引用(以便释放内存)</div><div class="line">compareNames = null;</div></pre></td></tr></table></figure>
<p><br>    首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域(除了全局作用域)也都可以安全地销毁了。图1-2展示了调用compareNames()的过程中产生的作用域链之间的关系。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-7-2.png"></p>
<div style="text-align: center;">图1-2</div>

<blockquote>
<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，我们建议只在绝对必要时再考虑使用闭包。虽然像V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存，但还是要慎重使用闭包。</p>
</blockquote>
<h3 id="1-2-1-闭包与变量"><a href="#1-2-1-闭包与变量" class="headerlink" title="1.2.1 闭包与变量"></a>1.2.1 闭包与变量</h3><p><br>    作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说明这个问题。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createFuntions() &#123;</div><div class="line">    var result = new Array();</div><div class="line"></div><div class="line">    for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">        result[i] = function() &#123;</div><div class="line">            return i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返回自己的索引值，即位置0的函数返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10.因为每个函数的作用域链中都保存着createFunction()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10.但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createFuntions() &#123;</div><div class="line">    var result = new Array();</div><div class="line"></div><div class="line">    for(var i = 0; i &lt; 10; i++) &#123;</div><div class="line">        result[i] = function(num) &#123;</div><div class="line">            return function() &#123;</div><div class="line">                return num;</div><div class="line">            &#125;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在重写了前面的createFunctions()函数后，每个函数就会返回各自不同的索引值了。在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋值给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包。这样一来，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。<br></p>

<h3 id="1-2-1-关于this对象"><a href="#1-2-1-关于this对象" class="headerlink" title="1.2.1 关于this对象"></a>1.2.1 关于this对象</h3><p><br>    在闭包中使用this对象也可能会导致一些问题。我们知道，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。下面来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getNameFun: function() &#123;</div><div class="line">        return function() &#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()());    // &quot;The Window&quot;(在非严格模式下)</div></pre></td></tr></table></figure>
<p><br>    以上代码先创建了一个全局变量name，又创建了一个包含name属性的对象。这个对象还包含一个方法——getNameFunc()，它返回一个匿名函数，而匿名函数又返回this.name.由于getNameFunc()返回一个函数，因此调用object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串。然而，这个例子返回的字符串是”The Window”,即全局name变量的值。为什么匿名函数没有取得其包含作用域(或外部作用域)的this对象呢？<br></p>

<p><br>    前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中this对象保存在一个闭包能够访问到的变量例，就可以让闭包访问该对象了，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;;</div><div class="line"></div><div class="line">    getNameFunc: function() &#123;</div><div class="line">        var that = this;</div><div class="line">        return function() &#123;</div><div class="line">            return that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()());    // &quot;My Object&quot;</div></pre></td></tr></table></figure>
<p><br>    在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因此它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，taht也仍然引用这object，所以调用object.getNameFunc()就返回了“My Object”。<br></p>

<blockquote>
<p>this和arguments也存在同样的问题。如果想访问作用域链中的arguments对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。</p>
</blockquote>
<p><br>    在几种特殊情况下，this的值可能会意外地改变。比如，下面的代码是修改前面例子的结果。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line"></div><div class="line">var object = &#123;</div><div class="line">    name: &quot;My Object&quot;,</div><div class="line">    getName: function() &#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    这里的getName()方法只简单地返回this.name的值。以下是几种调用object.getName()的方式以及各自的结果。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object.getName();    // &quot;My Object&quot;</div><div class="line">(object.getName)();  // &quot;My Object&quot;</div><div class="line">(object.getName = object.getName)();    // &quot;The Window&quot;, 在非严格模式下</div></pre></td></tr></table></figure>
<p><br>    第一行代码跟平常一样调用了object.getName()，返回的是“My Object”，因为this.name就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像是在引用一个函数，但this的值得到了维持，因为object.getName和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this的值不能得到维持，结果就返回了”The Window”。<br></p>

<p><br>    当然，你不大可能会像第二行和第三行代码一样调用这个方法。不过，这个例子有助于说明即使是语法的细微变化，都有可能意外改变this的值。<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/面向对象的程序设计（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/02/面向对象的程序设计（三）/" itemprop="url">面向对象的程序设计（三）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T09:23:54+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-2-4-组合使用构造函数模式和原型模式"><a href="#1-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="1.2.4 组合使用构造函数模式和原型模式"></a>1.2.4 组合使用构造函数模式和原型模式</h3><p><br>    创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line"> constructor: Person,</div><div class="line"> sayName: function() &#123;</div><div class="line">  alert(this.name);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div><div class="line"></div><div class="line">person1.friends.push(&quot;Van&quot;);</div><div class="line">alert(person1.friends);    // &quot;Shelby, Count, Van&quot;</div><div class="line">alert(person2.friends);    // &quot;Shelby, Count&quot;</div><div class="line">alert(person1.friends === person2.friends);    // false</div><div class="line">alert(person1.sayName === person2.sayName);    // true</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。而修改了person1.friends(向其中添加一个新字符串)，并不会影响到person2.friends，因为它们分别引用了不同的数组。<br></p>

<p><br>    这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。<br></p>

<h3 id="1-2-5-动态原型模式"><a href="#1-2-5-动态原型模式" class="headerlink" title="1.2.5 动态原型模式"></a>1.2.5 动态原型模式</h3><p><br>    有其他OO语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的有点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    // 属性</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    // 方法</div><div class="line">    if(typeof this.sayName != &quot;function&quot;) &#123;</div><div class="line">        Person.prototype.sayName = function() &#123;</div><div class="line">            alert(this.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p><br>    注意上面代码的if语句。这里只在sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中，if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if语句检查每个属性和每个方法；只要检查其中一个即可。。对于采用这种模式创建的对象，还可以使用instanceof操作符确定它的类型。<br></p>

<blockquote>
<p>使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>
</blockquote>
<h3 id="1-2-6-寄生构造函数模式"><a href="#1-2-6-寄生构造函数模式" class="headerlink" title="1.2.6 寄生构造函数模式"></a>1.2.6 寄生构造函数模式</h3><p><br>    通常，在前述的几种模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    var o = new Object();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = function() &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">    return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了使用new操作符并使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。<br></p>

<p><br>    这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function SpeicalArray() &#123;</div><div class="line">    // 创建数组</div><div class="line">    var values = new Array();</div><div class="line">    // 添加值</div><div class="line">    values.push.apply(values, arguments);</div><div class="line">    // 添加方法</div><div class="line">    values.toPopedString = function() &#123;</div><div class="line">        return this.join(&quot;|&quot;);</div><div class="line">    &#125;;</div><div class="line">    // 返回数组</div><div class="line">    return values；</div><div class="line">&#125;</div><div class="line"></div><div class="line">var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</div><div class="line">alert(colors.toPipedString());    // &quot;red|blue|green&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们创建了一个名叫SpecialArray的构造函数。在这个函数内部，首先创建了一个数组，然后push()方法(用构造函数接收到的所有参数)初始化了数组的值。随后，又给数组实例添加了一个toPipedString()方法，该方法返回以竖线分割的数组值。最后，将数组以函数值的形式返回。接着，我们调用了SpecialArray构造函数，向其中传入了用于初始化数组的值，此后又调用了toPipedString()方法。<br></p>

<p><br>    关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。<br></p>

<h3 id="1-2-7-稳妥构造函数模式"><a href="#1-2-7-稳妥构造函数模式" class="headerlink" title="1.2.7 稳妥构造函数模式"></a>1.2.7 稳妥构造函数模式</h3><p><br>    道格拉斯·克罗克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中(这些环境中会禁止使用this和new)，或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不引用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    // 创建要返回的对象</div><div class="line">    var o = new Object();</div><div class="line">    // 可以在这里定义私有变量和函数</div><div class="line"></div><div class="line">    // 添加方法</div><div class="line">    o.sayName = function() &#123;</div><div class="line">    	alert(name);</div><div class="line">    &#125;;</div><div class="line">    // 返回对象</div><div class="line">    return o；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法返回name的值。可以像下面使用稳妥的Person构造函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    这样，变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境。<br></p>

<blockquote>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p>
</blockquote>
<h3 id="1-3-继承"><a href="#1-3-继承" class="headerlink" title="1.3 继承"></a>1.3 继承</h3><p><br>    继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。<br></p>

<h3 id="1-3-1-原型链"><a href="#1-3-1-原型链" class="headerlink" title="1.3.1 原型链"></a>1.3.1 原型链</h3><p><br>    ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型有时另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。<br></p>

<p><br>    实现原型链有一种基本模式，其代码大致如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // true</div></pre></td></tr></table></figure>
<p><br>    以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确立了继承关系之后，我们给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如下图所示。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-6-4.png"></p>
<p><br>    在上面的代码中，我们没有使用SubType默认提供的原型，而是给它换了一个新原型；这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向SuperType的原型。最终结果就是这样的：instance指向SubType的原型，SubType的原型又指向SuperType的原型。getSuperValue()方法仍然还在SuperType.prototype中，但property则位于SubType.prototype中。这是因为property是一个实例属性，而getSuperValue()则是一个原型方法。既然SubType.prototype现在是SuperType的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来SubType.prototype中的constructor被重写了的缘故。<br></p>

<p><br>    通过实现原型链，本质上扩展了前面介绍的原型搜索机制。当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤:1) 搜索实例；2) 搜索SubType.prototype；3) 搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。<br></p>

<h4 id="1-别忘记默认的原型"><a href="#1-别忘记默认的原型" class="headerlink" title="1. 别忘记默认的原型"></a>1. 别忘记默认的原型</h4><p><br>    事实上，前面例子中展示的原型链还少了一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层次。下图展示了该例子中完整的原型链。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-6-5.png"></p>
<p><br>    一句话，SubType继承了SuperType，而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法。<br></p>

<h4 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2. 确定原型和实例的关系"></a>2. 确定原型和实例的关系</h4><p><br>    可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。以下几行代码就说明了这一点。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(instance instanceof Object);    // true</div><div class="line">alert(instance instanceof SuperType); // true</div><div class="line">alert(instance instanceof SubType);   // true</div></pre></td></tr></table></figure>
<p><br>    由于原型链的关系，我们可以说instance是Object、SuperType或SubType中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了true。<br></p>

<p><br>    第二种方式是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(Object.prototype.isPrototypeOf(instance));    // true</div><div class="line">alert(SuperType.prototype.isPrototypeOf(instance)); // true</div><div class="line">alert(SubType.prototype.isPrototypeOf(instance));   // true</div></pre></td></tr></table></figure>
<h4 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3. 谨慎地定义方法"></a>3. 谨慎地定义方法</h4><p><br>    子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">// 添加新方法</div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line">// 重写超类型中的方法</div><div class="line">SubType.prototype.getSuperValue = function() &#123;</div><div class="line">    return false;</div><div class="line">&#125;;</div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // false</div></pre></td></tr></table></figure>
<p><br>    在以上代码中，getSubValue()被添加到了SubType中。第二个方法getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个那个方法。这里要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。<br></p>

<p><br>    还有一点需要注意，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">// 使用字面量添加新方法，会导致上一行代码无效</div><div class="line">SubType.prototype = &#123;</div><div class="line">    getSubValue: function() &#123;</div><div class="line">        return this.subproperty;</div><div class="line">    &#125;,</div><div class="line">    someOtherMethod: function() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // error!</div></pre></td></tr></table></figure>
<p><br>    以上代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断——SubType和SuperType之间已经没有关系了。<br></p>

<h4 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h4><p><br>    原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。下列代码可以用来说明这个问题。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType() &#123;&#125;</div><div class="line"></div><div class="line">// 继承SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green, black&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的SuperType构造函数定义了一个colors属性，该属性包含一个数组(引用类型值)。SuperType的每个实例都会有各自包含自己数组的colors属性。当SubType通过原型链继承了SuperType之后，SubType.prototype就变成了SuperType的一个实例，因此它也拥有了一个它自己的colors属性——就跟专门创建了一个SubType.prototype.colors属性一样。但结果是什么呢？结果是SubType的所有实例都会共享这一个colors属性一样。但结果是什么呢？结果是SubType的所有实例都会共享这一个colors属性。而我们对instance1.colors的修改能够通过instance2.colors反映出来，就已经充分证实了这一点。<br></p>

<p><br>    原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。<br></p>

<h3 id="1-3-2-借用构造函数"><a href="#1-3-2-借用构造函数" class="headerlink" title="1.3.2 借用构造函数"></a>1.3.2 借用构造函数</h3><p><br>    在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数，如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType() &#123;</div><div class="line">    // 继承SuperType</div><div class="line">    SuperType.call(this);</div><div class="line">&#125;</div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green&quot;</div></pre></td></tr></table></figure>
<p><br>    代码中加注释（第一个）的那一行代码“借调”了超类型的构造函数。通过使用call()方法(或apply()方法也可以)，我们实际上是在(未来将要)新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都具有自己的colors属性的副本了。<br></p>

<h4 id="1-传递参数"><a href="#1-传递参数" class="headerlink" title="1. 传递参数"></a>1. 传递参数</h4><p><br>    相对于原型链而言，借用构造函数有一个很大的优势，既可以在子类型构造函数中向超类型构造函数传递参数。看下面这个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">function SubType() &#123;</div><div class="line">    // 继承了SuperType，同时还传递了参数</div><div class="line">    SuperType.call(this, &quot;Nicholas&quot;);</div><div class="line">    // 实例属性</div><div class="line">    this.age = 29;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.name);    // &quot;Nicholas&quot;;</div><div class="line">alert(instance.age);     // 29</div></pre></td></tr></table></figure>
<p><br>    以上代码中的SuperType只接受一个参数name，该参数会直接赋给一个属性。在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。<br></p>

<h4 id="2-借用构造函数的问题"><a href="#2-借用构造函数的问题" class="headerlink" title="2. 借用构造函数的问题"></a>2. 借用构造函数的问题</h4><p><br>    如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。<br></p>

<h3 id="1-3-3-组合继承"><a href="#1-3-3-组合继承" class="headerlink" title="1.3.3 组合继承"></a>1.3.3 组合继承</h3><p><br>    组合继承(combination inheritance),有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。下面来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    // 继承属性</div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">// 继承方法</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line">instance1.sayName();        // &quot;Nicholas&quot;</div><div class="line">instance1.sayAge();         // 29</div><div class="line"></div><div class="line">var instance2 = new SubType(&quot;Greg&quot;, 27);</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green&quot;</div><div class="line">instance2.sayName();        // &quot;Greg&quot;</div><div class="line">instance2.sayAge();         // 27</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName().SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge().这样一来，就可以让两个不同的SubType实例既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。<br></p>

<p><br>    组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。<br></p>

<h3 id="1-3-4-原型式继承"><a href="#1-3-4-原型式继承" class="headerlink" title="1.3.4 原型式继承"></a>1.3.4 原型式继承</h3><p><br>    道格拉斯·克罗克福德在2006年写了一篇文章，题为Prototyal Inheritance in JavaScript(JavaScript中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">    function F() &#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = object(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</div><div class="line"></div><div class="line">alert(person.friends);    // &quot;Shelby, Court, Van, Rob, Barbie&quot;</div></pre></td></tr></table></figure>
<p><br>    克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到object()函数中，然后改函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。<br></p>

<p><br>    ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson = Object.create(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = Object.create(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</div><div class="line"></div><div class="line">alert(person.friends);    // &quot;Shelby, Court, Van, Rob, Barbie&quot;</div></pre></td></tr></table></figure>
<p><br>    Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = Object.create(person, &#123;</div><div class="line">    name: &#123;</div><div class="line">        value: &quot;Greg&quot;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name);    // &quot;Greg&quot;</div></pre></td></tr></table></figure>
<p><br>    支持Object.create()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br></p>

<p><br>    在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。<br></p>

<h3 id="1-3-5-寄生式继承"><a href="#1-3-5-寄生式继承" class="headerlink" title="1.3.5 寄生式继承"></a>1.3.5 寄生式继承</h3><p><br>    寄生式(parasitic)继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function createAnother(original) &#123;</div><div class="line">    var clone = object(original);    // 通过调用函数创建一个新对象</div><div class="line">    clone.sayHi = function() &#123;</div><div class="line">        alert(&quot;hi&quot;);</div><div class="line">    &#125;;</div><div class="line">    return clone;    // 返回这个对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，createAnother()函数接收一个参数，也就是将要作为新对象基础的对象。然后，把这个对象(original)传递给object()函数，将返回的结果赋值给clone。再为clone对象添加一个新方法sayHi(),最后返回clone对象。可以像下面这样来使用createAnother()函数：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi();    // &quot;hi&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person的所有属性和方法，而且还有自己的sayHi()方法。<br></p>

<p><br>    在主要考虑对象而不是定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。<br></p>

<blockquote>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
</blockquote>
<h3 id="1-3-6-寄生组合式继承"><a href="#1-3-6-寄生组合式继承" class="headerlink" title="1.3.6 寄生组合式继承"></a>1.3.6 寄生组合式继承</h3><p><br>    前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数；一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。再来看一看下面组合继承的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    SuperType.call(this, name);    // 第二次调用SuperType()</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = new SuperType();    // 第一次调用SuperType()</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    加注释的代码是调用SuperType构造函数的代码。在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。图1-6展示了上述过程。<br></p>

<p><br>    图1-6所示，有两组name和colors属性：一组在实例上，一组在SubType原型中。这就是调用两次SuperType构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。<br></p>

<p><br>    所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType, superType) &#123;</div><div class="line">    var prototype = object(superType.prototype);    // 创建对象</div><div class="line">    prototype.constructor = subType;                // 增强对象</div><div class="line">    subType.prototype = prototype;                  // 指定对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个示例中的inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。最后一步，将新创建的对象(即副本)赋值给子类型的原型。这样，我们就可以用调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://shaoqianheng.github.io/images/h-6-6.png"></p>
<div style="text-align: center;">图1-6</div>

<p><br>    这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf().开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。<br></p>

<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><br>    ECMAScript支持面向对象(OO)编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。<br></p>

<p><br>    (1) 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。<br><br>    (2) 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象(即与对象具有松散耦合的特点)，因此没有理由不在多个对象间共向函数。<br><br>    (3) 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式与原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。<br></p>

<p><br>    JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型的构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合模式，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。<br></p>

<p><br>    此外，还存在下列可供选择的继承模式。<br></p>

<p><br>    (1) 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。<br><br>    (2) 寄生式继承，与原型式继承非常类似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。<br><br>    (3) 寄生组合式继承，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。<br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/01/面向对象的程序设计（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/01/面向对象的程序设计（二）/" itemprop="url">面向对象的程序设计（二）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-01T09:37:24+08:00">
                2017-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="2-原型与in操作符"><a href="#2-原型与in操作符" class="headerlink" title="2.原型与in操作符"></a>2.原型与in操作符</h4><p><br>    有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。看一看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line">alert(&quot;name&quot; in person1);    // true</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // true</div><div class="line">alert(&quot;name&quot; in person1);    // true</div><div class="line"></div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person2.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line">alert(&quot;name&quot; in person2);    // true</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line">alert(&quot;name&quot; in person1);    // true</div></pre></td></tr></table></figure>
<p><br>    在以上代码执行的整个过程中，name属性要么是直接在对象上能访问到的，要么是通过原型访问到的。因此，调用“name” in person1始终都返回true，无论该属性存在于实例还是存在于原型中。同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function hasPrototypeProperty(object, name) &#123;</div><div class="line">    return !object.hasOwnProperty(name) &amp;&amp; (name in object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty()只在属性存在于实例中时才返回true，因此只要in操作符返回true而hasOwnProperty()返回false，就可以确定属性是原型中的属性。下面来看一看上面定义的函数hasPrototypeProperty()的用法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Person();</div><div class="line">alert(hasPrototypeProperty(person, &quot;name&quot;));    // true</div><div class="line"></div><div class="line">person.name = &quot;Greg&quot;;</div><div class="line">alert(hasPrototypeProperty(person, &quot;name&quot;));    // false</div></pre></td></tr></table></figure>
<p><br>    在这里，name属性先是存在于原型中，因此hasPrototypeProperty()返回true。当在实例中重写name属性后，该属性就存在于实例中了，因此hasPrototypeProperty()返回false。即使原型中仍然有name属性，但由于现在实例中也有这个属性，因此原型中的name属性就用不到了。<br></p>

<p><br>    在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性(即将[[Enumerable]]标记为false的属性)的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。<br></p>

<p><br>    IE早期版本的实现中存在一个bug，即屏蔽不可枚举属性的实例属性不会出现在for-in循环中。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">    toString: function() &#123;</div><div class="line">        return &quot;My Object&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">for(var prop in o) &#123;</div><div class="line">    if (prop == &quot;toString&quot;) &#123;</div><div class="line">        alert(&quot;Found toString&quot;);    // 在IE中不会显示</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    当以上代码运行时，应该会显示一个警告框，表明找到了toString()方法。这里的对象o定义了一个名为toString()的方法，该方法屏蔽了原型中(不可枚举)的toString()方法。在IE中，由于其实现认为原型的toString()方法被打上了值为false的[[Enumerable]]标记，因此应该跳过该属性，结果我们就不会看到警告框。该bug会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和valueOf()。ECMAScript 5也将constructor和prototype属性的[[Enumerable]]特性设置为false，但并不是所有浏览器都照此实现。<br></p>

<p><br>    要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var keys = Object.keys(Person.prototype);</div><div class="line">alert(keys);    // &quot;name, age, job, sayName&quot;</div><div class="line"></div><div class="line">var p1 = new Person();</div><div class="line">p1.name = &quot;Rob&quot;;</div><div class="line">p1.age = 31;</div><div class="line">var p1keys = Object(p1);</div><div class="line">alert(p1keys);    // &quot;name, age&quot;</div></pre></td></tr></table></figure>
<p><br>    这里，变量keys中将保存一个数组，数组中是字符串“name”、“age”、“job”和“sayName”。这个顺序也是它们在for-in循环中出现的顺序。如果是通过Person的实例调用，则Object.keys()返回的数组只包含“name”和“age”这两个实例属性。<br></p>

<p><br>    如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var keys = Object.getOwnPropertyNames(Person.prototype);</div><div class="line">alert(keys);    // &quot;constructor, name, age, job, sayName&quot;</div></pre></td></tr></table></figure>
<p><br>    注意结果中包含了不可枚举的constructor属性。Object.keys()和Object.getOwnPropertyNames()方法都可以用来替代for-in循环。支持这两个方法的浏览器有IE9+、Firefox4+、Safari5+、Opera12+和Chrome。<br></p>

<h4 id="3-更简单的原型语法"><a href="#3-更简单的原型语法" class="headerlink" title="3.更简单的原型语法"></a>3.更简单的原型语法</h4><p><br>    前面例子中每添加一个属性和方法就要敲一遍Person.prototype.为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	name: &quot;Nicholas&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;Software Engineer&quot;,</div><div class="line">	sayName: function() &#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    在上面的代码中，我们将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：constructor属性不再指向Person了。前面曾经介绍过，每创建一个函数，就会同时创建它的property对象，这个对象也会自动获得constructor属性。而我们在这里使用的语法，本质上完全重写了默认的property对象，因此constructor属性也就变成了新对象的constructor属性(指向Object构造函数)，不再指向Person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var friend = new Person();</div><div class="line"></div><div class="line">alert(friend instanceof Object);        // true</div><div class="line">alert(friend instanceof Person);        // true</div><div class="line">alert(friend.constructor == Person);    // false</div><div class="line">alert(friend.constructor == Object);    // true</div></pre></td></tr></table></figure>
<p><br>    在此，用instanceof操作符测试Object和Person仍然返回true，但constructor属性则等于Object而不等于Person了。如果constructor的值真的很重要，可以像下面这样特意将它设置回适当的值。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	constructor: Person,</div><div class="line">	name: &quot;Nicholas&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;Software Engineer&quot;,</div><div class="line">	sayName: function() &#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    以上代码特意包含了一个constructor属性，并将它的值设置为Person，从而确保了通过该属性能够访问到适当的值。<br></p>

<p><br>    注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的，因此如果你使用兼容ECMAScript5的JavaScript引擎，可以试一试Object.defineProperty()。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	name: &quot;Nicholas&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;Software Engineer&quot;,</div><div class="line">	sayName: function() &#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">// 重设构造函数，只适用于ECMAScript5兼容的浏览器</div><div class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</div><div class="line">    enumerable: false,</div><div class="line">    value: Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4.原型的动态性"></a>4.原型的动态性</h4><p><br>    由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var friend = new Person();</div><div class="line"></div><div class="line">Person.prototype.sayHi = function() &#123;</div><div class="line">    alert(&quot;hi&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayHi();    // &quot;hi&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码先创建了Person的一个实例，并将其保存在person中。然后，下一条语句在Person.prototype中添加了一个方法sayHi().即使person实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用person.sayHi()时，首先会在实例中搜索名为sayHi的属性，在没有找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在哪里的函数。<br></p>

<p><br>    尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]],而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">var friend = new Person();</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	constructor: Person,</div><div class="line">	name: &quot;Nicholas&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;Software Engineer&quot;,</div><div class="line">	sayName: function() &#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayName();    // error</div></pre></td></tr></table></figure>
<p><br>    在这里例子中，我们先创建了Person的一个实例，然后又重写了其原型对象。然后在调用friend.sayName()时发生了错误，因为friend指向的原型中不包含以该名字命名的属性。下图展示了这个过程的内幕。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-6-3.png"></p>
<p><br>    从上图可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。<br></p>

<h4 id="5-原生对象的原型"><a href="#5-原生对象的原型" class="headerlink" title="5.原生对象的原型"></a>5.原生对象的原型</h4><p><br>    原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型(Object、Array、String,等等)都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(typeof Array.prototype.sort);          // &quot;function&quot;</div><div class="line">alert(typeof String.prototype.sunstring);    // &quot;function&quot;</div></pre></td></tr></table></figure>
<p><br>    通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了一个名为startWith()的方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String.prototype.startsWith = function(text) &#123;</div><div class="line">    return this.indexOf(text) == 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var msg = &quot;Hello world!&quot;;</div><div class="line">alert(msg.startsWith(&quot;Hello&quot;));    // true</div></pre></td></tr></table></figure>
<p><br>    这里新定义的startsWith()方法会在传入的文本位于一个字符串开始时返回true。既然方法被添加了String.prototype,那么当前环境中的所有字符串就都可以调用它。由于msg是字符串，而且后台会调用String基本包装函数创建这个字符串，因此通过msg就可以调用startsWith()方法。<br></p>

<blockquote>
<p>尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法。</p>
</blockquote>
<h4 id="6-原型对象的问题"><a href="#6-原型对象的问题" class="headerlink" title="6.原型对象的问题"></a>6.原型对象的问题</h4><p><br>    原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。<br></p>

<p><br>    原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟(如前面的例子所示)，通过在实例上添加一个同名属性，可以隐藏原型中的对象属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	constructor: Person,</div><div class="line">	name: &quot;Nicholas&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;Software Engineer&quot;,</div><div class="line">	friends: [&quot;Shelby&quot;, &quot;Court&quot;],</div><div class="line">	sayName: function() &#123;</div><div class="line">	    alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.friends.push(&quot;Van&quot;);</div><div class="line"></div><div class="line">alert(person1.friends);    // &quot;Shelby, Court, Van&quot;</div><div class="line">alert(person2.friends);    // &quot;Shelby, Court, Van&quot;</div><div class="line">alert(person1.friends == person2.friends);    // true</div></pre></td></tr></table></figure>
<p><br>    在此，Person.prototype对象有一个名为friends属性，该属性包含一个字符串数组。然后，创建了Person的两个实例。接着，修改了person.friends引用的数组，向数组中添加了一个字符串。由于friends数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2.friends(与person1.friends指向同一个数组)反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果没话可说。可以实例一般都是要有属于自己的全部属性。而这个问题正是我们很少看到有人单独使用原型模式的原因所在.<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/31/面向对象的程序设计（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/31/面向对象的程序设计（一）/" itemprop="url">面向对象的程序设计（一）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-31T09:29:39+08:00">
                2017-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>面向对象(Object-Oriented, OO)的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。</p>
</blockquote>
<p>ECMAScript-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样，我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。</p>
<p>每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。</p>
<h3 id="1-1-理解对象"><a href="#1-1-理解对象" class="headerlink" title="1.1 理解对象"></a>1.1 理解对象</h3><p><br>    曾经介绍过，创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div><div class="line">person.job = &quot;Software Engineer&quot;;</div><div class="line"></div><div class="line">person.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    上面的例子创建了一个名为person的对象，并为它添加了三个属性(name、age和job)和一个方法(sayName())。其中，sayName()方法用于显示this.name(将被解析为person.name)的值。早期的JavaScript开发人员经常使用这个模式创建新对象。几年后，对象字面量成为创建这种对象的首选模式。前面的例子用对象字面量语法可以写成这样：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    age: 29,</div><div class="line">    job: &quot;Software Engineer&quot;,</div><div class="line"></div><div class="line">    sayName: function() &#123;</div><div class="line">    	alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的person对象与前面例子中的person对象是一样的，都有相同的属性和方法。这些属性在创建时都带有一些特征值(characteristic)，JavaScript通过这些特征值来定义它们的行为。<br></p>

<h3 id="1-1-1-属性类型"><a href="#1-1-1-属性类型" class="headerlink" title="1.1.1 属性类型"></a>1.1.1 属性类型</h3><p><br>    ECMA-262第5版在定义只有内部才用的特性(attribute)时，描述了属性(property)的各种特征。ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对方括号中，例如[[Enumerable]]。<br></p>

<p><br>    ECMAScript中有两种属性：数据属性和访问器属性。<br></p>

<h4 id="1-数据属性"><a href="#1-数据属性" class="headerlink" title="1.数据属性"></a>1.数据属性</h4><p><br>    数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(1) [[Configurable]] : 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</div><div class="line"></div><div class="line">(2) [[Enumerable]] : 表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</div><div class="line"></div><div class="line">(3) [[Writable]] : 表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们这个特性默认值为true。</div><div class="line"></div><div class="line">(4) [[Value]] : 包含这个属性的数据值。读取属性值的时候，从这个位置上读，写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</div></pre></td></tr></table></figure>
<p><br>    对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    这里创建了一个名为name的属性，为它指定的值是“Nicholas”。也就是说，[[Value]]特性将被设置为“Nicholas”，而对这个值的任何修改都反映在这个位置。<br></p>

<p><br>    要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符(descriptor)对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对应的特性值。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;；</div><div class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">    writable: false,</div><div class="line">    value: &quot;Nicholas&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div><div class="line">person.name = &quot;Greg&quot;;</div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子创建了一个名为name的属性，它的值“Nicholas”是只读的。这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。<br></p>

<p><br>    类似的规则也适用于不可配置的属性。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">    configurable: false,</div><div class="line">    value: &quot;Nicholas&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div><div class="line">delete person.name;</div><div class="line">alert(person.name);    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用Object.defineProperty()方法修改除了writable之外的特性，都会导致错误：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   var person = &#123;&#125;;</div><div class="line">   Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">       configurable: false,</div><div class="line">       value: &quot;Nicholas&quot;</div><div class="line">   &#125;);</div><div class="line"></div><div class="line">   // 抛出错误</div><div class="line">   Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">   	configurable: true,</div><div class="line">   	value: &quot;Nicholas&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><br>    也就是说，可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。<br></p>

<p><br>    在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功能。不过，理解这些概念对理解JavaScript对象却非常有用。<br></p>

<blockquote>
<p>IE8是第一个实现Object.defineProperty()方法的浏览器版本。然而，这个版本的实现存在诸多限制：只能在DOM对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，建议不要在IE8中使用Object.defineProperty()方法。</p>
</blockquote>
<h4 id="2-访问器属性"><a href="#2-访问器属性" class="headerlink" title="2. 访问器属性"></a>2. 访问器属性</h4><p><br>    访问器属性不包含数据值；它们包含一对getter和setter函数(不过，这两个函数都不是必需的)。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(1) [[Configurable]] : 表示能够通过delete属性删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</div><div class="line"></div><div class="line">(2) [[Enumerable]] : 表示能否通过for-in循环返回属性。对于直接在对象上定义的对象，这个特性的默认值为true。</div><div class="line"></div><div class="line">(3) [[Get]] : 在读取属性时调用的函数。默认值为undefined。</div><div class="line"></div><div class="line">(4) [[Set]] : 在写入属性时调用的函数。默认值为undefined。</div></pre></td></tr></table></figure>
<p><br>    访问器属性不能直接定义，必须使用Object.defineProperty()来定义。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;</div><div class="line">       _year: 2004,</div><div class="line">       edition: 1</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   Object.defineProperty(book, &quot;year&quot;, &#123;</div><div class="line">       get: function() &#123;</div><div class="line">       	return this._year;</div><div class="line">       &#125;,</div><div class="line">       set: function(newValue) &#123;</div><div class="line">       	if (newValue &gt; 2004) &#123;</div><div class="line">       		this._year = newValue;</div><div class="line">       		this.edition += newValue - 2004;</div><div class="line">       	&#125;</div><div class="line">       &#125;	</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = 2005;</div><div class="line">alert(book.edition);    // 2</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了一个book对象，并给它定义了两个默认的属性：_year和edition。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year则包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致_year变成2005，而edition变为2.这是使用访问器属性的常见方式，即设置一个属性会导致其他属性发生变化。<br></p>

<p><br>    不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。<br></p>

<p><br>    支持ECMAScript 5的这个方法的浏览器有IE 9+(IE8只是部分实现)、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器属性，一般都是用两个非标准的方法：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。这两个方法最初由Firefox引入的，后来Safari 3、Chrome 1和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;</div><div class="line">       _year: 2004,</div><div class="line">       edition: 1</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   // 定义访问器的旧有方法</div><div class="line">   book.__defineGetter__(&quot;year&quot;, function() &#123;</div><div class="line">       return this._year;	</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.__defineSetter__(&quot;year&quot;, function(newValue) &#123;</div><div class="line">    if (newValue &gt; 2004) &#123;</div><div class="line">    	this._year = newValue;</div><div class="line">    	this.edition += newValue - 2004;</div><div class="line">    &#125;	</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = 2005;</div><div class="line">alert(book.edition);    // 2</div></pre></td></tr></table></figure>
<p><br>    在不支持Object.defineProperty()方法的浏览器中不能修改[[Configurable]]和[[Enumerable]].<br></p>

<h3 id="1-1-2-定义多个属性"><a href="#1-1-2-定义多个属性" class="headerlink" title="1.1.2 定义多个属性"></a>1.1.2 定义多个属性</h3><p><br>    由于为对象定义多个属性的可能性很大，ECMAScript 5有定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;&#125;;</div><div class="line"></div><div class="line">   Object.defineProperties(book, &#123;</div><div class="line">   	_year: &#123;</div><div class="line">   		value: 2004</div><div class="line">   	&#125;,</div><div class="line">   	edition: &#123;</div><div class="line">   		value: 1</div><div class="line">   	&#125;,</div><div class="line">   	year: &#123;</div><div class="line">   		get: function() &#123;</div><div class="line">   			return this._year;</div><div class="line">   		&#125;,</div><div class="line">   		set: function(newValue) &#123;</div><div class="line">   			if(newValue &gt; 2004) &#123;</div><div class="line">   				this._year = newValue;</div><div class="line">   				this.edition += newValue - 2004;</div><div class="line">   			&#125;</div><div class="line">   		&#125;</div><div class="line">   	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><br>    以上代码在book对象上定义了两个数据属性(_year和edition)和一个访问器属性(year).最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。<br></p>

<p><br>    支持Object.defineProperties()方法的浏览器有IE 9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br></p>

<h3 id="1-1-3-读取属性的特性"><a href="#1-1-3-读取属性的特性" class="headerlink" title="1.1.3 读取属性的特性"></a>1.1.3 读取属性的特性</h3><p><br>    使用ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">   var book = &#123;&#125;;</div><div class="line"></div><div class="line">   Object.defineProperties(book, &#123;</div><div class="line">       _year: &#123;</div><div class="line">       	value: 2004</div><div class="line">       &#125;,</div><div class="line">       edition: &#123;</div><div class="line">       	value: 1</div><div class="line">       &#125;,</div><div class="line">       year: &#123;</div><div class="line">       	get: function() &#123;</div><div class="line">       		return this._year;</div><div class="line">       	&#125;,</div><div class="line">       	set: function(newValue) &#123;</div><div class="line">       		if(newValue &gt; 2004) &#123;</div><div class="line">       			this._year = newValue;</div><div class="line">       			this.edition += newValue - 2004;</div><div class="line">       		&#125;</div><div class="line">       	&#125;</div><div class="line">       &#125;	</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);</div><div class="line">alert(descriptor.value);           // 2004</div><div class="line">alert(descriptor.configurable);    // false</div><div class="line">   alert(typeof descriptor.get);      // &quot;undefined&quot;</div><div class="line"></div><div class="line">   var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);</div><div class="line">   alert(descriptor.value);          // undefined</div><div class="line">   alert(descriptor.enumerable);     // false</div><div class="line">   alert(typeof descriptor,get);     // &quot;function&quot;</div></pre></td></tr></table></figure>
<p><br>    对于数据属性_year,value等于最初的值，configurable是false，而get等于undefined。对于访问器属性year，value等于undefined，enumerable是false，而get是一个指向getter函数的指针。<br></p>

<p><br>    在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br></p>

<h3 id="1-2-创建对象"><a href="#1-2-创建对象" class="headerlink" title="1.2 创建对象"></a>1.2 创建对象</h3><blockquote>
<p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
</blockquote>
<h3 id="1-2-1-工厂模式"><a href="#1-2-1-工厂模式" class="headerlink" title="1.2.1 工厂模式"></a>1.2.1 工厂模式</h3><p><br>    工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age, job) &#123;</div><div class="line">    var o = new Object();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = function() &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">    return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure>
<p><br>    函数createPerson()能够根据接受的参数来创建一个包含所有必要信息的Person对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)。随着JavaScript的发展，又一个新模式出现了。<br></p>

<h3 id="1-2-2-构造函数模式"><a href="#1-2-2-构造函数模式" class="headerlink" title="1.2.2 构造函数模式"></a>1.2.2 构造函数模式</h3><p><br>    ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = function() &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，Person()函数取代了createPerson()函数。我们注意到，Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：<br>    (1) 没有显式地创建对象；<br>    (2) 直接将属性和方法赋给了this对象；<br>    (3) 没有return语句。<br></p>

<p><br>    此外，还应该注意到函数名Person使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别于ECMAScript中的其他函数；因此构造函数本身也是函数，只不过可以用来创建对象而已。<br></p>

<p><br>    要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：<br>    (1) 创建一个新对象；<br>    (2) 将构造函数的作用域赋给新对象(因此this就指向了这个新对象)；<br>    (3) 执行构造函数中的代码(为这个新对象添加属性)；<br>    (4) 返回新对象。<br></p>

<p><br>    在前面例子的最后，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor(构造函数)属性，该属性指向Person，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person1.constructor == Person);    // true</div><div class="line">alert(person2.constructor == Person);    // true</div></pre></td></tr></table></figure>
<p><br>    对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object的实例，同时也是Person的实例，这一点通过instanceof操作符可以得到验证。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(person1 instanceof Object);    // true</div><div class="line">alert(person1 instanceof Person);    // true</div><div class="line">alert(person2 instanceof Object);    // true</div><div class="line">alert(person2 instanceof Person);    // true</div></pre></td></tr></table></figure>
<p><br>    创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，person1和person2之所以同时是Object的实例，是因为所有对象均继承自Object。<br></p>

<blockquote>
<p>以这种方式定义的构造函数是定义在Global对象(在浏览器中是window对象)中的。</p>
</blockquote>
<h4 id="1-将构造函数当作函数"><a href="#1-将构造函数当作函数" class="headerlink" title="1. 将构造函数当作函数"></a>1. 将构造函数当作函数</h4><p><br>    构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义的Person()函数可以通过下列任何一种方式来调用。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 当作构造函数使用</div><div class="line">var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">person.sayName();    // &quot;Nicholas&quot;</div><div class="line"></div><div class="line">// 作为普通函数调用</div><div class="line">Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);    // 添加到window</div><div class="line">window.sayName();    // &quot;Greg&quot;</div><div class="line"></div><div class="line">// 在另一个对象的作用域中调用</div><div class="line">var o = new Object();</div><div class="line">Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);</div><div class="line">o.sayName();    // &quot;Kristen&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的前两行代码展示了构造函数的典型用法，即使用new操作符来创建一个新对象。接下来的两行代码展示了不使用new操作符调用Person()会出现什么结果：属性和方法都被添加给window对象了。当在全局作用域中调用一个函数时，this对象总是指向Global对象(在浏览器中就是window对象)。因此，在调用完函数之后，可以通过window对象来调用sayName()方法，并且还返回“Greg”。最后，也可以使用call()(或者apply())在某个特殊对象的作用域中调用Person()函数。这里是在对象o的作用域中调用的，因此调用后o就拥有了所有属性和sayName()方法。<br></p>

<h4 id="2-构造函数的问题"><a href="#2-构造函数的问题" class="headerlink" title="2. 构造函数的问题"></a>2. 构造函数的问题</h4><p><br>    构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了——ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = new Funtion(&quot;alert(this.name&quot;);    // 与声明函数在逻辑上是等价的</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例(以显示name属性)的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以证明这一点。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName == person2.sayName);    // false</div></pre></td></tr></table></figure>
<p><br>    然而，创建两个完成同样任务的Function实例的确没有必要；况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转义到构造函数外来解决这个问题。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sayName() &#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们把sayName()函数的定义转移到了构造函数的外部。而在构造函数内部，我们将sayName属性设置成等于全局的sayName函数。这样一来，由于sayName包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用域中定义的同一个sayName()函数。这样做确实解决了两个函数做同一件事的问题，可是新的问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型模式来解决。<br></p>

<h3 id="1-2-3-原型模式"><a href="#1-2-3-原型模式" class="headerlink" title="1.2.3 原型模式"></a>1.2.3 原型模式</h3><p><br>    我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话来说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName();    // &quot;Nicholas&quot;</div><div class="line"></div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName();    // &quot;Nicholas&quot;</div><div class="line"></div><div class="line">alert(person1.sayName == person2.sayName);    // true</div></pre></td></tr></table></figure>
<p><br>    在此，我们将sayName()方法和所有属性直接添加到了Person的prototype属性中。构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。<br></p>

<h4 id="1-理解原型对象"><a href="#1-理解原型对象" class="headerlink" title="1.理解原型对象"></a>1.理解原型对象</h4><p><br>    无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br></p>

<p><br>    创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]].虽然在脚本中没有标准的方式访问[[Prototype]],但Firefox、Safari和Chrome在每个对象上都支持一个属性<strong>proto</strong>;而在其他实现中，这个属性对脚本则是完全可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。<br></p>

<p><br>    以前面使用Person构造函数和Person.prototype创建实例的代码为例，图1-1展示了各个对象之间的关系。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-6-1.png"></p>
<p><br>    图1-1展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。<br></p>

<p><br>    虽然在所有实现中都无法访问[[Prototype]],但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象(Person.prototype),那么这个方法就返回true，如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Person.prototype.isPrototypeOf(person1));    // true</div><div class="line">alert(Person.prototype.isPrototypeOf(person2));    // true</div></pre></td></tr></table></figure>
<p><br>    这里，我们用原型对象的isPrototypeOf()方法测试了person1和person2.因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。<br></p>

<p><br>    ECMAScript 5增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Object.getPrototypeOf(person1) == Person.prototype);    // true</div><div class="line">alert(Object.getPrototypeOf(person1).name);    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    这里的第一行代码只是确定Object.getPrototypeOf()返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中name属性的值，也就是“Nicholas”。使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。支持这个方法的浏览器有IE 9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。<br></p>

<p><br>    每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName()的时候，会先后执行两次搜索。首先，解析器会问：“实例person1有sayName属性吗？”答：“没有”。然后，它继续搜索，再问：“person1的原型有sayName属性吗？”答：“有”。于是，它就读取那个保存在原型对象中的函数。当我们调用person2.sayName()时，将会重现相同的搜索过程，得到相同的结果，而这正是多个对象实例共享原型所包存的属性和方法的基本原理。<br></p>

<blockquote>
<p>前面提到过，原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问。</p>
</blockquote>
<p><br>    虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div></pre></td></tr></table></figure>
<p><br>    在这里例子中，person1的name被一个新值给屏蔽了。但无论访问person1.name还是访问person2.name都能够正常地返回值，即分别是“Greg”(来自对象实例)和“Nicholas”(来自原型)。当在alert()中访问person1.name时，需要读取它的值，因此就会在这个实例上搜索一个名为name的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当以同样的方式访问person2.name时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了name属性。<br></p>

<p><br>    当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);    // &quot;Nicholas&quot;——来自原型</div></pre></td></tr></table></figure>
<p><br>    在这个修改后的例子中，我们使用delete操作符删除了person1.name，之前它保存的“Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中name属性的连接。因此，接下来再调用person1.name是，返回的就是原型中name属性的值了。<br></p>

<p><br>    使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法(不要忘了它是从Object继承来的)只在给定属性存在于实例中时，才会返回true。来看下面这个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name);    // &quot;Greg&quot;——来自实例</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // true</div><div class="line"></div><div class="line">alert(person2.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person2.hasOwnProperty(&quot;name&quot;));    // false</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);    // &quot;Nicholas&quot;——来自原型</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));    // false</div></pre></td></tr></table></figure>
<p><br>    通过使用hasOwnProperty()方法，什么时候访问的是实例属性，什么时候访问的是原型属性就一清二楚了。调用person1.hasOwnProperty(“name”)时，只有当person1重写name属性后才会返回true，因为只有这时候name才是一个实例属性，而非原型属性。图1-2展示了上面例子在不同情况下的实现与原型的关系(为了简单起见，图中省略了与Person构造函数的关系).<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-6-2.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/引用类型（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/30/引用类型（三）/" itemprop="url">引用类型（三）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T09:10:54+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><br>    当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必须的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。<br></p>

<p><br>    Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = new Object(&quot;some text&quot;);</div><div class="line">alert(obj instanceof String);   // true</div></pre></td></tr></table></figure>
<p><br>    把字符串传给Object构造函数，就会创建String的实例；而传入数值参数会得到Number的实例，传入布尔值参数就会得到Boolean的实例。<br></p>

<p><br>    要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var value = &quot;25&quot;;</div><div class="line">var number = Number(value);    // 转型函数</div><div class="line">alert(typeof number);          // &quot;number&quot;</div><div class="line"></div><div class="line">var obj = new Number(value);   // 构造函数</div><div class="line">alert(typeof obj);             // &quot;object&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，变量number中保存的是基本类型的值25，而变量obj中保存的是Number的实例。<br></p>

<p><br>    尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。<br></p>

<h3 id="1-5-1-Boolean类型"><a href="#1-5-1-Boolean类型" class="headerlink" title="1.5.1 Boolean类型"></a>1.5.1 Boolean类型</h3><p><br>    Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true或false。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var booleanObject = new Boolean(true);</div></pre></td></tr></table></figure>
<p><br>    Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false。可是，Boolean对象在ECMAScript中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是布尔表达式中使用Boolean对象，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var falseObject = new Object(false);</div><div class="line">var result = falseObject &amp;&amp; true;</div><div class="line">alert(result);    // true</div><div class="line"></div><div class="line">var falseValue = false;</div><div class="line">result = falseValue &amp;&amp; true;</div><div class="line">alert(result);    // false</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们使用false值创建了一个Boolean对象。然后，将这个对象与基本类型值true构成了逻辑与表达式。在布尔运算中，false &amp;&amp; true等于false。可是，示例中的这行代码是对falseObject对象而不是对它的值(false)进行求值。前面讨论过，布尔表达式中的所有对象都会被转换为true，因此falseObject对象在布尔表达式中代表的是true。结果，true &amp;&amp; true当然就等于true了。<br></p>

<p><br>    基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(typeof falseObject);    // object</div><div class="line">alert(typeof falseValue);     // boolean</div><div class="line">alert(falseObject instanceof Boolean);    // true</div><div class="line">alert(falseValue instanceof Boolean);     // false</div></pre></td></tr></table></figure>
<p><br>    理解基本类型的布尔值与Boolean对象之间的区别非常重要——当然，建议是永远不要使用Boolean对象。<br></p>

<h3 id="1-5-2-Number类型"><a href="#1-5-2-Number类型" class="headerlink" title="1.5.2 Number类型"></a>1.5.2 Number类型</h3><p><br>    Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递相应的数值。下面是一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var numberObject = new Number(10);</div></pre></td></tr></table></figure>
<p><br>    与Boolean类型一样，Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。我们可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString());    // &quot;10&quot;</div><div class="line">alert(num.toString(2));   // &quot;1010&quot;</div><div class="line">alert(num.toString(8));   // &quot;12&quot;</div><div class="line">alert(num.toString(10));  // &quot;10&quot;</div><div class="line">alert(num.toString(16));  // &quot;a&quot;</div></pre></td></tr></table></figure>
<p><br>    除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toFixed(2));    // &quot;10.00&quot;</div></pre></td></tr></table></figure>
<p><br>    这里给toFixed()方法传入了数值2，意思是显示几位小数。于是，这个方法返回了“10.00”，即以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就舍入，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10.005;</div><div class="line">alert(num.toFixed(2));    // &quot;10.01&quot;</div></pre></td></tr></table></figure>
<p><br>    能够自动舍入的特性，使得toFixed()方法很适合处理货币值。但需要注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同。在给toFixed()传入0的情况下，IE8及之前版本不能正确舍入范围在{(-0.94, -0.5], [0.5, 0.94)}之间的值。对于这个范围内的值，IE会返回0，而不是-1或1；其他浏览器都能返回正确的值。IE9修复了这个问题。<br></p>

<blockquote>
<p>toFixed()方法可以表示带有0到20个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数。</p>
</blockquote>
<p><br>    另外可用于格式化数值的方法是toExponential()，该方法返回以指数表示法(也称e表示法)表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数。看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toExponential(1));    // &quot;1.0e+1&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码输出了“1.0e+1”;不过，这么小的数值一般不必使用e表示法。如果你想得到表示某个数值的最合适的格式，就应该使用toPrecision()方法，<br></p>

<p><br>    对于一个数值来说，toPrecision()方法可能会返回固定大小(fixed)格式，也可能返回指数(exponential)格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数(不包括指数部分)。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var num = 99;</div><div class="line">alert(num.toPrecision(1));    // &quot;1e+2&quot;</div><div class="line">alert(num.toPrecision(2));    // &quot;99&quot;</div><div class="line">alert(num.toPrecision(3));    // &quot;99.0&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码首先完成的任务是以一位数来表示99，结果是“1e+2”,即100.因为一位数无法准确地表示99，因此toPrecision()就将它向上舍入为100，这样就可以使用一位数来表示它。而接下来的用两位数表示99，当然还是“99”。最后，在想以三位数表示99时，toPrecision()方法返回“99.0”。实际上，toPrecision()会根据要处理的数值决定到底是调用toFixed()还是调用toExponential()。而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。<br></p>

<blockquote>
<p>toPrecision()方法可以表现1到21位小数。某些浏览器支持的范围更大，但这是典型实现的范围。</p>
</blockquote>
<p><br>    与Boolean对象类似，Number对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化Number类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var numberObject = new Number(10);</div><div class="line">var numberValue = 10;</div><div class="line">alert(typeof numberObject);    // &quot;object&quot;</div><div class="line">alert(typeof numberValue);     // &quot;object&quot;</div><div class="line">alert(numberObject instanceof Number);    // true</div><div class="line">alert(numberValue instanceof Number);     // false</div></pre></td></tr></table></figure>
<p><br>    在使用typeof操作符测试基本类型数值时，始终会返回“number”，而在测试Number对象时，则会返回“object”。类似地，Number对象时Number类型的实例，而基本类型的数值则不是。<br></p>

<h3 id="1-5-3-String类型"><a href="#1-5-3-String类型" class="headerlink" title="1.5.3 String类型"></a>1.5.3 String类型</h3><p><br>    String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var stringObject = new String(&quot;hello world&quot;);</div></pre></td></tr></table></figure>
<p><br>    String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocaleString()和toString()方法，都返回对象所表示的基本字符串值。<br></p>

<p><br>    String类型的每个实例都有一个length属性，表示字符串中包含多个字符。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.length);    // &quot;11&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子输出了字符串“hello world”中的字符数量，即“11”。应该注意的是，即使字符串中包含双字节字符(不是占一个字节的ASCII字符)，每个字符也仍然算一个字符。<br></p>

<p><br>    String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。<br></p>

<p>####1、字符方法</p>
<p><br>    两个用于访问字符串中特定字符的方法是：charAt()和chatCodeAt()。这两个方法都接收一个参数，即基于0的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符(ECMAScript中没有字符类型)。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charAt(1));    // &quot;e&quot;</div></pre></td></tr></table></figure>
<p><br>    字符串“hello world”位置1处的字符是“e”，因此调用charAt(1)就返回了“e”。如果你想得到的不是字符而是字符编码，那么就像下面这样使用charCodeAt()了。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charCodeAt(1));    // 输出&quot;101&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子输出的是“101”，也就是小写字母“e”的字符编码。<br></p>

<p><br>    ECMAScript 5还定义了另一个访问个别字符的方法，在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue(1));    // &quot;e&quot;</div></pre></td></tr></table></figure>
<p><br>    使用方括号表示法访问个别字符的语法得到了IE8及Firefox、Safari、Chrome和Opera所有版本的支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值(尽管根本不是特殊的undefined值)。<br></p>

<h4 id="2、字符串操作方法"><a href="#2、字符串操作方法" class="headerlink" title="2、字符串操作方法"></a>2、字符串操作方法</h4><p><br>    下面介绍与操作字符串有关的几个方法。第一个就是concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。先来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello &quot;;</div><div class="line">var result = stringValue.concat(&quot;world&quot;);</div><div class="line">alert(result);         // &quot;hello world&quot;</div><div class="line">alert(stringValue);    // &quot;hello&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，通过stringValue调用concat()方法返回的结果是“hello world”——但stringValue的值则保持不变。实际上，concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。再看一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello &quot;;</div><div class="line">var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);</div><div class="line"></div><div class="line">alert(result);        // &quot;hello world!&quot;</div><div class="line">alert(stringValue);   // &quot;hello&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子将“world”和“！”拼接到了“hello”的末尾。虽然concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符(+)。而且，使用加号操作符在大多数情况下都比使用concat()方法要简便易行(特别是在拼接多个字符串的情况下)。<br></p>

<p><br>    ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(3));        // &quot;lo world&quot;</div><div class="line">alert(stringValue.substring(3));    // &quot;lo world&quot;</div><div class="line">alert(stringValue.substr(3));       // &quot;lo world&quot;</div><div class="line">alert(stringValue.slice(3, 7));     // &quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, 7)); // &quot;lo w&quot;</div><div class="line">alert(stringValue.substr(3, 7));    // &quot;lo worl&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子比较了以相同方式调用slice()、substr()和substring()得到的结果，而且多数情况下的结果是相同的。在只指定一个参数3的情况下，这三个方法都返回“lo world”，因为“hello”中的第二个“1”处于位置3.而在指定两个参数3和7的情况下，slice()和substring()返回“lo w”(“world”中的“o”处于位置7，因此结果中不包含“o”)，但substr()返回“lo worl”，因为它的第二个参数指定的是要返回的字符个数.<br></p>

<p><br>    在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.下面来看例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(-3));    // &quot;rld&quot;</div><div class="line">alert(stringValue.substring(-3));    // &quot;hello world&quot;</div><div class="line">alert(stringValue.substr(-3));       // &quot;rld&quot;</div><div class="line">alert(stringValue.slice(3, -4));     // &quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, -4)); // &quot;hel&quot;</div><div class="line">alert(stringValue.substr(3, -4));    // &quot;&quot;(空字符串)</div></pre></td></tr></table></figure>
<p><br>    这个例子清晰地展示了上述三个方法之间的不同行为。在给slice()和substr()传递一个负值参数时，它们的行为相同。这是因为-3会被转换为8(字符串长度加参数11+(-3)=8),实际上相当于调用slice(8)和substr(8).但substring()方法则返回了全部字符串，因为它将-3转换成了0.<br></p>

<blockquote>
<p>IE的JavaScript实现在处理向substr()方法传递负值的情况时存在问题，它会返回原始的字符串。IE9修复了这个问题。</p>
</blockquote>
<p><br>    当第二个参数是负值时，这三个方法的行为各不相同。slice()方法会把第二个参数转换为7，这就相当于调用了slice(3, 7),因此返回“lo w”。substring()方法会把第二个参数转换为0，使调用变成了substring(3, 0),而由于这个方法将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了substring(0, 3).substr()也会将第二个参数转换为0，这也就意味着返回包含零个字符的字符串，也就是一个空字符串。<br></p>

<h4 id="3、字符串位置方法"><a href="#3、字符串位置方法" class="headerlink" title="3、字符串位置方法"></a>3、字符串位置方法</h4><p><br>    有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf().这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置(如果没有找到该字符串，则返回-1)。这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。还是来看一个例子吧。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;));        // 4</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));    // 7</div></pre></td></tr></table></figure>
<p><br>    子字符串“o”第一次出现的位置是4，即“hello”中的“o”；最后一次出现的位置是7，即“world”中的“o”。如果“o”在这个字符串中仅出现了一次，那么indexOf()和lastIndexOf()会返回相同的位置值。<br></p>

<p><br>    这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;, 6));        // 7</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6));    // 4</div></pre></td></tr></table></figure>
<p><br>    在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于indexOf()是从位置6(字母”w”)开始向后搜索，结果在位置7找到了“o”，因此它返回7.而lastIndexOf()是从位置6开始向前搜索。结果找到了“hello”中的“o”，因此它返回4.在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;</div><div class="line">var positions = new Array();</div><div class="line">var pos = stringValue.indexOf(&quot;e&quot;);</div><div class="line"></div><div class="line">while(pos &gt; -1) &#123;</div><div class="line">	positions.push(pos);</div><div class="line">	pos = stringValue.indexOf(&quot;e&quot;, pos + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(positions);    // &quot;3, 24, 32, 35, 52&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子通过不断增加indexOf()方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找到了“e”在字符串中的初始位置；而进入循环之后，则每次都给indexOf()传递上一次的位置加1.这样，就确保了每次新搜索都从上一次找到的子字符串的后面开始。每次搜索返回的位置依次被保存在数组positions中，以便将来使用。<br></p>

<h4 id="4-trim-方法"><a href="#4-trim-方法" class="headerlink" title="4.trim()方法"></a>4.trim()方法</h4><p><br>    ECMAScript 5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;   hello world    &quot;;</div><div class="line">var trimmedStringValue = stringValue.trim();</div><div class="line">alert(stringValue);           // &quot;    hello world   &quot;</div><div class="line">alert(trimmedStringValue);    // &quot;hello world&quot;</div></pre></td></tr></table></figure>
<p><br>    由于trim()返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。此外，Firefox 3.5+、Safari 5+和Chrome 8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。<br></p>

<h4 id="5、字符串大小写转换方法"><a href="#5、字符串大小写转换方法" class="headerlink" title="5、字符串大小写转换方法"></a>5、字符串大小写转换方法</h4><p><br>    接下来要介绍的是一组与大小写转换有关的方法。ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase().其中，toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语)会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.toLocaleUpperCase());    // &quot;HELLO WORLD&quot;</div><div class="line">alert(stringValue.toUpperCase());          // &quot;HELLO WORLD&quot;</div><div class="line">alert(stringValue.toLocaleLowerCase());    // &quot;hello world&quot;</div><div class="line">alert(stringValue.toLowerCase());          // &quot;hello world&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码调用的toLocaleUpperCase()和toUpperCase()都返回了“HELLO WORLD”，就像调用toLocaleLowerCase()和toLowerCase()都返回“hello world”一样。一般来说，在不知道自己的代码将在那种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。<br></p>

<h4 id="6、字符串的模式匹配方法"><a href="#6、字符串的模式匹配方法" class="headerlink" title="6、字符串的模式匹配方法"></a>6、字符串的模式匹配方法</h4><p><br>    String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pattern = /.at/;</div><div class="line"></div><div class="line">// 与pattern.exec(text)相同</div><div class="line">var matches = text.match(pattern);</div><div class="line">alert(matches.index);        // 0</div><div class="line">alert(matches[0]);           // &quot;cat&quot;</div><div class="line">alert(pattern.lastIndex);    // 0</div></pre></td></tr></table></figure>
<p><br>    本例中的match()方法返回了一个数组；如果是调用RegExp对象的exec()方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串。<br></p>

<p><br>    另一个用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中的第一个匹配项的索引；如果没有找到匹配项，则返回-1.而且，search()方法始终是从字符串的开头向后查找模式。看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pos = text.search(/at/);</div><div class="line">alert(pos);    // 1</div></pre></td></tr></table></figure>
<p><br>    这个例子中的search()方法返回1，即“at”在字符串中第一次出现的位置。<br></p>

<p><br>    为了简化替换子字符串的操作，ECMAScript提供了replace()方法。这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串(这个字符串不会被转换成正则表达式)，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局(g)标志，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var result = text.replace(&quot;at&quot;, &quot;ond&quot;);</div><div class="line">alert(result);    // &quot;cond, bat, sat, fat&quot;</div><div class="line"></div><div class="line">result = text.replace(/at/g, &quot;ond&quot;);</div><div class="line">alert(result);    // &quot;cond, bond, sond, fond&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，首先传入replace()方法的是字符串“at”和替换用的字符串“ond”。替换的结果是把“cat”变成了“cond”，但字符串中的其他字符并没有受到影响。然后，通过将第一个参数修改为带有全局标志的正则表达式，就将全部“at”都替换成了“ond”。<br></p>

<p><br>    如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">字符序列       替换文本</div><div class="line">$$             $</div><div class="line">$&amp;             匹配整个模式的子字符串。与RegExp.lastMatch的值相同</div><div class="line">$&apos;             匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</div><div class="line">$`             匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</div><div class="line">$n             匹配第n个捕获组的子字符串，其中n等于0-9.例如，$1是匹配第一个捕获组的子字符串，$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</div><div class="line">$nn            匹配第nn个捕获组的子字符串，其中nn等于01-99.例如，$01是匹配第一个捕获组的子字符串，$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</div></pre></td></tr></table></figure>
<p><br>    通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">result = text.replace(/(.at)/g, &quot;word ($1)&quot;);</div><div class="line">alert(result);    // word(cat), word(bat), word(sat), word(fat)</div></pre></td></tr></table></figure>
<p><br>    在此，每个以“at”结尾的单词都被替换了，替换结果是“word”后跟一对圆括号，而圆括号中是被字符序列$1所替换的单词。<br></p>

<p><br>    replace()方法的第二个参数也可以是一个函数。在只有一个匹配项(即与模式匹配的字符串)的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作，请看下面这个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function htmlEscape(text) &#123;</div><div class="line">    return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText) &#123;</div><div class="line">        switch(match) &#123;</div><div class="line">            case &quot;&lt;&quot;:</div><div class="line">                return &quot;&amp;lt;&quot;;</div><div class="line">            case &quot;&gt;&quot;:</div><div class="line">                return &quot;&amp;gt;&quot;;</div><div class="line">            case &quot;&amp;&quot;:</div><div class="line">                return &quot;&amp;amp;&quot;;</div><div class="line">            case &quot;\&quot;&quot;:</div><div class="line">                return &quot;&amp;quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(htmlEscape(&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;));</div><div class="line">// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</div></pre></td></tr></table></figure>
<p><br>    这里，我们为插入HTML代码定义了函数htmlEscape()，这个函数能够转义4个字符：小于号、大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定HTML实体的函数。<br></p>

<p><br>    最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方法不会将字符串看成正则表达式)。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colorText = &quot;red, blue, green, yellow&quot;;</div><div class="line">var colors1 = colorText.split(&quot;,&quot;);    // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</div><div class="line">var colors2 = colorText.split(&quot;,&quot;, 2); // [&quot;red&quot;, &quot;blue&quot;]</div><div class="line">var colors3 = colorText.split(/[^\,]+/);    // [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，colorText是逗号分隔的颜色名字符串。基于该字符串调用split(“,”)会得到一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可以为split()方法传递第二个参数2.最后，通过使用正则表达式，还可以取得包含逗号字符的数组。需要注意的是，在最后一次调用split()返回的数组中，第一项和最后一项是两个空字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头(即子字符串“red”)和末尾(即子字符串“yellow”)。<br></p>

<p><br>    对split()中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1) IE8及之前版本会忽略捕获组。ECMAScript-262规定应该把捕获组拼接到结果数组中。IE9中能正确地在结果中捕获组。</div><div class="line">2) Firefox 3.6及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262规定没有匹配项的捕获组在结果数组中应该用undefined表示。</div></pre></td></tr></table></figure>
<p><br>    在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览器下多做一些测试。<br></p>

<h4 id="7-localeCompare-方法"><a href="#7-localeCompare-方法" class="headerlink" title="7.localeCompare()方法"></a>7.localeCompare()方法</h4><p><br>    与操作字符串有关的最后一个方法是localeCompare(),这个方法比较两个字符串，并返回下列值中的一个：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数(大多数情况下是-1，具体的值要视实现而定)；</div><div class="line">2) 如果字符串等于字符串参数，则返回0；</div><div class="line">3) 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是1，具体的值同样要视实现而定)。</div></pre></td></tr></table></figure>
<p><br>    下面是几个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;yellow&quot;;</div><div class="line">alert(stringValue.localeCompare(&quot;brick&quot;));    // 1</div><div class="line">alert(stringValue.localeCompare(&quot;yellow&quot;));   // 0</div><div class="line">alert(stringValue.localeCompare(&quot;zoo&quot;));      // -1</div></pre></td></tr></table></figure>
<p><br>    这个例子比较了字符串“yellow”和另外几个值：“brick”、“yellow”和“zoo”。因为“brick”在字母表中排在“yellow”之前，所以localeCompare()返回1；而“yellow”等于“yellow”，所以localeCompare()返回了0；最后，“zoo”在字母表中排在“yellow”后面，所以localeCompare()返回了-1.再强调一次，因为localeCompare()返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function determineOrder(value) &#123;</div><div class="line">    var result = stringValue.localeCompare(value);</div><div class="line">    if (result &lt; 0) &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; comes before the string &apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125; else if (result &gt; 0) &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; comes after the string &apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; is equal to the string&apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line">determineOrder(&quot;brick&quot;);</div><div class="line">determineOrder(&quot;yellow&quot;);</div><div class="line">determineOrder(&quot;zoo&quot;);</div></pre></td></tr></table></figure>
<p><br>    使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。<br></p>

<h3 id="1-6-单体内置对象"><a href="#1-6-单体内置对象" class="headerlink" title="1.6 单体内置对象"></a>1.6 单体内置对象</h3><p><br>    ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array和String。ECMA-262还定义了两个单体内置对象：Global和Math。<br></p>

<h3 id="1-6-1-Global对象"><a href="#1-6-1-Global对象" class="headerlink" title="1.6.1 Global对象"></a>1.6.1 Global对象</h3><p><br>    Global(全局)对象可以说是ECMAScript中最特别的一个独享了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。像isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global对象还包含其他一些方法。<br></p>

<h4 id="1-URI编码方法"><a href="#1-URI编码方法" class="headerlink" title="1.URI编码方法"></a>1.URI编码方法</h4><p><br>    Global对象的encodeURI()和encodeURIComponent()方法可以对URI(Uniform Resource Identifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如，空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。<br></p>

<p><br>    其中，encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;</div><div class="line"></div><div class="line">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</div><div class="line">alert(encodeURI(uri));</div><div class="line"></div><div class="line">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</div><div class="line">alert(encodeURIComponent(uri));</div></pre></td></tr></table></figure>
<p><br>    使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20.而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正式可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。<br></p>

<blockquote>
<p>一般来说，我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。</p>
</blockquote>
<p><br>    与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。例如，它可将%20替换成一个空格，但不会对%23作任何处理，因为%23表示井字号(#)，而井字号不是使用encodeURI()替换的。同样地，decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。<br></p>

<h4 id="2-Global对象的属性"><a href="#2-Global对象的属性" class="headerlink" title="2.Global对象的属性"></a>2.Global对象的属性</h4><p><br>    特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下面列出了Global对象的所有属性。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-3.png"></p>
<p><br>    ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。<br></p>

<h4 id="4-window对象"><a href="#4-window对象" class="headerlink" title="4.window对象"></a>4.window对象</h4><p><br>    ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都称为了window对象的属性。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var color = &quot;red&quot;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">	alert(window.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.sayColor();    // &quot;red&quot;</div></pre></td></tr></table></figure>
<p><br>    这里定义了一个名为color的全局变量和一个名为sayColor()的全局函数。在sayColor()内部，我们通过window.color来访问color变量，以说明全局变量是window对象的属性。然后，又使用window.sayColor()来直接通过window对象调用这个函数，结果显示在警告框中。<br></p>

<p><br>    另一种取得Global对象的方法是使用以下代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var global = function() &#123;</div><div class="line">    return this;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了一个立即调用的函数表达式，返回this的值。。如前所述，在没有给函数明确指定this值的情况下(无论是通过将函数添加为对象的方法，还是通过调用call()或apply()),this值等于Global对象。而像这样通过简单地返回this来取得Global对象，在任何执行环境下都是可行的。<br></p>

<h3 id="1-6-2-Math对象"><a href="#1-6-2-Math对象" class="headerlink" title="1.6.2 Math对象"></a>1.6.2 Math对象</h3><p><br>    ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们在JavaScript直接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。Math对象中还提供了辅助完成这些计算的属性和方法。<br></p>

<h4 id="1-Math对象的属性"><a href="#1-Math对象的属性" class="headerlink" title="1.Math对象的属性"></a>1.Math对象的属性</h4><p><br>    Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-4.png"></p>
<h4 id="2-min-和max-方法"><a href="#2-min-和max-方法" class="headerlink" title="2.min()和max()方法"></a>2.min()和max()方法</h4><p><br>    Math对象还包含许多方法，用于辅助完成简单和复杂的数学计算。<br></p>

<p><br>    其中，min()和max()方法用于确定一组数值中的最大值和最小值。这两个方法都可以接收任意多个数值参数，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var max = Math.max(3, 54, 32, 16);</div><div class="line">alert(max);    // 54</div><div class="line"></div><div class="line">var min = Math.min(3, 54, 32, 16);</div><div class="line">alert(min);    // 3</div></pre></td></tr></table></figure>
<p><br>    对于3、54、32和16，Math.max()返回54，而Math.min()返回3.这两个方法经常用于避免多余的循环和在if语句中确定一组数的最大值。<br></p>

<p><br>    要找到数组中的最大或最小值，可以像下面这样使用apply()方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var values = [1, 2, 3, 4, 5, 6, 7, 8];</div><div class="line">var max = Math.max.apply(Math, values);</div></pre></td></tr></table></figure>
<p><br>    这个技巧的关键是把Math作为apply()的第一个参数，从而正确地设置this值。然后，可以将任何数组作为第二个参数。<br></p>

<h4 id="3-舍入方法"><a href="#3-舍入方法" class="headerlink" title="3. 舍入方法"></a>3. 舍入方法</h4><p><br>    下面介绍将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round().这三个方法分别遵循下列舍入规则：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</div><div class="line">2) Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</div><div class="line">3) Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</div></pre></td></tr></table></figure>
<h4 id="4-random-方法"><a href="#4-random-方法" class="headerlink" title="4. random()方法"></a>4. random()方法</h4><p><br>    Math.random()方法返回大于等于0小于1的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。<br></p>

<p><br>    值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)<br></p>

<p><br>    公式中用到了Math.floor()方法，这是因为Math.random()总返回一个小数值。而用这个小数值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个1到10之间的数值，可以像下面这样编写代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = Math.floor(Math.random() * 10 + 1);</div></pre></td></tr></table></figure>
<p><br>    总共有10个可能的值（1到10），而第一个可能的值是1.而如果想要选择一个介于2到10之间的值，就应该将上面的代码改成这样：<br></p>

<p><br>    var num = Math.floor(Math.random() * 9 + 2);<br></p>

<p><br>    从2数到10要数9个数，因此可能值的总数就是9，而第一个可能的值就是2.多数情况下，其实都可以通过一个函数来计算可能值的总数和第一个可能的值，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function selectFrom(lowerValue, upperValue) &#123;</div><div class="line">    var choices = upperValue - lowerValue + 1;</div><div class="line">    return Math.floor(Math.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var num = selectFrom(2, 10);</div><div class="line">alert(num);    // 介于2和10之间(包括2和10)的一个数值</div></pre></td></tr></table></figure>
<p><br>    函数selectFrom()接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加1得到了可能值的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用selectFrom(2, 10)就可以得到一个介于2和10之间(包括2和10)的数值了。利用这个函数，可以方便地从数组中随机取出一项。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];</div><div class="line">var color = colors[selectFrom(0, colors.length-1)];</div><div class="line">alert(color);    // 可能是数组中包含的任何一个字符串</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，传递给selectFrom()的第二个参数是数组的长度减1，也就是数组中最后一项的位置。<br></p>

<h4 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5. 其他方法"></a>5. 其他方法</h4><p><br>    Math对象中还包含其他一些与完成各种简单或复杂计算有关的方法。下图，列出了这些没有介绍到的Math对象的方法。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-5.png"></p>
<p><br>    虽然ECMA-262规定了这些方法，但不同实现可能会对这些方法采用不同的算法。毕竟，计算某个值的正弦、余弦和正切的方式多种多样。也正是因为如此，这些方法在不同的实现中可能会有不同的精度。<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/29/引用类型（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/29/引用类型（二）/" itemprop="url">引用类型（二）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-29T08:40:33+08:00">
                2017-08-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-3-3-RegExp构造函数属性"><a href="#1-3-3-RegExp构造函数属性" class="headerlink" title="1.3.3 RegExp构造函数属性"></a>1.3.3 RegExp构造函数属性</h3><p><br>    RegExp构造函数包含一些属性(这些属性在其他语言中被看成是静态属性)。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名(Opera是例外，它不支持短属性名)。下表列出了RegExp构造函数的属性。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">长属性名            短属性名         说明</div><div class="line">input               $_               最近一次要匹配的字符串。Opera未实现此属性</div><div class="line">lastMatch           $&amp;               最近一次的匹配项。Opera未实现此属性</div><div class="line">lastParen           $+               最近一次匹配的捕获组。Opera未实现此属性</div><div class="line">leftContext         $`               input字符串中lastMatch之前的文本</div><div class="line">multiline           $*               布尔值，表示是否所有表达式都是用多行模式。IE和Opera未实现此属性</div><div class="line">rightContext        $&apos;               Input字符串中lastMatch之后的文本</div></pre></td></tr></table></figure>
<p><br>    使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var text = &quot;this has been a short summer&quot;;</div><div class="line">var pattern = /(.)hort/g;</div><div class="line"></div><div class="line">// 注意：Opera不支持input、lastMatch、lastParen和multiline属性。IE不支持multiline属性。</div><div class="line">if (pattern.test(text)) &#123;</div><div class="line">    alert(RegExp.input);        // this has been a short summer</div><div class="line">    alert(RegExp.leftContext);	// this has been a</div><div class="line">    alert(RegExp.rightContext);	// summer</div><div class="line">    alert(RegExp.lastMatch);	// short</div><div class="line">    alert(RegExp.lastParen);	// s</div><div class="line">    alert(RegExp.multiline);	// false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了一个模式，匹配任何一个字符后跟hort，而且第一个字符放在了一个捕获组中。RegExp构造函数的各个属性返回了下列值：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) input属性返回了原始字符串；</div><div class="line">b) leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串；</div><div class="line">c) lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short；</div><div class="line">d) lastParen属性返回最近一次匹配的捕获组，即例子中的s。</div></pre></td></tr></table></figure>
<p><br>    如前所述，例子使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var text = &quot;this has been a short summer&quot;;</div><div class="line">var pattern = /(.)hort/g;</div><div class="line"></div><div class="line">if (pattern.test(text)) &#123;</div><div class="line">    alert(RegExp.$_);       // this has been a short summer</div><div class="line">    alert(RegExp[&quot;$`&quot;]);    // this has been a</div><div class="line">    alert(RegExp[&quot;$&apos;&quot;]);    // summer</div><div class="line">    alert(RegExp[&quot;$&amp;&quot;]);    // short</div><div class="line">    alert(RegExp[&quot;$+&quot;]);    // s</div><div class="line">    alert(RegExp[&quot;$*&quot;]);    // false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    除了上面介绍的几个属性之外，还有多大9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1、RegExp.$2……RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var text = &quot;this has been a short summer&quot;;</div><div class="line">var pattern = /(..)or(.)/g;</div><div class="line"></div><div class="line">if(pattern.test(text)) &#123;</div><div class="line">    alert(RegExp.$1);   // sh</div><div class="line">    alert(RegExp.$2);   // t</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这里创建了一个包含两个捕获组的模式，并且该模式测试了一个字符串。即使test()方法只返回一个布尔值，但RegExp构造函数的属性$1和$2也会被匹配相应捕获组的字符串自动填充。<br></p>

<h3 id="1-3-4-模式的局限性"><a href="#1-3-4-模式的局限性" class="headerlink" title="1.3.4 模式的局限性"></a>1.3.4 模式的局限性</h3><p><br>    尽管ECMAScript中的正则表达式功能还是比较完备的，但仍然缺少某些语言(特别是Perl)所支持的高级正则表达式特性。下面列出了ECMAScript正则表达式不支持的特性。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a) 匹配字符串开始和结尾的\A和\Z锚(但支持以插入符号(^)和美元符号($)来匹配字符串的开始和结尾)</div><div class="line">b) 向后查找(lookbehind)-但完全支持向前查找(lookahead)</div><div class="line">c) 并集和交集类</div><div class="line">d) 原子组(atomic grouping)</div><div class="line">e) Unicode支持</div><div class="line">f) 命名的捕获组-但支持编号的捕获组</div><div class="line">g) s(single,单行)和x(free-spacing,无间隔)匹配模式</div><div class="line">h) 条件匹配</div><div class="line">i) 正则表达式注释</div></pre></td></tr></table></figure>
<p><br>    即使存在这些限制，ECMAScript正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹配任务。<br></p>

<h3 id="1-4-Function类型"><a href="#1-4-Function类型" class="headerlink" title="1.4 Function类型"></a>1.4 Function类型</h3><p><br>    说起来ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function sum (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这与下面使用函数表达式定义函数的方式几乎相差无几。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sum = function(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    以上代码定义了变量sum并将其初始化为一个函数。有没有注意到，function后面没有函数名。这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量sum即可以引用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量一样。<br></p>

<p><br>    最后一种定义函数的方式是使用Function构造函数。Function函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。来看下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var sum = new Funtion(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);	// 不推荐</div></pre></td></tr></table></figure>
<p><br>    从技术角度讲，这是一个函数表达式。但是，我们不推荐使用这种方法定义函数，因为这种语法会导致解析两次代码(第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串)，从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。<br></p>

<p><br>    由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function sum (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum(10, 10));		// 20</div><div class="line"></div><div class="line">var anotherSum = sum;</div><div class="line">alert(anotherSum(10, 10));	// 20</div><div class="line"></div><div class="line">sum = null;</div><div class="line">alert(anotherSum(10, 10));	// 20</div></pre></td></tr></table></figure>
<p><br>    以上代码首先定义了一个名为sum()的函数，用于求两个值的和。然后，又声明了变量anotherSum，并将其设置为与sum相等(将sum的值赋给anotherSum)。注意，使用不带圆括号的函数名是访问函数的指针，而非调用函数。此时，anotherSum和sum就都指向了同一个函数，因此anotherSum()也可以被调用并返回结果。即使将sum设置为null，让它与函数“断绝关系”，但仍然可以正常调用anotherSum()。<br></p>

<h3 id="1-4-1-没有重载-深入理解"><a href="#1-4-1-没有重载-深入理解" class="headerlink" title="1.4.1 没有重载(深入理解)"></a>1.4.1 没有重载(深入理解)</h3><p><br>    将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。以下是曾在第3章使用过的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function addSomeNumber (num) &#123;</div><div class="line">    return num + 100;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function addSomeNumber(num) &#123;</div><div class="line">    return num + 200;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result = addSomeNumber(100);	// 300</div></pre></td></tr></table></figure>
<p><br>    显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var addSomeNumber = function (num) &#123;</div><div class="line">    return num + 100;</div><div class="line">&#125;;</div><div class="line">addSomeNumber = function (num) &#123;</div><div class="line">    return num + 200;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var result = addSomeNumber(100);	// 300</div></pre></td></tr></table></figure>
<p><br>    通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。<br></p>

<h3 id="1-4-2-函数声明与函数表达式"><a href="#1-4-2-函数声明与函数表达式" class="headerlink" title="1.4.2 函数声明与函数表达式"></a>1.4.2 函数声明与函数表达式</h3><p><br>    到目前为止，我们一直没有对函数声明和函数表达式加以区别。而实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使用其在指向任何代码之前可用(可以访问)；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(10, 10));</div><div class="line">function sum (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升(function declaration hoisting)的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(10, 10));</div><div class="line">var sum = function (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；而且，由于第一行代码就会导致“unexpected identifier”(意外标识符)错误，实际上也不会执行到下一行。<br></p>

<p><br>    除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。<br></p>

<blockquote>
<p>也可以同时使用函数声明和函数表达式，例如var sum = function sum () {}.不过这种语法在Safari中会导致错误。</p>
</blockquote>
<h3 id="1-4-3-作为值的函数"><a href="#1-4-3-作为值的函数" class="headerlink" title="1.4.3 作为值的函数"></a>1.4.3 作为值的函数</h3><p><br>    因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数的结果返回。来看一看下面的函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function callSomeFunction(someFunction, someArgument) &#123;</div><div class="line">    return someFunction(someArgument);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function add10 (num) &#123;</div><div class="line">    return num + 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result1 = callSomeFunction(add10, 10);</div><div class="line">alert(result1);		// 20</div><div class="line"></div><div class="line">function getGreeting (name) &#123;</div><div class="line">    return &quot;Hello, &quot; + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);</div><div class="line">alert(result2);		// &quot;Hello, Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去掉函数名后面那对圆括号。因此上面例子中传递给callSomeFunction()的是add10和getGreeting，而不是执行它们之后的结果。<br></p>

<p><br>    当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假如有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">    return function(object1, object2) &#123;</div><div class="line">        var value1 = object1[propertyName];</div><div class="line">        var value2 = object2[propertyName];</div><div class="line"></div><div class="line">        if (value1 &lt; value2) &#123;</div><div class="line">            return -1;</div><div class="line">        &#125; else if (value1 &gt; value2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var data = [&#123;name: &quot;Zachary&quot;, age: 28&#125;, &#123;name: &quot;Nicholas&quot;, age: 29&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(&quot;name&quot;));</div><div class="line">alert(data[0].name);	// Nicholas</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(&quot;age&quot;));</div><div class="line">alert(data[0].name);	// Zachary</div></pre></td></tr></table></figure>
<p><br>    这里，我们创建了一个包含两个对象的数组data。其中，每个对象都包含一个name属性和一个age属性。在默认情况下，sort()方法会调用每个对象的toString()方法以确定他们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用createComparisonFunction(“name”)方法创建了一个比较函数，以便按照每个对象的name属性值进行排序。而结果排在前面的第一项是name为“Nicholas”，age是29的对象。然后，我们又使用了createComparisonFunction(“age”)返回的比较函数，这次是按照对象的age属性排序。得到的结果是name值为“Zachary”，age值是28的对象排在了第一位。<br></p>

<h3 id="1-4-4-函数内部属性"><a href="#1-4-4-函数内部属性" class="headerlink" title="1.4.4 函数内部属性"></a>1.4.4 函数内部属性</h3><p><br>    在函数内部，有两个特殊的对象：arguments和this。其中，arguments它是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if (num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * factorial(num - 1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    定义阶乘函数一般都要用到递归算法；如上面代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;</div><div class="line">    if (num &lt;= 1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num - 1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var trueFactorial = factorial;</div><div class="line"></div><div class="line">factorial = function () &#123;</div><div class="line">    return 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(trueFactorial(5));	// 120</div><div class="line">alert(factorial(5));		// 0</div></pre></td></tr></table></figure>
<p><br>    在此，变量trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋给了factorial变量。如果像原来的factorial()那样不使用arguments.callee,调用trueFactorial()就会返回0.可是，在解除了函数体内的代码与函数名的耦合状态之后，trueFactorial()仍然能够地计算阶乘；至于factorial()，它现在只是一个返回0的函数。<br></p>

<p><br>    函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象——或者也可以说是this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor();	// &quot;red&quot;</div><div class="line"></div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor();	// &quot;blue&quot;</div></pre></td></tr></table></figure>
<p><br>    上面这个函数sayColor()是在全局作用域中定义的，它引用了this对象。由于在调用函数之前this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。当在全局作用域中调用sayColor()时，this引用的是全局对象window；换句话说，对this.color求值会转换成对window.color求值，于是结果就返回了”red”。而当把这个函数赋给对象o并调用o.sayColor()时，this引用的是对象o，因此对this.color求值会转换成对o.color求值，结果就返回了“blue”。<br></p>

<blockquote>
<p>请牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的sayColor()函数与o.sayColor()指向的仍然是同一个函数。</p>
</blockquote>
<p><br>    ECMAScript5也规范化了另一个函数对象的属性：caller。除了Opera的早期版本不支持，其他浏览器都支持这个ECMAScript3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outer() &#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function inner() &#123;</div><div class="line">    alert(inner.caller);</div><div class="line">&#125;</div><div class="line"></div><div class="line">outer();</div></pre></td></tr></table></figure>
<p><br>    以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了inner()，所以inner.caller就指向outer().为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outer() &#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function inner() &#123;</div><div class="line">   alert(arguments.callee.caller);</div><div class="line">&#125;</div><div class="line"></div><div class="line">outer();</div></pre></td></tr></table></figure>
<p><br>    IE、Firefox、Chrome和Safari的所有版本以及Opera9.6都支持caller属性<br></p>

<p><br>    当函数在严格模式下运行时，访问arguments.callee会导致错误。ECMAScript 5还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。<br></p>

<p><br>    严格模式还有一个限制：不能为函数的caller属性复制，否则会导致错误。<br></p>

<h3 id="1-4-5-函数属性和方法"><a href="#1-4-5-函数属性和方法" class="headerlink" title="1.4.5 函数属性和方法"></a>1.4.5 函数属性和方法</h3><p><br>    前面曾经提到过，ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function sayName(name) &#123;</div><div class="line">    alert(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sum(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sayHi() &#123;</div><div class="line">    alert(&quot;hi&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(sayName.length);		// 1</div><div class="line">alert(sum.length);			// 2</div><div class="line">alert(sayHi.length);		// 0</div></pre></td></tr></table></figure>
<p><br>    以上代码定义了3个函数，但每个函数接收的命名参数个数不同。首先，sayName()函数定义了一个参数，因此其length属性的值为1.类似地，sum()函数定义了两个参数，结果其length属性中保存的值为2.而sayHi()没有命名参数，所以其length值为0.<br></p>

<p><br>    在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了。对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在ECMAScript5中，prototype属性是不可枚举的，因此使用for-in无法发现。<br></p>

<p><br>    每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum1(num1, num2) &#123;</div><div class="line">    return sum.apply(this, arguments);	// 传入arguments对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum2(num1, num2) &#123;</div><div class="line">    return sum.apply(this, [num1, num2]);	// 传入数组</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(callSum1(10, 10));	// 20</div><div class="line">alert(callSum2(10, 10));	// 20</div></pre></td></tr></table></figure>
<p><br>    在上面这个例子中，callSum1()在执行sum()函数时传入了this作为this值(因为是在全局作用域中调用的，所以传入的就是window对象)和arguments对象。而callSum2同样也调用了sum()函数，但它传入的则是this和一个参数数组。这两个函数都会正常执行并返回正确的结果。<br></p>

<blockquote>
<p>在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this值将是undefined。</p>
</blockquote>
<p><br>    call()和apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum(num1, num2) &#123;</div><div class="line">    return sum.call(this, num1, num2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(callSum(10, 10));		// 20</div></pre></td></tr></table></figure>
<p><br>    在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call(),完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。(在不给函数传递参数的情况下，使用哪个方法都无所谓。)<br></p>

<p><br>    事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor();             // red</div><div class="line"></div><div class="line">sayColor.call(this);    // red</div><div class="line">sayColor.call(window);  // red</div><div class="line">sayColor.call(o);       // blue</div></pre></td></tr></table></figure>
<p><br>    这个例子是在前面说明this对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示“red”——因为对this.color的求值会转换成对window.color的求值。而sayColor.call(this)和sayColor.call(window),则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示“red”。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this对象指向了o，于是结果显示的是“blue”。<br></p>

<p><br>    使用call()(或apply())来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将sayColor()函数放到了对象o中，然后再通过o来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。<br></p>

<p><br>    ECMAScript 5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor();	// blue</div></pre></td></tr></table></figure>
<p><br>    在这里，sayColor()调用bind()并传入对象o，创建了objectSayColor()函数。objectSayColor()函数的this值等于o，因此即使是在全局作用域中调用这个函数，也会看到“blue”。<br></p>

<p><br>    支持bind()方法的浏览器有IE 9+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。<br></p>

<p><br>    每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即有解析器删除了注释并对某些代码做了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf()方法同样也只返回函数代码。<br></p>

<h3 id="1-5-基本包装类型"><a href="#1-5-基本包装类型" class="headerlink" title="1.5 基本包装类型"></a>1.5 基本包装类型</h3><p><br>    为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。这些类型与前面介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">var s2 = s1.substring(2);</div></pre></td></tr></table></figure>
<p><br>    这个例子中的变量s1包含一个字符串，字符串当然是基本类型值。而下一行调用了s1的substring()方法，并将返回的结果保存在了s2中。我们子道，基本类型值不是对象，因为从逻辑上讲它们不应该有方法(尽管如我们所愿，它们确实有方法)。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问s1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。<br></p>

<p><br>    (1) 创建String类型的一个实例；<br>    (2) 在实例上调用指定的方法；<br>    (3) 销毁这个实例。<br>    可以将以上三个步骤想象成是执行下列ECMAScript代码。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = new String(&quot;some text&quot;);</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s1 = null;</div></pre></td></tr></table></figure>
<p><br>    经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于Boolean和Number类型对应的布尔值和数字值。<br></p>

<p><br>    引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">s1.color = &quot;red&quot;;</div><div class="line">alert(s1.color);	// undefined</div></pre></td></tr></table></figure>
<p><br>    在此，第二行代码试图为字符串s1添加一个color属性。但是，当第三行代码再次访问s1时，其color属性不见了。问题的原因就是第二行创建的String对象在执行第三行代码时已经被销毁了。第三行代码又创建自己的String对象，而该对象没有color属性。<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/28/引用类型（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/28/引用类型（一）/" itemprop="url">引用类型（一）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-28T09:28:54+08:00">
                2017-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>引用类型的值(对象)是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因此它们描述的是一类对象所具有的属性和方法。</p>
</blockquote>
<p><br>    如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div></pre></td></tr></table></figure>
<p><br>    这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型(例如Object)，以便开发人员用以实现常见的计算任务。<br></p>

<h3 id="1-1-Object类型"><a href="#1-1-Object类型" class="headerlink" title="1.1 Object类型"></a>1.1 Object类型</h3><p><br>    到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。<br></p>

<p><br>    创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数，如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure>
<p><br>    另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的person对象：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &apos;Nicholas&apos;,</div><div class="line">    age: 29</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，左边的花括号({)表示对象字面量的开始，因为它出现在了表达式上下文中(expression context)中。ECMAScript中的表达式上下文值得是能够返回一个值(表达式)。赋值操作符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文(statement context)中，例如跟在if语句条件的后面，则表示一个语句块的开始。<br></p>

<p><br>    然后，我们定义了name属性，之后是一个冒号，再后面是这个属性的值。在对象字面量中，使用逗号来分隔不同的属性，因此’Nicholas’后面是一个逗号。但是，在age属性的值29的后面不能添加逗号，因为age是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在IE7及更早版本和Opera中导致错误。<br></p>

<p><br>    在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    &quot;name&quot;: &quot;Nicholas&quot;,</div><div class="line">    &quot;age&quot;: 29,</div><div class="line">    5: true</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    这个例子会创建一个对象，包含三个属性：name、age和5.但这里的数值属性名会自动转换为字符串。<br></p>

<p><br>    另外，使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;	// 与new Object()相同</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure>
<p><br>    这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。<br></p>

<blockquote>
<p>在通过对象字面量定义对象时，实际上不会调用Object构造函数(Firefox 2及更早版本会调用Object构造函数；但Firefox 3之后就不会了)。</p>
</blockquote>
<p><br>    虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function displayInfo (args) &#123;</div><div class="line">    var output = &quot;&quot;;</div><div class="line">    if (typeof args.name == &quot;string&quot;) &#123;</div><div class="line">        output += &quot;Name: &quot; + args.name + &quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    if (typeof args.age == &quot;number&quot;) &#123;</div><div class="line">        output += &quot;Age: &quot; + args.age +&quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    alert(output);</div><div class="line">&#125;</div><div class="line">displayInfo(&#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    age: 29</div><div class="line">&#125;);</div><div class="line">displayInfo(&#123;</div><div class="line">    name: &quot;Greg&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，函数displayInfo()接受一个名为args的函数。这个参数可能带有一个名为name或age的属性，也可能这两个属性都有或者都没有。在这个函数内部，我们通过typeof操作符来检测每个属性是否存在，然后再基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都是用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。<br></p>

<blockquote>
<p>这种传递参数的模式最适合需要向函数传入大量可选参数的情形。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p>
</blockquote>
<p><br>    一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，在JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person[&quot;name&quot;]);	// &quot;Nicholas&quot;</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量来访问属性，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var propertyName = &quot;name&quot;;</div><div class="line">alert(person[propertyName]);	// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    如果属性名中包含导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person[&quot;first name&quot;] = &quot;Nicholas&quot;;</div></pre></td></tr></table></figure>
<p><br>    由于“first name”中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包含非字母非数字的，这时候就可以使用方括号表示法来访问它们。<br></p>

<p><br>    通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。<br></p>

<h3 id="1-2-Date类型"><a href="#1-2-Date类型" class="headerlink" title="1.2 Date类型"></a>1.2 Date类型</h3><p><br>    ECMAScript中的Date类型是在早期Java中的java.util.Date基础上构建的。为此，Date类型使用自UTC(Coordinated Universal Time, 国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的285616年。<br></p>

<p><br>    要创建一个日期对象，使用new操作符和Date构造函数即可，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var now = new Date();</div></pre></td></tr></table></figure>
<p><br>    在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示日期的毫秒数(即从UTC时间1970年1月1日午夜起至该日期止经过的毫秒数)。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。<br></p>

<p><br>    其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国浏览器通常都接受下列日期格式：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) “月/日/年”，如6/13/2004;</div><div class="line">b) “英文月名 日，年”，如January 12, 2004;</div><div class="line">c) “英文星期几 英文月名 日 年 时：分：秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700;</div><div class="line">d) ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ(例如 2004-05-25T00:00:00)。只有兼容ECMAScript 5的实现支持这种格式。</div></pre></td></tr></table></figure>
<p><br>    例如，要为2004年5月25日创建一个日期对象，可以使用下面的代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));</div></pre></td></tr></table></figure>
<p><br>    如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前面的例子是等价的：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var someDate = new Date(&quot;May 25, 2004&quot;);</div></pre></td></tr></table></figure>
<p><br>    这行代码将会得到与前面相同的日期对象。<br></p>

<blockquote>
<p>日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超出范围的值替换成当前的值，以便生成输出。例如，在解析“January 32,2007”时，有的浏览器会将其解释为“February 1, 2007”。而Opera则倾向于插入当前月份的当前日期，返回“January 当前日期，2007”。也就是说，如果在2007年9月21日运行前面的代码，将会得到“January 21,2007”(都是21日)。</p>
</blockquote>
<p><br>    Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0的月份(一月是0，二月是1，以此类推)、月中的哪一天(1到31)、小时数(0到23)、分钟、秒以及毫秒数。在这些参数中，只有前面两个参数(年和月)是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0.以下是两个使用Date.UTC()方法的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// GMT 时间2000年1月1日午夜零时</div><div class="line">var y2k = new Date(Date.UTC(2000, 0));</div><div class="line"></div><div class="line">// GMT 时间2005年5月5日下午5:55:55</div><div class="line">var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</div></pre></td></tr></table></figure>
<p><br>    这个例子创建了两个日期对象。第一个对象表示GMT时间2000年1月1日午夜零时，传入的值一个是表示年份的2000，一个是表示月份的0(即一月份)。因为其他参数是自动填充的(即月中的天数为1，其他所有参数均为0)，所以结果就是该月第一天的午夜零时。第二个对象表示GMT时间2005年5月5日下午5:55:55，即使日期和时间中只包含5，也需要传入不一样的参数：月份必须是4(因为月份是基于0的)、小时必须设置为17(因为小时以0到23表示)，剩下的参数就很直观了。<br></p>

<p><br>    如同模仿Date.parse()一样，Date构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTC()相同。因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。据此，可以将前面的例子重写如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 本地时间2000年1月1日午夜零时</div><div class="line">var y2k = new Date(2000, 0);</div><div class="line">// 本地时间2005年5月5日下午5:55:55</div><div class="line">var allFives = new Date(2005, 4, 5, 17, 55, 55);</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区而创建的。<br></p>

<p><br>    ECMAScript 5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Date对象分析代码的工作。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 取得开始时间</div><div class="line">var start = Date.now();</div><div class="line"></div><div class="line">// 调用函数</div><div class="line">doSomething();</div><div class="line"></div><div class="line">// 取得停止时间</div><div class="line">var stop = Date.now(),</div><div class="line">    result = stop - start;</div></pre></td></tr></table></figure>
<p><br>    支持Date.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支持它的浏览器中，使用+操作符把Date对象转换成字符串，也可以达到同样的目的。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 取得开始时间</div><div class="line">var start = +new Date();</div><div class="line"></div><div class="line">// 调用函数</div><div class="line">doSomething();</div><div class="line">// 取得停止时间</div><div class="line">var stop = +new Date(),</div><div class="line">    result = stop - start;</div></pre></td></tr></table></figure>
<h3 id="1-2-1-继承的方法"><a href="#1-2-1-继承的方法" class="headerlink" title="1.2.1 继承的方法"></a>1.2.1 继承的方法</h3><p><br>    与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法；但这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息(当然，具体的格式会因浏览器而异)。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间(即小时的范围是0到23)表示。下面给出了在不同浏览器中调用toLocaleString()和toString()方法，输出PST(Pacific Standard Time, 太平洋标准时间)时间2007年2月1日午夜零时的结果。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-1.png"></p>
<p><br>    显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。<br></p>

<p><br>    至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符(小于或大于)来比较日期值。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var date1 = new Date(2007, 0, 1);	// &quot;January 1, 2007&quot;</div><div class="line">var date2 = new Date(2007, 1, 1);	// &quot;February 1, 2007&quot;</div><div class="line"></div><div class="line">alert(date1 &lt; date2);	// true</div><div class="line">alert(date1 &gt; date2);	// false</div></pre></td></tr></table></figure>
<p><br>    从逻辑上讲，2007年1月1日要早于2007年2月1日，此时如果我们说前者小于后者比较符合常理。而表示2007年1月1日的毫秒值小于表示2007年2月1日的毫秒值，因此在首先使用小于操作符比较日期时，返回的结果是true。这样，就为我们比较日期提供了极大方便。<br></p>

<h3 id="1-2-2-日期格式化方法"><a href="#1-2-2-日期格式化方法" class="headerlink" title="1.2.2 日期格式化方法"></a>1.2.2 日期格式化方法</h3><p><br>    Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a) toDateString() —— 以特定于实现的格式显示星期几、月、日和年；</div><div class="line">b) toTimeString() —— 以特定于实现的格式显示时、分、秒和时区；</div><div class="line">c) toLocaleDateString() —— 以特定于地区的格式显示星期几、月、日和年；</div><div class="line">d) toLocaleTimeString() —— 以特定于实现的格式显示时、分、秒；</div><div class="line">e) toUTCString() —— 以特定于实现的格式完整的UTC日期。</div></pre></td></tr></table></figure>
<p><br>    与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。<br></p>

<blockquote>
<p>除了前面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写的代码一律使用toUTCString()方法。</p>
</blockquote>
<h3 id="1-2-3-日期-时间组件方法"><a href="#1-2-3-日期-时间组件方法" class="headerlink" title="1.2.3 日期/时间组件方法"></a>1.2.3 日期/时间组件方法</h3><p><br>    到目前为止，剩下还未介绍的Date类型的方法(如下表所示)，都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC日期指的是在没有时区偏差的情况下(将日期转换为GMT时间)的日期值。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-2.png"></p>
<h3 id="1-3-RegExp类型"><a href="#1-3-RegExp类型" class="headerlink" title="1.3 RegExp类型"></a>1.3 RegExp类型</h3><p><br>    ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var expression = / pattern / flags;</div></pre></td></tr></table></figure>
<p><br>    其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g：表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</div><div class="line">i：表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写；</div><div class="line">m：表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</div></pre></td></tr></table></figure>
<p><br>    因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 匹配字符串中所有“at”的实例</div><div class="line">var pattern1 = /at/g;</div><div class="line">// 匹配第一个“bat”或“cat”，不区分大小写</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line">// 匹配所有以“at”结尾的3个字符的组合，不区分大小写</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure>
<p><br>    与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( [ &#123; \ ^ $ | ) ? * + . ] &#125;</div></pre></td></tr></table></figure>
<p><br>    这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 匹配第一个“bat”或“cat”,不区分大小写</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">// 匹配第一个“[bc]at”,不区分大小写</div><div class="line">var pattern2 = /\[bc\]at/i;</div><div class="line">// 匹配所有以“at”结尾的3个字符的组合，不区分大小写</div><div class="line">var pattern3 = /.at/gi;</div><div class="line">// 匹配所有“.at”，不区分大小写</div><div class="line">var pattern4 = /\.at/gi;</div></pre></td></tr></table></figure>
<p><br>    在上面的例子中，pattern1匹配第一个“bat”或“cat”，不区分大小写。而要想直接匹配“[bc]at”的话，就需要像定义pattern2一样，对其中的两个方括号进行转义。对于pattern3来说，句点表示位于“at”之前的任意一个可以构成匹配项的字符。但如果想匹配“.at”，则必须对句点本身进行转义，如pattern4所示。<br></p>

<p><br>    前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 匹配第一个“bat”或“cat”，不区分大小写</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">// 与pattern1相同，只不过是使用构造函数创建的</div><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure>
<p><br>    在此，pattern1和pattern2是两个完全等价的正则表达式。要注意的是，传递给RegExp构造函数的两个参数都是字符串(不能把正则表达式字面量传给RegExp构造函数)。有RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n(字符\在字符串中通常被转义为\,而在正则表达式字符串中就会变成\\)。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义相同模式时使用的字符串。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">字面量模式             等价的字符串</div><div class="line">/\[bc\]at/             &quot;\\[bc\\]at&quot;</div><div class="line">/\.at/                 &quot;\\.at&quot;</div><div class="line">/name\/age/            &quot;name\\/age&quot;</div><div class="line">/\d.\d&#123;1,2&#125;/           &quot;\\d.\\d&#123;1,2&#125;&quot;</div><div class="line">/\w\\hello\\123/       &quot;\\w\\\\hello\\\\123&quot;</div></pre></td></tr></table></figure>
<p><br>    使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var re = null,</div><div class="line">    i;</div><div class="line"></div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">	re = /cat/g;</div><div class="line">	re.test(&quot;catastrophe&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">	re = new RegExp(&quot;cat&quot;, &quot;g&quot;);</div><div class="line">	re.test(&quot;catastrophe&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在第一个循环中，即使是循环体指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性不会重置，所以在循环中再次调用test()方法会失败。这是因为第一个调用test()找到了“cat”。但第二次调用是从索引为3的字符(上一次匹配的末尾)开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就有从头开始了。<br></p>

<p><br>    第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp实例，所以每次调用test()都会返回true。<br></p>

<p><br>    ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一眼，每次都创建新的RegExp实例。IE9+、Firefox4+和Chrome都据此做出了修改。<br></p>

<h3 id="1-3-1-RegExp实例属性"><a href="#1-3-1-RegExp实例属性" class="headerlink" title="1.3.1 RegExp实例属性"></a>1.3.1 RegExp实例属性</h3><p><br>    RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a) global：布尔值，表示是否设置了g标志。</div><div class="line">b) ignoreCase：布尔值，表示是否设置了i标志。</div><div class="line">c) lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</div><div class="line">d) multiline：布尔值，表示是否设置了m标志。</div><div class="line">e) source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</div></pre></td></tr></table></figure>
<p><br>    通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var pattern1 = /\[bc\]at/i;</div><div class="line"></div><div class="line">alert(pattern1.global);		// false</div><div class="line">alert(pattern1.ignoreCase);	// true</div><div class="line">alert(pattern1.multiline);	// false</div><div class="line">alert(pattern1.lastIndex);	// 0</div><div class="line">alert(pattern1.source);		// &quot;\[bc\]at&quot;</div><div class="line"></div><div class="line">var pattern2 = new RegExp(&quot;\\[bc\\]at&quot;, &quot;i&quot;);</div><div class="line"></div><div class="line">alert(pattern2.global);		// false</div><div class="line">alert(pattern2.ignoreCase);	// true</div><div class="line">alert(pattern2.multiline);	// false</div><div class="line">alert(pattern2.lastIndex);	// 0</div><div class="line">alert(pattern2.source);		// &quot;\[bc\]at&quot;</div></pre></td></tr></table></figure>
<p><br>    我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了RegExp构造函数，但它们的source属性是相同的。可见，source属性保存的是规范形式的字符串，即字面量形式所用的字符串。<br></p>

<h3 id="1-3-2-RegExp实例方法"><a href="#1-3-2-RegExp实例方法" class="headerlink" title="1.3.2 RegExp实例方法"></a>1.3.2 RegExp实例方法</h3><p><br>    RegExp对象的主要方法是exec(),该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)。请看下面这个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var text = &quot;mom and dad and baby&quot;;</div><div class="line">var pattern = /mom( and dad( and baby)?)?/gi;</div><div class="line"></div><div class="line">var matches = pattern.exec(text);</div><div class="line">alert(matches.index);	// 0</div><div class="line">alert(matches.input);	// &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[0]);		// &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[1]);		// &quot; and dad and baby&quot;</div><div class="line">alert(matches[2]);		// &quot; and baby&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的模式包含两个捕获组。最内部的捕获组匹配“and baby”，而包含它的捕获组匹配“and dad”或者“and dad and baby”。当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs的index属性值为0.数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。<br></p>

<p><br>    对于exec()方法而言，即使在模式中设置了全局标志(g),他每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pattern1 = /.at/;</div><div class="line"></div><div class="line">var matches = pattern1.exec(text);</div><div class="line">alert(matches.index);		// 0</div><div class="line">alert(matches[0]);			// cat</div><div class="line">alert(pattern.lastIndex);	// 0</div><div class="line"></div><div class="line">matches = pattern1.exec(text);</div><div class="line">alert(matches.index);		// 0</div><div class="line">alert(matches[0]);			// cat</div><div class="line">alert(matches.lastIndex);   // 0</div><div class="line"></div><div class="line">var pattern2 = /.at/g;</div><div class="line"></div><div class="line">var matches = pattern2.exec(text);</div><div class="line">alert(matches.index);		// 0</div><div class="line">alert(matches[0]);			// cat</div><div class="line">alert(pattern2.lastIndex);	// 3</div><div class="line"></div><div class="line">matches = pattern2.exec(text);</div><div class="line">alert(matches.index);		// 5</div><div class="line">alert(matches[0]);			// bat</div><div class="line">alert(pattern2.lastIndex);	// 8</div></pre></td></tr></table></figure>
<p><br>    这个例子中的第一个模式pattern1不是全局模式，因此每次调用exec()返回的都是第一个匹配项(“cat”)。而第二个模式pattern2是全局模式，因此每次调用exec()都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的lastIndex属性的变化情况。在全局匹配模式下，lastIndex的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。<br></p>

<blockquote>
<p>IE的JavaScript实现在lastIndex属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。</p>
</blockquote>
<p><br>    正则表达式的第二个方法是text()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;000-00-0000&quot;;</div><div class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</div><div class="line"></div><div class="line">if (pattern.text(text)) &#123;</div><div class="line">	alert(&quot;The pattern was matched.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们使用正则表达式来测试一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效就无关紧要了。<br></p>

<p><br>    RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var pattern = new RegExp(&quot;\\[bc\\]at&quot;, &quot;gi&quot;);</div><div class="line">alert(pattern.toString());			// /\[bc\]at/gi</div><div class="line">alert(pattern.toLocaleString());	// /\[bc\]at/gi</div></pre></td></tr></table></figure>
<p><br>    即使上例中的模式是通过调用RegExp构造函数创建的，但toLocaleString()和toString()方法仍然会像它是以字面量形式创建的一样显示其字符串表示。<br></p>

<blockquote>
<p>正则表达式的valueOf()方法返回正则表达式本身。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/变量、作用域和内存问题（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/变量、作用域和内存问题（二）/" itemprop="url">变量、作用域和内存变量（二）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-27T16:15:05+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-3-垃圾收集"><a href="#1-3-垃圾收集" class="headerlink" title="1.3 垃圾收集"></a>1.3 垃圾收集</h3><p><br>    JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在C和C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写JavaScript程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。<br></p>

<p><br>    下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈(或堆)内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有的情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。<br></p>

<h3 id="1-3-1-标记清除"><a href="#1-3-1-标记清除" class="headerlink" title="1.3.1 标记清除"></a>1.3.1 标记清除</h3><p><br>    JavaScript中最常用的垃圾收集方式是标记清除(mark-and-sweep).当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。<br></p>

<p><br>    可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。<br></p>

<p><br>    垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记(当然，可以使用任何标记方式)。然后，它会去掉环境中的变量以及被环境中的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br></p>

<p><br>    到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略(或类似的策略)，只不过垃圾收集的时间间隔互有不同。<br></p>

<h3 id="1-3-2-引用计数"><a href="#1-3-2-引用计数" class="headerlink" title="1.3.2 引用计数"></a>1.3.2 引用计数</h3><p><br>    另一种不太常见的垃圾收集策略叫做引用计数(reference counting)。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋给该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，这说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。<br></p>

<p><br>    Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。请看下面这个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function problem() &#123;</div><div class="line">    var objectA = new Object();</div><div class="line">    var objectB = new Object();</div><div class="line"></div><div class="line">    objectA.someOtherObject = objectB;</div><div class="line">    objectB.anotherObject = objectA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2.在采用标记清除策略的实现中，但函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不会是0.假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，NetScape在Navigator4.0中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。<br></p>

<p><br>    我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM(Component Object Model，组件对象模型)对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的JavaScript引擎是使用标记清除策略来实现的，但JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用COM对象导致的循环引用问题：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var element = document.getElementById(&quot;some_element&quot;);</div><div class="line">var myObject = new Object();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p><br>    这个例子在一个DOM元素(element)与一个原生JavaScript对象(myObject)之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个属性名叫someObject回指myObject。由于存在这个循环引用，即使将例子中的DOM从页面中移除，它也永远不会被回收。<br></p>

<p><br>    为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生JavaScript对象与DOM元素之间的链接。例如，可以使用下面的代码消除前面例子创建的循环引用：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = null;</div><div class="line">element.someObject = null;</div></pre></td></tr></table></figure>
<p><br>    将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。<br></p>

<p><br>    为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄露现象。<br></p>

<h3 id="1-3-3-性能问题"><a href="#1-3-3-性能问题" class="headerlink" title="1.3.3 性能问题"></a>1.3.3 性能问题</h3><p><br>    垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一次，不禁让人联想到IE因此而声名狼藉的性能问题。IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象(或数组)字面量和数组元素(slot)或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。<br></p>

<p><br>    随着IE7的发布，其JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和(或)数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和(或)数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置或默认值。这一看似简单的调整，极大地提升了IE在运行包含大量JavaScript的页面时的性能。<br></p>

<h3 id="1-3-4-管理内存"><a href="#1-3-4-管理内存" class="headerlink" title="1.3.4 管理内存"></a>1.3.4 管理内存</h3><p><br>    使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是处于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。<br></p>

<p><br>    因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用(dereferencing)。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被接触引用，如下面这个例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function createPerson(name) &#123;</div><div class="line">    var localPerson = new Object();</div><div class="line">    localPerson.name = name;</div><div class="line">    return localPerson;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var globalPerson = createPerson(&quot;Nicholas&quot;);</div><div class="line"></div><div class="line">// 手工解除globalPerson的引用</div><div class="line">globalPerson = null;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，变量globalPerson取得了createPerson()函数返回的值。在createPerson()函数内部，我们创建了一个对象并将其赋给局部变量localPerson，然后又为该对象添加了一个名为name的属性。最后，当调用这个函数时，localPerson以函数值的形式返回并赋给全局变量globalPerson。由于localPerson在createPerson()函数执行完毕后就离开了其执行环境，因此，无须我们显式地去为它解除引用。但是对于全局变量globalPerson而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。<br></p>

<p><br>    不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。<br></p>

<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><br>    JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1) 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</div><div class="line">2) 从一个变量向另一个变量复制基本类型的值，会创建这个值的副本；</div><div class="line">3) 引用类型的值是对象，保存在堆内存中；</div><div class="line">4) 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</div><div class="line">5) 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都会指向同一个对象；</div><div class="line">6) 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。</div></pre></td></tr></table></figure>
<p><br>    所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) 执行环境有去全局执行环境(也称为全局环境)和函数执行环境之分；</div><div class="line">2) 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</div><div class="line">3) 函数的局部环境不仅有权访问函数作用域中变量，而且有权访问其包含(父)环境，乃至全局环境；</div><div class="line">4) 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</div><div class="line">5) 变量的执行环境有助于确定应该何时释放内存。</div></pre></td></tr></table></figure>
<p><br>    JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</div><div class="line">2) &quot;标记清除&quot;是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。</div><div class="line">3) 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象(如DOM元素)时，这种算法仍然可能会导致问题。</div><div class="line">4) 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</div><div class="line">5) 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/26/变量、作用域和内存问题（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/变量、作用域和内存问题（一）/" itemprop="url">变量、作用域和内存变量（一）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T19:41:33+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>按照ECMA-262的定义，JavaScript的变量与其他语言的变量有很大区别。JavaScript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但JavaScript变量实际的复杂程度还远不止如此。</p>
</blockquote>
<h3 id="1-1-基本类型和引用类型的值"><a href="#1-1-基本类型和引用类型的值" class="headerlink" title="1.1 基本类型和引用类型的值"></a>1.1 基本类型和引用类型的值</h3><p><br>    ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。<br></p>

<p><br>    在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br></p>

<p><br>    引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。(这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象)<br></p>

<blockquote>
<p>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。</p>
</blockquote>
<h3 id="1-1-1-动态的属性"><a href="#1-1-1-动态的属性" class="headerlink" title="1.1.1 动态的属性"></a>1.1.1 动态的属性</h3><p><br>    定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了一个对象并将其保存在了变量person中。然后，我们为该对象添加了一个名为name的属性，并将字符串值“Nicholas”赋给了这个属性。紧接着，又通过alert()函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。<br></p>

<p><br>    但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name = &quot;Nicholas&quot;;</div><div class="line">name.age = 27;</div><div class="line">alert(name.age);	// undefined</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们为字符串name定义了一个名为age的属性，并为该属性赋值27.但在下一行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。<br></p>

<h3 id="1-1-2-复制变量值"><a href="#1-1-2-复制变量值" class="headerlink" title="1.1.2 复制变量值"></a>1.1.2 复制变量值</h3><p><br>    除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。来看一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num1 = 5;</div><div class="line">var num2 = num1;</div></pre></td></tr></table></figure>
<p><br>    在此，num1中保存的值是5。当使用num1的值来初始化num2时，num2中也保存了值5.但num2中的5与num1中的5是完全独立的，该值只是num1中5的一个副本。此后，这个变量可以参与任何操作而不会相互影响。图1-1形象地真是了赋值基本类型值的过程。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-1.png"></p>
<div style="text-align: center;">图1-1 复制基本类型值的过程</div>

<p><br>    当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj1 = new Object();</div><div class="line">var obj2 = obj1;</div><div class="line">obj1.name = &quot;Nicholas&quot;;</div><div class="line">alert(obj2.name);	// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了obj2中，换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加name属性后，可以通过obj2来访问这个属性，因为这两个变量引用的都是同一个对象。图1-2展示了保存在变量对象中的变量和保存在堆中的对象之间的这种关系。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-2.png"></p>
<div style="text-align: center;">图1-2 复制引用类型值的过程</div>

<h3 id="1-1-3-传递参数"><a href="#1-1-3-传递参数" class="headerlink" title="1.1.3 传递参数"></a>1.1.3 传递参数</h3><p><br>    ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。<br></p>

<p><br>    在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素)。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面这个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function addTen (num) &#123;</div><div class="line">    num += 10;</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line">var count = 20;</div><div class="line">var result = addTen(count);</div><div class="line">alert(count);	// 20, 没有变化</div><div class="line">alert(result);	// 30</div></pre></td></tr></table></figure>
<p><br>    这里的函数addTen()有一个参数num，而参数实际上是函数的局部变量。在调用这个函数时，变量count作为参数被传递给函数，这个变量的值是20.于是，数值20被复制给参数num以便在addTen()中使用。在函数内部，参数num的值被加上了10，但这一变化不会影响函数外部的count变量。参数num与变量count互不相识，它们仅仅是具有相同的值。假如num是按引用传递的话，那么变量count的值也将变成30，从而反映函数内部的修改。当然，使用数值等基本类型值来说明按值传递参数比较简单，但如果使用对象，那问题就不好理解了。再举一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function setName (obj) &#123;</div><div class="line">    obj.name = &quot;Nicholas&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码中创建一个对象，并将其保存在了变量person中。然后，这个变量被传递到setName()函数中之后就被复制给了obj。在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象。于是，当在函数内部为obj添加name属性后，函数外部的person也将有所反映；因为person所指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setName (obj) &#123;</div><div class="line">    obj.name = &quot;Nickolas&quot;;</div><div class="line">    obj = new Object();</div><div class="line">    obj.name = &quot;Greg&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子与前一个例子的唯一区别，就是在setName()函数中添加了两行代码：一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给setName()后，其name属性被设置为“Nicholas”。然后，又将一个新对象赋给变量obj，同时将其name属性设置为“Greg”。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为“Greg”的新对象。但是，当接下来再访问person.name时，显示的值仍然是“Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。<br></p>

<blockquote>
<p>可以把ECMAScript函数的参数想象成局部变量。</p>
</blockquote>
<h3 id="1-1-4-检测类型"><a href="#1-1-4-检测类型" class="headerlink" title="1.1.4 检测类型"></a>1.1.4 检测类型</h3><p><br>    要检测一个变量是不是基本数据类型？typeof操作符是最佳的工具。说得更具体一点，typeof操作符是确定一个变量是字符串、数值、布尔值、还是undefined的最佳工具。如果变量的值是一个对象或null，则typeof操作符会像下面例子中所示的那样返回“object”：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var s = &quot;Nicholas&quot;;</div><div class="line">var b = true;</div><div class="line">var i = 22;</div><div class="line">var u;</div><div class="line">var n = null;</div><div class="line">var o = new Object();</div><div class="line"></div><div class="line">alert(typeof s);	// &quot;string&quot;</div><div class="line">alert(typeof i);	// &quot;number&quot;</div><div class="line">alert(typeof b);	// &quot;boolean&quot;</div><div class="line">alert(typeof u);	// &quot;undefined&quot;</div><div class="line">alert(typeof n);	// &quot;object&quot;</div><div class="line">alert(typeof o);	// &quot;object&quot;</div></pre></td></tr></table></figure>
<p><br>    虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符，其语法如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = variable instanceof constructor</div></pre></td></tr></table></figure>
<p><br>    如果变量是给定引用类型(根据它的原型链来识别)的实例，那么instanceof操作符就会返回true。请看下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(person instanceof Object);	// 变量person是Object吗？</div><div class="line">alert(colors instanceof Array);		// 变量colors是Array吗？</div><div class="line">alert(pattern instanceof RegExp);	// 变量pattern是RegExp吗？</div></pre></td></tr></table></figure>
<p><br>    根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。<br></p>

<blockquote>
<p>使用typeof操作符检测函数时，该操作符会返回“function”。在Safari 5及之前版本和Chrome 7及之前版本中使用typeof检测正则表达式时，由于规范的原因，这个操作符也返回“function”。ECMA-262规定任何在内部实现[[Call]]方法的对象都应该在应用typeof操作符时返回“function”。由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回“function”。在IE和Firefox中，对正则表达式应用typeof会返回“object”。</p>
</blockquote>
<h3 id="1-2-执行环境及作用域"><a href="#1-2-执行环境及作用域" class="headerlink" title="1.2 执行环境及作用域"></a>1.2 执行环境及作用域</h3><p><br>    执行环境(execution context, 为简单起见，有时也称为“环境”)是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<br></p>

<p><br>    全局执行环境是最外层的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁)。<br></p>

<p><br>    每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。<br></p>

<p><br>    当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象在最开始时只包含一个变量。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。<br></p>

<p><br>    标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止(如果找不到标识符，通常会导致错误发生)。请看下面的示例代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line">function changeColor () &#123;</div><div class="line">    if (color === &quot;blue&quot;) &#123;</div><div class="line">        color = &quot;red&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">        color = &quot;blue&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeColor();</div><div class="line">alert(&quot;Color is now &quot; + color);</div></pre></td></tr></table></figure>
<p><br>    在这个简单的例子中，函数changeColor()的作用域链包含两个对象：它自己的变量对象(其中定义着arguments对象)和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。<br></p>

<p><br>    此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function changeColor () &#123;</div><div class="line">	var anotherColor = &quot;red&quot;;</div><div class="line">	function swapColors () &#123;</div><div class="line">		var tempColor = anotherColor;</div><div class="line">		anotherColor = color;</div><div class="line">		color = tempColor;</div><div class="line">		// 这里可以访问color、anotherColor和tempColor</div><div class="line">	&#125;</div><div class="line">	// 这里可以访问color和anotherColor，但不能访问tempColor</div><div class="line">	swapColors();</div><div class="line">&#125;</div><div class="line">// 这里只能访问color</div><div class="line">changeColor();</div></pre></td></tr></table></figure>
<p><br>    以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。全局环境中有一个变量和一个函数changeColor()。changeColor()的局部环境中有一个名为anotherColor的变量和一个名为swapColors()的函数，但它也可以访问全局环境中的变量color。swapColors()的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到。无论全局环境还是changeColor()的局部环境都无权访问tempColor。然而，在swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境都是它的父执行环境。图1-3形象地展示了前面这个例子的作用域链。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-3.png"></p>
<div style="text-align: center;">图1-3</div>

<p><br>    图1-3中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的swapColors()而言，其作用域链中包含3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问swapColors()的环境。<br></p>

<blockquote>
<p>函数参数也被当做变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
</blockquote>
<h3 id="1-2-1-延长作用域链"><a href="#1-2-1-延长作用域链" class="headerlink" title="1.2.1 延长作用域链"></a>1.2.1 延长作用域链</h3><p><br>    虽然执行环境的类型总共只有两种——全局和局部(函数),但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a) try-catch语句的catch块；</div><div class="line">b) with语句。</div></pre></td></tr></table></figure>
<p><br>    这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。下面看一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function buildUrl () &#123;</div><div class="line">    var qs = &quot;?debug=true&quot;;</div><div class="line">    with(location) &#123;</div><div class="line">        var url = href + qs;</div><div class="line">    &#125;</div><div class="line">    return url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在此，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量qs。当在with语句中引用变量href时(实际引用的是location.href)，可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。<br></p>

<blockquote>
<p>在IE8及之前版本的JavaScript实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。</p>
</blockquote>
<h3 id="1-2-2-没有块级作用域"><a href="#1-2-2-没有块级作用域" class="headerlink" title="1.2.2 没有块级作用域"></a>1.2.2 没有块级作用域</h3><p><br>    JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码块都有自己的作用域(如果用ECMAScript的话来讲，就是它们自己的执行环境)，因而支持根据条件来定义变量。例如，下面的代码在JavaScript中并不会得到想象中的结果：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    var color = &quot;blue&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(color);	// &quot;blue&quot;</div></pre></td></tr></table></figure>
<p><br>    这里实在一个if语句中定义了变量color。如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境(在这里是全局环境)中。在使用for语句时尤其要牢记这一差异，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i);	// 10</div></pre></td></tr></table></figure>
<p><br>    对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。<br></p>

<h3 id="1、声明变量"><a href="#1、声明变量" class="headerlink" title="1、声明变量"></a>1、声明变量</h3><p><br>    使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add (num1, num2) &#123;</div><div class="line">    var sum = num1 + num2;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">var result = add(10, 20);	// 30</div><div class="line">alert(sum);		// 由于sum不是有效的变量，因此会导致错误</div></pre></td></tr></table></figure>
<p><br>    以上代码中的函数add()定义了一个名为sum的局部变量，该变量包含加法操作的结果。虽然结果值从函数中返回了，但变量sum在函数外部是访问不到的。如果省略这个例子中的var关键字，那么当add()执行完毕后，sum也将可以访问到：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add (num1, num2) &#123;</div><div class="line">    sum = num1 + num2;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">var result = add(10, 20);	// 30</div><div class="line">alert(sum);		// 30</div></pre></td></tr></table></figure>
<p><br>    这个例子中的变量sum在被初始化赋值时没有使用var关键字。于是，当调用完add()之后，添加到全局环境中的变量sum将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。<br></p>

<blockquote>
<p>在编写JavaScript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。</p>
</blockquote>
<h3 id="2、查询标识符"><a href="#2、查询标识符" class="headerlink" title="2、查询标识符"></a>2、查询标识符</h3><p><br>    当在某个环境中为了读取或写入而引用一个标识符，必须通过搜索来确定标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。<br></p>

<p><br>    通过下面这个示例，可以理解查询标识符的过程：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function getColor () &#123;</div><div class="line">    return color;    	</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor());	// &quot;blue&quot;</div></pre></td></tr></table></figure>
<p><br>    调用本例中的函数getColor()时会引用变量color。为了确定变量color的值，将开始一个两步的搜索过程。首先，搜索getColor()的变量对象，查找其中是否包含一个名为color的标识符。在没有找到的情况下，搜索继续到下一个变量对象(全局环境的变量对象)，然后在那里找到了名为color的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。图1-4形象地展示了上述搜索过程。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-4.png"></p>
<div style="text-align: center;">图1-4</div>

<p><br>    在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，如下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function getColor () &#123;</div><div class="line">	var color = &quot;red&quot;;</div><div class="line">	return color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor());	// &quot;red&quot;</div></pre></td></tr></table></figure>
<p><br>    修改后的代码在getColor()函数中声明了一个名为color的局部变量。调用函数时，该变量就会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量color的值。搜索过程首先从局部环境中开始，而且在这里发现了一个名为color的变量，其值为“red”。因为变量已经找到了，所以搜索即行停止，return语句就使用这个局部变量，并为函数会返回“red”。也就是说，任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。<br></p>

<blockquote>
<p>变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/25/群书治要360（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/25/群书治要360（一）/" itemprop="url">群書治要360 (一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-25T17:35:33+08:00">
                2017-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="《群書治要》序"><a href="#《群書治要》序" class="headerlink" title="《群書治要》序"></a>《群書治要》序</h3><p><br>    《群書治要》是唐太宗李世明（西元五九九年——六四九年）於貞觀初年下令編輯。太宗十六歲隨父從軍，起義平定動亂的社會，戎馬倥傯十餘年。二十七歲即帝位後，偃武修文，特別留心於治平之道，休生養民。<br></p>

<p><br>    太宗英武善辯，遺憾早年從軍，讀書不多。鑒於前隋滅亡之失，深知創業不易，守成維艱，在位期間，鼓勵群臣進諫，批評其決策過失。令諫官魏征及虞世南等，整理歷代帝王治國資政史料，擷取六經、四史、諸子百家中，有關修身、齊家、治國、平天下之精要，匯編成書。上始五帝，下迄晉代，自一萬四千多部、八萬九千多卷古籍中，博采典籍六十五種，共五十餘萬言。<br></p>

<p><br>    書成，如魏征於序文中所說，實為一部[用之當今你，足以鑒覽前古；傅之來葉，可以貽厥孫謀]的治世寶典。太宗喜其廣博而切要，日日手不釋卷。曰：[使我稽古臨事不惑者，卿等力也]。由是而知<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="谦恒" />
          <p class="site-author-name" itemprop="name">谦恒</p>
           
              <p class="site-description motion-element" itemprop="description">苟日新 日日新 又日新</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谦恒</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
