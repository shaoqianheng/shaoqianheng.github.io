<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="苟日新 日日新 又日新">
<meta property="og:type" content="website">
<meta property="og:title" content="谦恒-个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="谦恒-个人博客">
<meta property="og:description" content="苟日新 日日新 又日新">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谦恒-个人博客">
<meta name="twitter:description" content="苟日新 日日新 又日新">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>谦恒-个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谦恒-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/28/引用类型（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/28/引用类型（一）/" itemprop="url">引用类型——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-28T09:28:54+08:00">
                2017-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>引用类型的值(对象)是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因此它们描述的是一类对象所具有的属性和方法。</p>
</blockquote>
<p><br>    如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div></pre></td></tr></table></figure>
<p><br>    这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型(例如Object)，以便开发人员用以实现常见的计算任务。<br></p>

<h3 id="1-1-Object类型"><a href="#1-1-Object类型" class="headerlink" title="1.1 Object类型"></a>1.1 Object类型</h3><p><br>    到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。<br></p>

<p><br>    创建Object实例的方式有两种。第一种是使用new操作符后跟Object构造函数，如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure>
<p><br>    另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。下面这个例子就使用了对象字面量语法定义了与前面那个例子中相同的person对象：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &apos;Nicholas&apos;,</div><div class="line">    age: 29</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，左边的花括号({)表示对象字面量的开始，因为它出现在了表达式上下文中(expression context)中。ECMAScript中的表达式上下文值得是能够返回一个值(表达式)。赋值操作符表示后面是一个值，所以左花括号在这里表示一个表达式的开始。同样的花括号，如果出现在一个语句上下文(statement context)中，例如跟在if语句条件的后面，则表示一个语句块的开始。<br></p>

<p><br>    然后，我们定义了name属性，之后是一个冒号，再后面是这个属性的值。在对象字面量中，使用逗号来分隔不同的属性，因此’Nicholas’后面是一个逗号。但是，在age属性的值29的后面不能添加逗号，因为age是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在IE7及更早版本和Opera中导致错误。<br></p>

<p><br>    在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    &quot;name&quot;: &quot;Nicholas&quot;,</div><div class="line">    &quot;age&quot;: 29,</div><div class="line">    5: true</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    这个例子会创建一个对象，包含三个属性：name、age和5.但这里的数值属性名会自动转换为字符串。<br></p>

<p><br>    另外，使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;	// 与new Object()相同</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure>
<p><br>    这个例子与本节前面的例子是等价的，只不过看起来似乎有点奇怪。关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。<br></p>

<blockquote>
<p>在通过对象字面量定义对象时，实际上不会调用Object构造函数(Firefox 2及更早版本会调用Object构造函数；但Firefox 3之后就不会了)。</p>
</blockquote>
<p><br>    虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function displayInfo (args) &#123;</div><div class="line">    var output = &quot;&quot;;</div><div class="line">    if (typeof args.name == &quot;string&quot;) &#123;</div><div class="line">        output += &quot;Name: &quot; + args.name + &quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    if (typeof args.age == &quot;number&quot;) &#123;</div><div class="line">        output += &quot;Age: &quot; + args.age +&quot;\n&quot;;</div><div class="line">    &#125;</div><div class="line">    alert(output);</div><div class="line">&#125;</div><div class="line">displayInfo(&#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    age: 29</div><div class="line">&#125;);</div><div class="line">displayInfo(&#123;</div><div class="line">    name: &quot;Greg&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，函数displayInfo()接受一个名为args的函数。这个参数可能带有一个名为name或age的属性，也可能这两个属性都有或者都没有。在这个函数内部，我们通过typeof操作符来检测每个属性是否存在，然后再基于相应的属性来构建一条要显示的消息。然后，我们调用了两次这个函数，每次都是用一个对象字面量来指定不同的数据。这两次调用传递的参数虽然不同，但函数都能正常执行。<br></p>

<blockquote>
<p>这种传递参数的模式最适合需要向函数传入大量可选参数的情形。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p>
</blockquote>
<p><br>    一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，在JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person[&quot;name&quot;]);	// &quot;Nicholas&quot;</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量来访问属性，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var propertyName = &quot;name&quot;;</div><div class="line">alert(person[propertyName]);	// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    如果属性名中包含导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person[&quot;first name&quot;] = &quot;Nicholas&quot;;</div></pre></td></tr></table></figure>
<p><br>    由于“first name”中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包含非字母非数字的，这时候就可以使用方括号表示法来访问它们。<br></p>

<p><br>    通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。<br></p>

<h3 id="1-2-Date类型"><a href="#1-2-Date类型" class="headerlink" title="1.2 Date类型"></a>1.2 Date类型</h3><p><br>    ECMAScript中的Date类型是在早期Java中的java.util.Date基础上构建的。为此，Date类型使用自UTC(Coordinated Universal Time, 国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的285616年。<br></p>

<p><br>    要创建一个日期对象，使用new操作符和Date构造函数即可，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var now = new Date();</div></pre></td></tr></table></figure>
<p><br>    在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示日期的毫秒数(即从UTC时间1970年1月1日午夜起至该日期止经过的毫秒数)。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。<br></p>

<p><br>    其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国浏览器通常都接受下列日期格式：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) “月/日/年”，如6/13/2004;</div><div class="line">b) “英文月名 日，年”，如January 12, 2004;</div><div class="line">c) “英文星期几 英文月名 日 年 时：分：秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700;</div><div class="line">d) ISO 8601扩展格式YYYY-MM-DDTHH:mm:ss.sssZ(例如 2004-05-25T00:00:00)。只有兼容ECMAScript 5的实现支持这种格式。</div></pre></td></tr></table></figure>
<p><br>    例如，要为2004年5月25日创建一个日期对象，可以使用下面的代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));</div></pre></td></tr></table></figure>
<p><br>    如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前面的例子是等价的：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var someDate = new Date(&quot;May 25, 2004&quot;);</div></pre></td></tr></table></figure>
<p><br>    这行代码将会得到与前面相同的日期对象。<br></p>

<blockquote>
<p>日期对象及其在不同浏览器中的实现有许多奇怪的行为。其中有一种倾向是将超出范围的值替换成当前的值，以便生成输出。例如，在解析“January 32,2007”时，有的浏览器会将其解释为“February 1, 2007”。而Opera则倾向于插入当前月份的当前日期，返回“January 当前日期，2007”。也就是说，如果在2007年9月21日运行前面的代码，将会得到“January 21,2007”(都是21日)。</p>
</blockquote>
<p><br>    Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0的月份(一月是0，二月是1，以此类推)、月中的哪一天(1到31)、小时数(0到23)、分钟、秒以及毫秒数。在这些参数中，只有前面两个参数(年和月)是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0.以下是两个使用Date.UTC()方法的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// GMT 时间2000年1月1日午夜零时</div><div class="line">var y2k = new Date(Date.UTC(2000, 0));</div><div class="line"></div><div class="line">// GMT 时间2005年5月5日下午5:55:55</div><div class="line">var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</div></pre></td></tr></table></figure>
<p><br>    这个例子创建了两个日期对象。第一个对象表示GMT时间2000年1月1日午夜零时，传入的值一个是表示年份的2000，一个是表示月份的0(即一月份)。因为其他参数是自动填充的(即月中的天数为1，其他所有参数均为0)，所以结果就是该月第一天的午夜零时。第二个对象表示GMT时间2005年5月5日下午5:55:55，即使日期和时间中只包含5，也需要传入不一样的参数：月份必须是4(因为月份是基于0的)、小时必须设置为17(因为小时以0到23表示)，剩下的参数就很直观了。<br></p>

<p><br>    如同模仿Date.parse()一样，Date构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTC()相同。因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。据此，可以将前面的例子重写如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 本地时间2000年1月1日午夜零时</div><div class="line">var y2k = new Date(2000, 0);</div><div class="line">// 本地时间2005年5月5日下午5:55:55</div><div class="line">var allFives = new Date(2005, 4, 5, 17, 55, 55);</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区而创建的。<br></p>

<p><br>    ECMAScript 5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Date对象分析代码的工作。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 取得开始时间</div><div class="line">var start = Date.now();</div><div class="line"></div><div class="line">// 调用函数</div><div class="line">doSomething();</div><div class="line"></div><div class="line">// 取得停止时间</div><div class="line">var stop = Date.now(),</div><div class="line">    result = stop - start;</div></pre></td></tr></table></figure>
<p><br>    支持Date.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支持它的浏览器中，使用+操作符把Date对象转换成字符串，也可以达到同样的目的。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 取得开始时间</div><div class="line">var start = +new Date();</div><div class="line"></div><div class="line">// 调用函数</div><div class="line">doSomething();</div><div class="line">// 取得停止时间</div><div class="line">var stop = +new Date(),</div><div class="line">    result = stop - start;</div></pre></td></tr></table></figure>
<h3 id="1-2-1-继承的方法"><a href="#1-2-1-继承的方法" class="headerlink" title="1.2.1 继承的方法"></a>1.2.1 继承的方法</h3><p><br>    与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法；但这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息(当然，具体的格式会因浏览器而异)。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间(即小时的范围是0到23)表示。下面给出了在不同浏览器中调用toLocaleString()和toString()方法，输出PST(Pacific Standard Time, 太平洋标准时间)时间2007年2月1日午夜零时的结果。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-1.png"></p>
<p><br>    显然，这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。<br></p>

<p><br>    至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符(小于或大于)来比较日期值。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var date1 = new Date(2007, 0, 1);	// &quot;January 1, 2007&quot;</div><div class="line">var date2 = new Date(2007, 1, 1);	// &quot;February 1, 2007&quot;</div><div class="line"></div><div class="line">alert(date1 &lt; date2);	// true</div><div class="line">alert(date1 &gt; date2);	// false</div></pre></td></tr></table></figure>
<p><br>    从逻辑上讲，2007年1月1日要早于2007年2月1日，此时如果我们说前者小于后者比较符合常理。而表示2007年1月1日的毫秒值小于表示2007年2月1日的毫秒值，因此在首先使用小于操作符比较日期时，返回的结果是true。这样，就为我们比较日期提供了极大方便。<br></p>

<h3 id="1-2-2-日期格式化方法"><a href="#1-2-2-日期格式化方法" class="headerlink" title="1.2.2 日期格式化方法"></a>1.2.2 日期格式化方法</h3><p><br>    Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a) toDateString() —— 以特定于实现的格式显示星期几、月、日和年；</div><div class="line">b) toTimeString() —— 以特定于实现的格式显示时、分、秒和时区；</div><div class="line">c) toLocaleDateString() —— 以特定于地区的格式显示星期几、月、日和年；</div><div class="line">d) toLocaleTimeString() —— 以特定于实现的格式显示时、分、秒；</div><div class="line">e) toUTCString() —— 以特定于实现的格式完整的UTC日期。</div></pre></td></tr></table></figure>
<p><br>    与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。<br></p>

<blockquote>
<p>除了前面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写的代码一律使用toUTCString()方法。</p>
</blockquote>
<h3 id="1-2-3-日期-时间组件方法"><a href="#1-2-3-日期-时间组件方法" class="headerlink" title="1.2.3 日期/时间组件方法"></a>1.2.3 日期/时间组件方法</h3><p><br>    到目前为止，剩下还未介绍的Date类型的方法(如下表所示)，都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC日期指的是在没有时区偏差的情况下(将日期转换为GMT时间)的日期值。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-2.png"></p>
<h3 id="1-3-RegExp类型"><a href="#1-3-RegExp类型" class="headerlink" title="1.3 RegExp类型"></a>1.3 RegExp类型</h3><p><br>    ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var expression = / pattern / flags;</div></pre></td></tr></table></figure>
<p><br>    其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g：表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</div><div class="line">i：表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写；</div><div class="line">m：表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</div></pre></td></tr></table></figure>
<p><br>    因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 匹配字符串中所有“at”的实例</div><div class="line">var pattern1 = /at/g;</div><div class="line">// 匹配第一个“bat”或“cat”，不区分大小写</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line">// 匹配所有以“at”结尾的3个字符的组合，不区分大小写</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure>
<p><br>    与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( [ &#123; \ ^ $ | ) ? * + . ] &#125;</div></pre></td></tr></table></figure>
<p><br>    这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 匹配第一个“bat”或“cat”,不区分大小写</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">// 匹配第一个“[bc]at”,不区分大小写</div><div class="line">var pattern2 = /\[bc\]at/i;</div><div class="line">// 匹配所有以“at”结尾的3个字符的组合，不区分大小写</div><div class="line">var pattern3 = /.at/gi;</div><div class="line">// 匹配所有“.at”，不区分大小写</div><div class="line">var pattern4 = /\.at/gi;</div></pre></td></tr></table></figure>
<p><br>    在上面的例子中，pattern1匹配第一个“bat”或“cat”，不区分大小写。而要想直接匹配“[bc]at”的话，就需要像定义pattern2一样，对其中的两个方括号进行转义。对于pattern3来说，句点表示位于“at”之前的任意一个可以构成匹配项的字符。但如果想匹配“.at”，则必须对句点本身进行转义，如pattern4所示。<br></p>

<p><br>    前面举的这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 匹配第一个“bat”或“cat”，不区分大小写</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">// 与pattern1相同，只不过是使用构造函数创建的</div><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure>
<p><br>    在此，pattern1和pattern2是两个完全等价的正则表达式。要注意的是，传递给RegExp构造函数的两个参数都是字符串(不能把正则表达式字面量传给RegExp构造函数)。有RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n(字符\在字符串中通常被转义为\,而在正则表达式字符串中就会变成\\)。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义相同模式时使用的字符串。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">字面量模式             等价的字符串</div><div class="line">/\[bc\]at/             &quot;\\[bc\\]at&quot;</div><div class="line">/\.at/                 &quot;\\.at&quot;</div><div class="line">/name\/age/            &quot;name\\/age&quot;</div><div class="line">/\d.\d&#123;1,2&#125;/           &quot;\\d.\\d&#123;1,2&#125;&quot;</div><div class="line">/\w\\hello\\123/       &quot;\\w\\\\hello\\\\123&quot;</div></pre></td></tr></table></figure>
<p><br>    使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var re = null,</div><div class="line">    i;</div><div class="line"></div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">	re = /cat/g;</div><div class="line">	re.test(&quot;catastrophe&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (i = 0; i &lt; 10; i++) &#123;</div><div class="line">	re = new RegExp(&quot;cat&quot;, &quot;g&quot;);</div><div class="line">	re.test(&quot;catastrophe&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在第一个循环中，即使是循环体指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性不会重置，所以在循环中再次调用test()方法会失败。这是因为第一个调用test()找到了“cat”。但第二次调用是从索引为3的字符(上一次匹配的末尾)开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就有从头开始了。<br></p>

<p><br>    第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp实例，所以每次调用test()都会返回true。<br></p>

<p><br>    ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一眼，每次都创建新的RegExp实例。IE9+、Firefox4+和Chrome都据此做出了修改。<br></p>

<h3 id="1-3-1-RegExp实例属性"><a href="#1-3-1-RegExp实例属性" class="headerlink" title="1.3.1 RegExp实例属性"></a>1.3.1 RegExp实例属性</h3><p><br>    RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a) global：布尔值，表示是否设置了g标志。</div><div class="line">b) ignoreCase：布尔值，表示是否设置了i标志。</div><div class="line">c) lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</div><div class="line">d) multiline：布尔值，表示是否设置了m标志。</div><div class="line">e) source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</div></pre></td></tr></table></figure>
<p><br>    通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var pattern1 = /\[bc\]at/i;</div><div class="line"></div><div class="line">alert(pattern1.global);		// false</div><div class="line">alert(pattern1.ignoreCase);	// true</div><div class="line">alert(pattern1.multiline);	// false</div><div class="line">alert(pattern1.lastIndex);	// 0</div><div class="line">alert(pattern1.source);		// &quot;\[bc\]at&quot;</div><div class="line"></div><div class="line">var pattern2 = new RegExp(&quot;\\[bc\\]at&quot;, &quot;i&quot;);</div><div class="line"></div><div class="line">alert(pattern2.global);		// false</div><div class="line">alert(pattern2.ignoreCase);	// true</div><div class="line">alert(pattern2.multiline);	// false</div><div class="line">alert(pattern2.lastIndex);	// 0</div><div class="line">alert(pattern2.source);		// &quot;\[bc\]at&quot;</div></pre></td></tr></table></figure>
<p><br>    我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了RegExp构造函数，但它们的source属性是相同的。可见，source属性保存的是规范形式的字符串，即字面量形式所用的字符串。<br></p>

<h3 id="1-3-2-RegExp实例方法"><a href="#1-3-2-RegExp实例方法" class="headerlink" title="1.3.2 RegExp实例方法"></a>1.3.2 RegExp实例方法</h3><p><br>    RegExp对象的主要方法是exec(),该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)。请看下面这个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var text = &quot;mom and dad and baby&quot;;</div><div class="line">var pattern = /mom( and dad( and baby)?)?/gi;</div><div class="line"></div><div class="line">var matches = pattern.exec(text);</div><div class="line">alert(matches.index);	// 0</div><div class="line">alert(matches.input);	// &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[0]);		// &quot;mom and dad and baby&quot;</div><div class="line">alert(matches[1]);		// &quot; and dad and baby&quot;</div><div class="line">alert(matches[2]);		// &quot; and baby&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的模式包含两个捕获组。最内部的捕获组匹配“and baby”，而包含它的捕获组匹配“and dad”或者“and dad and baby”。当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs的index属性值为0.数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。<br></p>

<p><br>    对于exec()方法而言，即使在模式中设置了全局标志(g),他每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pattern1 = /.at/;</div><div class="line"></div><div class="line">var matches = pattern1.exec(text);</div><div class="line">alert(matches.index);		// 0</div><div class="line">alert(matches[0]);			// cat</div><div class="line">alert(pattern.lastIndex);	// 0</div><div class="line"></div><div class="line">matches = pattern1.exec(text);</div><div class="line">alert(matches.index);		// 0</div><div class="line">alert(matches[0]);			// cat</div><div class="line">alert(matches.lastIndex);   // 0</div><div class="line"></div><div class="line">var pattern2 = /.at/g;</div><div class="line"></div><div class="line">var matches = pattern2.exec(text);</div><div class="line">alert(matches.index);		// 0</div><div class="line">alert(matches[0]);			// cat</div><div class="line">alert(pattern2.lastIndex);	// 3</div><div class="line"></div><div class="line">matches = pattern2.exec(text);</div><div class="line">alert(matches.index);		// 5</div><div class="line">alert(matches[0]);			// bat</div><div class="line">alert(pattern2.lastIndex);	// 8</div></pre></td></tr></table></figure>
<p><br>    这个例子中的第一个模式pattern1不是全局模式，因此每次调用exec()返回的都是第一个匹配项(“cat”)。而第二个模式pattern2是全局模式，因此每次调用exec()都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的lastIndex属性的变化情况。在全局匹配模式下，lastIndex的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。<br></p>

<blockquote>
<p>IE的JavaScript实现在lastIndex属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。</p>
</blockquote>
<p><br>    正则表达式的第二个方法是text()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;000-00-0000&quot;;</div><div class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</div><div class="line"></div><div class="line">if (pattern.text(text)) &#123;</div><div class="line">	alert(&quot;The pattern was matched.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们使用正则表达式来测试一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效就无关紧要了。<br></p>

<p><br>    RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var pattern = new RegExp(&quot;\\[bc\\]at&quot;, &quot;gi&quot;);</div><div class="line">alert(pattern.toString());			// /\[bc\]at/gi</div><div class="line">alert(pattern.toLocaleString());	// /\[bc\]at/gi</div></pre></td></tr></table></figure>
<p><br>    即使上例中的模式是通过调用RegExp构造函数创建的，但toLocaleString()和toString()方法仍然会像它是以字面量形式创建的一样显示其字符串表示。<br></p>

<blockquote>
<p>正则表达式的valueOf()方法返回正则表达式本身。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/变量、作用域和内存问题（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/变量、作用域和内存问题（二）/" itemprop="url">变量、作用域和内存变量（二）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-27T16:15:05+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-3-垃圾收集"><a href="#1-3-垃圾收集" class="headerlink" title="1.3 垃圾收集"></a>1.3 垃圾收集</h3><p><br>    JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在C和C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写JavaScript程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。<br></p>

<p><br>    下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈(或堆)内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有的情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。<br></p>

<h3 id="1-3-1-标记清除"><a href="#1-3-1-标记清除" class="headerlink" title="1.3.1 标记清除"></a>1.3.1 标记清除</h3><p><br>    JavaScript中最常用的垃圾收集方式是标记清除(mark-and-sweep).当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。<br></p>

<p><br>    可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。<br></p>

<p><br>    垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记(当然，可以使用任何标记方式)。然后，它会去掉环境中的变量以及被环境中的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br></p>

<p><br>    到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略(或类似的策略)，只不过垃圾收集的时间间隔互有不同。<br></p>

<h3 id="1-3-2-引用计数"><a href="#1-3-2-引用计数" class="headerlink" title="1.3.2 引用计数"></a>1.3.2 引用计数</h3><p><br>    另一种不太常见的垃圾收集策略叫做引用计数(reference counting)。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋给该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，这说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。<br></p>

<p><br>    Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。请看下面这个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function problem() &#123;</div><div class="line">    var objectA = new Object();</div><div class="line">    var objectB = new Object();</div><div class="line"></div><div class="line">    objectA.someOtherObject = objectB;</div><div class="line">    objectB.anotherObject = objectA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2.在采用标记清除策略的实现中，但函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不会是0.假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，NetScape在Navigator4.0中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。<br></p>

<p><br>    我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM(Component Object Model，组件对象模型)对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的JavaScript引擎是使用标记清除策略来实现的，但JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用COM对象导致的循环引用问题：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var element = document.getElementById(&quot;some_element&quot;);</div><div class="line">var myObject = new Object();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p><br>    这个例子在一个DOM元素(element)与一个原生JavaScript对象(myObject)之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个属性名叫someObject回指myObject。由于存在这个循环引用，即使将例子中的DOM从页面中移除，它也永远不会被回收。<br></p>

<p><br>    为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生JavaScript对象与DOM元素之间的链接。例如，可以使用下面的代码消除前面例子创建的循环引用：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = null;</div><div class="line">element.someObject = null;</div></pre></td></tr></table></figure>
<p><br>    将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。<br></p>

<p><br>    为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄露现象。<br></p>

<h3 id="1-3-3-性能问题"><a href="#1-3-3-性能问题" class="headerlink" title="1.3.3 性能问题"></a>1.3.3 性能问题</h3><p><br>    垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行一次，不禁让人联想到IE因此而声名狼藉的性能问题。IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象(或数组)字面量和数组元素(slot)或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。<br></p>

<p><br>    随着IE7的发布，其JavaScript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和(或)数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和(或)数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置或默认值。这一看似简单的调整，极大地提升了IE在运行包含大量JavaScript的页面时的性能。<br></p>

<h3 id="1-3-4-管理内存"><a href="#1-3-4-管理内存" class="headerlink" title="1.3.4 管理内存"></a>1.3.4 管理内存</h3><p><br>    使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是处于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。<br></p>

<p><br>    因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用(dereferencing)。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被接触引用，如下面这个例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function createPerson(name) &#123;</div><div class="line">    var localPerson = new Object();</div><div class="line">    localPerson.name = name;</div><div class="line">    return localPerson;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var globalPerson = createPerson(&quot;Nicholas&quot;);</div><div class="line"></div><div class="line">// 手工解除globalPerson的引用</div><div class="line">globalPerson = null;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，变量globalPerson取得了createPerson()函数返回的值。在createPerson()函数内部，我们创建了一个对象并将其赋给局部变量localPerson，然后又为该对象添加了一个名为name的属性。最后，当调用这个函数时，localPerson以函数值的形式返回并赋给全局变量globalPerson。由于localPerson在createPerson()函数执行完毕后就离开了其执行环境，因此，无须我们显式地去为它解除引用。但是对于全局变量globalPerson而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。<br></p>

<p><br>    不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。<br></p>

<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><br>    JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1) 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</div><div class="line">2) 从一个变量向另一个变量复制基本类型的值，会创建这个值的副本；</div><div class="line">3) 引用类型的值是对象，保存在堆内存中；</div><div class="line">4) 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</div><div class="line">5) 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都会指向同一个对象；</div><div class="line">6) 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。</div></pre></td></tr></table></figure>
<p><br>    所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) 执行环境有去全局执行环境(也称为全局环境)和函数执行环境之分；</div><div class="line">2) 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</div><div class="line">3) 函数的局部环境不仅有权访问函数作用域中变量，而且有权访问其包含(父)环境，乃至全局环境；</div><div class="line">4) 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</div><div class="line">5) 变量的执行环境有助于确定应该何时释放内存。</div></pre></td></tr></table></figure>
<p><br>    JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1) 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</div><div class="line">2) &quot;标记清除&quot;是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。</div><div class="line">3) 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象(如DOM元素)时，这种算法仍然可能会导致问题。</div><div class="line">4) 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</div><div class="line">5) 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/26/变量、作用域和内存问题（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/变量、作用域和内存问题（一）/" itemprop="url">变量、作用域和内存变量（一）——JavaScript高级程序设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T19:41:33+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>按照ECMA-262的定义，JavaScript的变量与其他语言的变量有很大区别。JavaScript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但JavaScript变量实际的复杂程度还远不止如此。</p>
</blockquote>
<h3 id="1-1-基本类型和引用类型的值"><a href="#1-1-基本类型和引用类型的值" class="headerlink" title="1.1 基本类型和引用类型的值"></a>1.1 基本类型和引用类型的值</h3><p><br>    ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。<br></p>

<p><br>    在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。基本数据类型：Undefined、Null、Boolean、Number和String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br></p>

<p><br>    引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。(这种说法不严密，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象)<br></p>

<blockquote>
<p>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。</p>
</blockquote>
<h3 id="1-1-1-动态的属性"><a href="#1-1-1-动态的属性" class="headerlink" title="1.1.1 动态的属性"></a>1.1.1 动态的属性</h3><p><br>    定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。请看下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了一个对象并将其保存在了变量person中。然后，我们为该对象添加了一个名为name的属性，并将字符串值“Nicholas”赋给了这个属性。紧接着，又通过alert()函数访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。<br></p>

<p><br>    但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。比如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name = &quot;Nicholas&quot;;</div><div class="line">name.age = 27;</div><div class="line">alert(name.age);	// undefined</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们为字符串name定义了一个名为age的属性，并为该属性赋值27.但在下一行访问这个属性时，发现该属性不见了。这说明只能给引用类型值动态地添加属性，以便将来使用。<br></p>

<h3 id="1-1-2-复制变量值"><a href="#1-1-2-复制变量值" class="headerlink" title="1.1.2 复制变量值"></a>1.1.2 复制变量值</h3><p><br>    除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。来看一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num1 = 5;</div><div class="line">var num2 = num1;</div></pre></td></tr></table></figure>
<p><br>    在此，num1中保存的值是5。当使用num1的值来初始化num2时，num2中也保存了值5.但num2中的5与num1中的5是完全独立的，该值只是num1中5的一个副本。此后，这个变量可以参与任何操作而不会相互影响。图1-1形象地真是了赋值基本类型值的过程。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-1.png"></p>
<div style="text-align: center;">图1-1 复制基本类型值的过程</div>

<p><br>    当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj1 = new Object();</div><div class="line">var obj2 = obj1;</div><div class="line">obj1.name = &quot;Nicholas&quot;;</div><div class="line">alert(obj2.name);	// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    首先，变量obj1保存了一个对象的新实例。然后，这个值被复制到了obj2中，换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加name属性后，可以通过obj2来访问这个属性，因为这两个变量引用的都是同一个对象。图1-2展示了保存在变量对象中的变量和保存在堆中的对象之间的这种关系。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-2.png"></p>
<div style="text-align: center;">图1-2 复制引用类型值的过程</div>

<h3 id="1-1-3-传递参数"><a href="#1-1-3-传递参数" class="headerlink" title="1.1.3 传递参数"></a>1.1.3 传递参数</h3><p><br>    ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。<br></p>

<p><br>    在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素)。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。请看下面这个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function addTen (num) &#123;</div><div class="line">    num += 10;</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line">var count = 20;</div><div class="line">var result = addTen(count);</div><div class="line">alert(count);	// 20, 没有变化</div><div class="line">alert(result);	// 30</div></pre></td></tr></table></figure>
<p><br>    这里的函数addTen()有一个参数num，而参数实际上是函数的局部变量。在调用这个函数时，变量count作为参数被传递给函数，这个变量的值是20.于是，数值20被复制给参数num以便在addTen()中使用。在函数内部，参数num的值被加上了10，但这一变化不会影响函数外部的count变量。参数num与变量count互不相识，它们仅仅是具有相同的值。假如num是按引用传递的话，那么变量count的值也将变成30，从而反映函数内部的修改。当然，使用数值等基本类型值来说明按值传递参数比较简单，但如果使用对象，那问题就不好理解了。再举一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function setName (obj) &#123;</div><div class="line">    obj.name = &quot;Nicholas&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码中创建一个对象，并将其保存在了变量person中。然后，这个变量被传递到setName()函数中之后就被复制给了obj。在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象。于是，当在函数内部为obj添加name属性后，函数外部的person也将有所反映；因为person所指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setName (obj) &#123;</div><div class="line">    obj.name = &quot;Nickolas&quot;;</div><div class="line">    obj = new Object();</div><div class="line">    obj.name = &quot;Greg&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);		// &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子与前一个例子的唯一区别，就是在setName()函数中添加了两行代码：一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。在把person传递给setName()后，其name属性被设置为“Nicholas”。然后，又将一个新对象赋给变量obj，同时将其name属性设置为“Greg”。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为“Greg”的新对象。但是，当接下来再访问person.name时，显示的值仍然是“Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。<br></p>

<blockquote>
<p>可以把ECMAScript函数的参数想象成局部变量。</p>
</blockquote>
<h3 id="1-1-4-检测类型"><a href="#1-1-4-检测类型" class="headerlink" title="1.1.4 检测类型"></a>1.1.4 检测类型</h3><p><br>    要检测一个变量是不是基本数据类型？typeof操作符是最佳的工具。说得更具体一点，typeof操作符是确定一个变量是字符串、数值、布尔值、还是undefined的最佳工具。如果变量的值是一个对象或null，则typeof操作符会像下面例子中所示的那样返回“object”：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var s = &quot;Nicholas&quot;;</div><div class="line">var b = true;</div><div class="line">var i = 22;</div><div class="line">var u;</div><div class="line">var n = null;</div><div class="line">var o = new Object();</div><div class="line"></div><div class="line">alert(typeof s);	// &quot;string&quot;</div><div class="line">alert(typeof i);	// &quot;number&quot;</div><div class="line">alert(typeof b);	// &quot;boolean&quot;</div><div class="line">alert(typeof u);	// &quot;undefined&quot;</div><div class="line">alert(typeof n);	// &quot;object&quot;</div><div class="line">alert(typeof o);	// &quot;object&quot;</div></pre></td></tr></table></figure>
<p><br>    虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符，其语法如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = variable instanceof constructor</div></pre></td></tr></table></figure>
<p><br>    如果变量是给定引用类型(根据它的原型链来识别)的实例，那么instanceof操作符就会返回true。请看下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(person instanceof Object);	// 变量person是Object吗？</div><div class="line">alert(colors instanceof Array);		// 变量colors是Array吗？</div><div class="line">alert(pattern instanceof RegExp);	// 变量pattern是RegExp吗？</div></pre></td></tr></table></figure>
<p><br>    根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。<br></p>

<blockquote>
<p>使用typeof操作符检测函数时，该操作符会返回“function”。在Safari 5及之前版本和Chrome 7及之前版本中使用typeof检测正则表达式时，由于规范的原因，这个操作符也返回“function”。ECMA-262规定任何在内部实现[[Call]]方法的对象都应该在应用typeof操作符时返回“function”。由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回“function”。在IE和Firefox中，对正则表达式应用typeof会返回“object”。</p>
</blockquote>
<h3 id="1-2-执行环境及作用域"><a href="#1-2-执行环境及作用域" class="headerlink" title="1.2 执行环境及作用域"></a>1.2 执行环境及作用域</h3><p><br>    执行环境(execution context, 为简单起见，有时也称为“环境”)是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<br></p>

<p><br>    全局执行环境是最外层的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁)。<br></p>

<p><br>    每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。<br></p>

<p><br>    当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象在最开始时只包含一个变量。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。<br></p>

<p><br>    标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止(如果找不到标识符，通常会导致错误发生)。请看下面的示例代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line">function changeColor () &#123;</div><div class="line">    if (color === &quot;blue&quot;) &#123;</div><div class="line">        color = &quot;red&quot;;</div><div class="line">    &#125; else &#123;</div><div class="line">        color = &quot;blue&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeColor();</div><div class="line">alert(&quot;Color is now &quot; + color);</div></pre></td></tr></table></figure>
<p><br>    在这个简单的例子中，函数changeColor()的作用域链包含两个对象：它自己的变量对象(其中定义着arguments对象)和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。<br></p>

<p><br>    此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function changeColor () &#123;</div><div class="line">	var anotherColor = &quot;red&quot;;</div><div class="line">	function swapColors () &#123;</div><div class="line">		var tempColor = anotherColor;</div><div class="line">		anotherColor = color;</div><div class="line">		color = tempColor;</div><div class="line">		// 这里可以访问color、anotherColor和tempColor</div><div class="line">	&#125;</div><div class="line">	// 这里可以访问color和anotherColor，但不能访问tempColor</div><div class="line">	swapColors();</div><div class="line">&#125;</div><div class="line">// 这里只能访问color</div><div class="line">changeColor();</div></pre></td></tr></table></figure>
<p><br>    以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。全局环境中有一个变量和一个函数changeColor()。changeColor()的局部环境中有一个名为anotherColor的变量和一个名为swapColors()的函数，但它也可以访问全局环境中的变量color。swapColors()的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到。无论全局环境还是changeColor()的局部环境都无权访问tempColor。然而，在swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境都是它的父执行环境。图1-3形象地展示了前面这个例子的作用域链。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-3.png"></p>
<div style="text-align: center;">图1-3</div>

<p><br>    图1-3中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的swapColors()而言，其作用域链中包含3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问swapColors()的环境。<br></p>

<blockquote>
<p>函数参数也被当做变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
</blockquote>
<h3 id="1-2-1-延长作用域链"><a href="#1-2-1-延长作用域链" class="headerlink" title="1.2.1 延长作用域链"></a>1.2.1 延长作用域链</h3><p><br>    虽然执行环境的类型总共只有两种——全局和局部(函数),但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a) try-catch语句的catch块；</div><div class="line">b) with语句。</div></pre></td></tr></table></figure>
<p><br>    这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。下面看一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function buildUrl () &#123;</div><div class="line">    var qs = &quot;?debug=true&quot;;</div><div class="line">    with(location) &#123;</div><div class="line">        var url = href + qs;</div><div class="line">    &#125;</div><div class="line">    return url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在此，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量qs。当在with语句中引用变量href时(实际引用的是location.href)，可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。<br></p>

<blockquote>
<p>在IE8及之前版本的JavaScript实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。</p>
</blockquote>
<h3 id="1-2-2-没有块级作用域"><a href="#1-2-2-没有块级作用域" class="headerlink" title="1.2.2 没有块级作用域"></a>1.2.2 没有块级作用域</h3><p><br>    JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码块都有自己的作用域(如果用ECMAScript的话来讲，就是它们自己的执行环境)，因而支持根据条件来定义变量。例如，下面的代码在JavaScript中并不会得到想象中的结果：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    var color = &quot;blue&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(color);	// &quot;blue&quot;</div></pre></td></tr></table></figure>
<p><br>    这里实在一个if语句中定义了变量color。如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境(在这里是全局环境)中。在使用for语句时尤其要牢记这一差异，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i);	// 10</div></pre></td></tr></table></figure>
<p><br>    对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。<br></p>

<h3 id="1、声明变量"><a href="#1、声明变量" class="headerlink" title="1、声明变量"></a>1、声明变量</h3><p><br>    使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add (num1, num2) &#123;</div><div class="line">    var sum = num1 + num2;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">var result = add(10, 20);	// 30</div><div class="line">alert(sum);		// 由于sum不是有效的变量，因此会导致错误</div></pre></td></tr></table></figure>
<p><br>    以上代码中的函数add()定义了一个名为sum的局部变量，该变量包含加法操作的结果。虽然结果值从函数中返回了，但变量sum在函数外部是访问不到的。如果省略这个例子中的var关键字，那么当add()执行完毕后，sum也将可以访问到：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add (num1, num2) &#123;</div><div class="line">    sum = num1 + num2;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">var result = add(10, 20);	// 30</div><div class="line">alert(sum);		// 30</div></pre></td></tr></table></figure>
<p><br>    这个例子中的变量sum在被初始化赋值时没有使用var关键字。于是，当调用完add()之后，添加到全局环境中的变量sum将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。<br></p>

<blockquote>
<p>在编写JavaScript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。</p>
</blockquote>
<h3 id="2、查询标识符"><a href="#2、查询标识符" class="headerlink" title="2、查询标识符"></a>2、查询标识符</h3><p><br>    当在某个环境中为了读取或写入而引用一个标识符，必须通过搜索来确定标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。<br></p>

<p><br>    通过下面这个示例，可以理解查询标识符的过程：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function getColor () &#123;</div><div class="line">    return color;    	</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor());	// &quot;blue&quot;</div></pre></td></tr></table></figure>
<p><br>    调用本例中的函数getColor()时会引用变量color。为了确定变量color的值，将开始一个两步的搜索过程。首先，搜索getColor()的变量对象，查找其中是否包含一个名为color的标识符。在没有找到的情况下，搜索继续到下一个变量对象(全局环境的变量对象)，然后在那里找到了名为color的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。图1-4形象地展示了上述搜索过程。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-4-4.png"></p>
<div style="text-align: center;">图1-4</div>

<p><br>    在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，如下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var color = &quot;blue&quot;;</div><div class="line"></div><div class="line">function getColor () &#123;</div><div class="line">	var color = &quot;red&quot;;</div><div class="line">	return color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor());	// &quot;red&quot;</div></pre></td></tr></table></figure>
<p><br>    修改后的代码在getColor()函数中声明了一个名为color的局部变量。调用函数时，该变量就会被声明。而当函数中的第二行代码执行时，意味着必须找到并返回变量color的值。搜索过程首先从局部环境中开始，而且在这里发现了一个名为color的变量，其值为“red”。因为变量已经找到了，所以搜索即行停止，return语句就使用这个局部变量，并为函数会返回“red”。也就是说，任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。<br></p>

<blockquote>
<p>变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/25/群书治要360（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/25/群书治要360（一）/" itemprop="url">群書治要360 (一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-25T17:35:33+08:00">
                2017-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="《群書治要》序"><a href="#《群書治要》序" class="headerlink" title="《群書治要》序"></a>《群書治要》序</h3><p><br>    《群書治要》是唐太宗李世明（西元五九九年——六四九年）於貞觀初年下令編輯。太宗十六歲隨父從軍，起義平定動亂的社會，戎馬倥傯十餘年。二十七歲即帝位後，偃武修文，特別留心於治平之道，休生養民。<br></p>

<p><br>    太宗英武善辯，遺憾早年從軍，讀書不多。鑒於前隋滅亡之失，深知創業不易，守成維艱，在位期間，鼓勵群臣進諫，批評其決策過失。令諫官魏征及虞世南等，整理歷代帝王治國資政史料，擷取六經、四史、諸子百家中，有關修身、齊家、治國、平天下之精要，匯編成書。上始五帝，下迄晉代，自一萬四千多部、八萬九千多卷古籍中，博采典籍六十五種，共五十餘萬言。<br></p>

<p><br>    書成，如魏征於序文中所說，實為一部[用之當今你，足以鑒覽前古；傅之來葉，可以貽厥孫謀]的治世寶典。太宗喜其廣博而切要，日日手不釋卷。曰：[使我稽古臨事不惑者，卿等力也]。由是而知<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/25/数组（3）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/25/数组（3）/" itemprop="url">数组(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-25T09:29:19+08:00">
                2017-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-10-数组类型"><a href="#1-10-数组类型" class="headerlink" title="1.10 数组类型"></a>1.10 数组类型</h3><p><br>    给定一个未知的对象，判定它是否为数组通常非常有用。在ECMAScript 5中，可以使用Array.isArray()函数来做这件事情：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Array.isArray([])	// =&gt; true</div><div class="line">Array.isArray(&#123;&#125;)	// =&gt; false</div></pre></td></tr></table></figure>
<p><br>    但是，在ECMAScript 5之前，要区分数组和非数组对象却令人惊讶地困难。typeof操作符在这里帮不上忙：对数组它返回“对象”(并且对于除了函数以外的所有对象都是如此)。instanceof操作符只能用于简单的情形：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[] instanceof Array 	// =&gt; true</div><div class="line">(&#123;&#125;) instanceof Array 	// =&gt; false</div></pre></td></tr></table></figure>
<p><br>    使用instanceof的问题是在Web浏览器中有可能有多个窗口或窗体(frame)存在。每个窗口都有自己的JavaScript环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明instanceof操作符不能视为一个可靠的数组检测方法。<br></p>

<p><br>    解决方案是检查对象的类属性。对数组而言该属性的值总是“Array”，因此在ECMAScript 3中isArray()函数的代码可以这样书写：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var isArray = Function.isArray || function(o) &#123;</div><div class="line">    return typeof o === &quot;object&quot; &amp;&amp;</div><div class="line">    Object.prototype.toString.call(o) === &quot;[object Array]&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    实际上，此处类属性的检测就是ECMAScript 5中的Array.isArray()函数所做的事情。获得对象类属性的技术使用了Object.prototype.toString()方法。<br></p>

<h3 id="1-11-类数组对象"><a href="#1-11-类数组对象" class="headerlink" title="1.11 类数组对象"></a>1.11 类数组对象</h3><p><br>    我们已经看到，JavaScript数组的有一些特性是其他对象所没有的：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a) 当有新的元素添加到列表中时，自动更新length属性。</div><div class="line">b) 设置length为一个较小值将截断数组。</div><div class="line">c) 从Array.prototype中继承一些有用的方法。</div><div class="line">d) 其类属性为“Array”。</div></pre></td></tr></table></figure>
<p><br>    这些特性让JavaScript数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法把拥有一个数值length属性和对应的非负整数属性的对象看做一种类型的数组。<br></p>

<p><br>    实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望length属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。<br></p>

<p><br>    以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&#125;;		// 从一个常规空对象开始</div><div class="line">// 添加一些属性，称为“类数组”</div><div class="line">var i = 0;</div><div class="line">while(i &lt; 10) &#123;</div><div class="line">    a[i] = i * i;</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line">a.length = i;</div><div class="line">// 现在，当做真正的数组遍历它</div><div class="line">var total = 0;</div><div class="line">for(var j = 0; j &lt; a.length; j++)</div><div class="line">    total += a[j];</div></pre></td></tr></table></figure>
<p><br>    像Arguments对象就是一个类数组对象。在客户端JavaScript中，一些DOM方法(如document.getElementsByTagName())也返回类数组对象。下面有一个函数可以用来检测类数组对象：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 判定o是否是一个类数组对象</div><div class="line">// 字符串和函数有length属性，但是它们</div><div class="line">// 可以用typeof检测将其排除。在客户端JavaScript中，DOM文本节点</div><div class="line">// 也有length属性，需要额外判断o.nodeType != 3将其排除</div><div class="line">function isArrayLike(o) &#123;</div><div class="line">    if (o &amp;&amp;									// o非null、undefined等</div><div class="line">        typeof o === &quot;object&quot; &amp;&amp;				// o是对象</div><div class="line">        isFinite(o.length) &amp;&amp;					// o.length是有限数值</div><div class="line">        o.length &gt;= 0 &amp;&amp;						// o.length为非负值</div><div class="line">        o.length === Math.floor(o.length) &amp;&amp;	// o.length是整数</div><div class="line">        o.lenght &lt; 4294967296					// o.length &lt; 2^32</div><div class="line">    )</div><div class="line">        return true;	// o是类数组对象</div><div class="line">    else</div><div class="line">        return false;	// 否则它不是</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在后面看到在ECMAScript 5中字符串的行为与数组类似(并且有些浏览器在ECMAScript 5之前已经让字符串变成可索引的了)。然而，类似上述的类数组对象的检测方法针对字符串常常返回false——它们通常最好当做字符串处理，而非数组。<br></p>

<p><br>    JavaScript数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。在ECMAScript 5中，所有的数组方法都是通用的。在ECMAScript 3中，除了toString()和toLocaleString()以外的所有方法也是通用的(concat()方法是一个特例：虽然可以用在类数组对象上，但它没有将那个对象扩充进返回的数组中。)既然类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。尽管如此，可以间接地使用Function.call方法调用：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;, length: 3&#125;;	// 类数组对象</div><div class="line">Array.prototype.join.call(a, &quot;+&quot;)	// =&gt; &quot;a+b+c&quot;</div><div class="line">Array.prototype.slice.call(a, 0)	// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]：真正数组的副本</div><div class="line">Array.prototype.map.call(a, function(x) &#123;</div><div class="line">    return x.toUpperCase();</div><div class="line">&#125;)		// =&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</div></pre></td></tr></table></figure>
<p><br>    ECMAScript 5数组方法是在Firefox 1.5中引入的。由于它们的写法的一般性，Firefox还将这些方法的版本在Array构造函数上直接定义为函数。使用这些方法定义的版本，上述例子就可以这样重写：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;, length: 3&#125;;	// 类数组对象</div><div class="line">Array.join(a, &quot;+&quot;)</div><div class="line">Array.slice(a, 0)</div><div class="line">Array.map(a, function(x) &#123; return x.toUpperCase(); &#125;)</div></pre></td></tr></table></figure>
<p><br>    当用在类数组对象上时，数组方法的静态函数版本非常有用。但既然它们不是标准的，不能期望它们在所有的浏览器中都有定义。可以这样书写代码来保证使用它们之前是存在的：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Array.join = Array.join || function(a, sep) &#123;</div><div class="line">    return Array.prototype.join.call(a, sep);</div><div class="line">&#125;;</div><div class="line">Array.slice = Array.slice || function(a, from, to) &#123;</div><div class="line">    return Array.prototype.slice.call(a, from, to);</div><div class="line">&#125;;</div><div class="line">Array.map = Array.map || function(a, f, thisArg) &#123;</div><div class="line">    return Array.prototype.map.call(a, f, thisArg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-12-作为数组的字符串"><a href="#1-12-作为数组的字符串" class="headerlink" title="1.12 作为数组的字符串"></a>1.12 作为数组的字符串</h3><p><br>    在ECMAScript 5(在众多最近的浏览器实现——包括IE8——早于ECMAScript 5)中，字符串的行为类似于只读的数组。除了用charAt()方法来访问单个的字符以外，还可以使用方括号：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s = test;</div><div class="line">s.chatAt(0)		// =&gt; &quot;t&quot;</div><div class="line">s[1]			// =&gt; &quot;e&quot;</div></pre></td></tr></table></figure>
<p><br>    当然，针对字符串的typeof操作符仍然返回“string”，但是如果给Array.isArray()传递字符串，它将返回false。<br></p>

<p><br>    可索引的字符串的最大的好处就是简单，用方括号代替了chatAt()调用，这样更加简洁、可读并且可能更高效。不仅如此，字符串的行为类似于数组的事实使得通用的数组方法可以用到字符串上。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = &quot;JavaScript&quot;</div><div class="line">Array.prototype.join.call(s, &quot;&quot;)	// =&gt; &quot;J a v a S c r i p t&quot;</div><div class="line">Array.prototype.filter.call(s,		// =&gt; 过滤字符串中的字符</div><div class="line">    function(x) &#123;</div><div class="line">        return x.match(/[^aeiou]/);	// =&gt; 只匹配非元音字母</div><div class="line"> &#125;).join(&quot;&quot;)						// =&gt; &quot;JvScrpt&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><br>    请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()和splice()等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/数组（2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/数组（2）/" itemprop="url">数组(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T09:23:15+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-8-数组方法"><a href="#1-8-数组方法" class="headerlink" title="1.8 数组方法"></a>1.8 数组方法</h3><blockquote>
<p>ECMAScript 3在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。下面将先介绍ECMAScript 3中的这些方法。然后还涉及到ECMAScript 5中新增的一些数组遍历方法。</p>
</blockquote>
<h3 id="1-8-1-join"><a href="#1-8-1-join" class="headerlink" title="1.8.1 join()"></a>1.8.1 join()</h3><p><br>    Array.join()方法将数组中的所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。如以下代码所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3];	// 创建一个包含三个元素的数组</div><div class="line">a.join();			// =&gt; &quot;1, 2, 3&quot;</div><div class="line">a.join(&quot; &quot;);		// =&gt; &quot;1 2 3&quot;</div><div class="line">a.join(&quot;&quot;);			// =&gt; &quot;123&quot;</div><div class="line">var b = new Array(10);	// 长度为10的空数组</div><div class="line">b.join(&apos;-&apos;)			// =&gt; &apos;----------&apos;：9个连字号组成的字符串</div></pre></td></tr></table></figure>
<p><br>    Array.join()方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。<br></p>

<h3 id="1-8-2-reverse"><a href="#1-8-2-reverse" class="headerlink" title="1.8.2 reverse()"></a>1.8.2 reverse()</h3><p><br>    Array.reverse()方法将数组中的元素颠倒顺序，返回逆序的数组。它采取了替换，换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们。例如，下面的代码使用reverse()和join()方法生成字符串“3, 2, 1”：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3];</div><div class="line">a.reverse().join()	// =&gt; &quot;3, 2, 1&quot;,并且现在的a是[3, 2, 1]</div></pre></td></tr></table></figure>
<h3 id="1-8-3-sort"><a href="#1-8-3-sort" class="headerlink" title="1.8.3 sort()"></a>1.8.3 sort()</h3><p><br>    Array.sort()方法将数组中的元素排序并返回排序后的数组。当不带参数调用sort()时，数组元素以字母表顺序排序(如果有必要将临时转化为字符串进行比较):<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = new Array(&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;);</div><div class="line">a.sort();</div><div class="line">var s = a.join(&quot;, &quot;);	// s == &quot;apple, banana, cherry&quot;</div></pre></td></tr></table></figure>
<p><br>    如果数组包含undefined元素，它们会被排到数组的尾部。为了按照其他方式而非字母表顺序进行数组排序，必须给sort()方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于0的数组。反之，假设第一个参数在后，函数应该返回一个大于0的数值。并且，假设两个值相等(也就是说，它们的顺序无关紧要),函数应该返回0.因此，用数值大小而非字母表顺序进行数组排序，代码如下：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = [33, 4, 1111, 222];</div><div class="line">a.sort();	// 字母表顺序： 1111, 222, 33, 4</div><div class="line">a.sort(function(a, b) &#123;	// 数值顺序：4, 33, 222, 1111</div><div class="line">    return a-b;		// 根据顺序，返回负数、0、正数</div><div class="line">&#125;);</div><div class="line">a.sort(function(a, b) &#123; return b-a &#125;);	// 数值大小相反的顺序</div></pre></td></tr></table></figure>
<p><br>    注意，这里使用匿名函数表达式非常方便。既然比较函数只是用一次，就没必要给它们命名了。<br></p>

<p><br>    另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表顺序，比较函数首先将参数都转化为小写字符串(使用toLowerCase()方法)，再开始比较：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a = [&apos;ant&apos;, &apos;Bug&apos;, &apos;cat&apos;, &apos;Dog&apos;]</div><div class="line">a.sort();	// 区分大小写的排序：[&apos;Bug&apos;, &apos;Dog&apos;, &apos;ant&apos;, &apos;cat&apos;]</div><div class="line">a.sort(function(s, t) &#123;	// 不区分大小写的排序</div><div class="line">    var a = s.toLowerCase();</div><div class="line">    var b = t.toLowerCase();</div><div class="line">    if (a &lt; b) return -1;</div><div class="line">    if (a &gt; b) return 1;</div><div class="line">    return 0;</div><div class="line">&#125;);		// =&gt; [&apos;ant&apos;, &apos;Bug&apos;, &apos;cat&apos;, &apos;Dog&apos;]</div></pre></td></tr></table></figure>
<h3 id="1-8-4-concat"><a href="#1-8-4-concat" class="headerlink" title="1.8.4 concat()"></a>1.8.4 concat()</h3><p><br>    Array.concat()方法创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连续的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化数组的数组。concat()也不会修改调用的数组。下面有一些示例：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3];</div><div class="line">a.concat(4, 5)		// 返回[1, 2, 3, 4, 5]</div><div class="line">a.concat([4, 5]);	// 返回[1, 2, 3, 4, 5]</div><div class="line">a.concat([4, 5], [6, 7])	// 返回[1, 2, 3, 4, 5, 6, 7]</div><div class="line">a.concat(4, [5, [6, 7]])	// 返回[1, 2, 3, 4, 5, [6, 7]]</div></pre></td></tr></table></figure>
<h3 id="1-8-5-slice"><a href="#1-8-5-slice" class="headerlink" title="1.8.5 slice()"></a>1.8.5 slice()</h3><p><br>    Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不包含第二个参数指定的位置之间的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如果参数中出现负数，它表示相对于数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。注意，slice()不会修改调用的数组。下面有一些示例：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5];</div><div class="line">a.slice(0, 3);		// 返回[1, 2, 3]</div><div class="line">a.slice(3);			// 返回[4, 5]</div><div class="line">a.slice(1, -1);		// 返回[2, 3, 4]</div><div class="line">a.slice(-3, -2);	// 返回[3]</div></pre></td></tr></table></figure>
<h3 id="1-8-6-splice"><a href="#1-8-6-splice" class="headerlink" title="1.8.6 splice()"></a>1.8.6 splice()</h3><p><br>    Array.splice()方法是在数组中插入或删除元素的通用方法。不同于slice()和concat()，splice()会修改调用的数组。注意，splice()和slice()拥有非常相似的名字，但它们的功能却有本质的区别。<br></p>

<p><br>    splice()能够从数组中删除元素、插入元素到数组中或者同事完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减少它们的索引值，因此数组的其他部分仍然保持连续的。splice()的第一个参数指定了插入和(或)删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice()返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5, 6, 7, 8];</div><div class="line">a.splice(4);	// 返回[5, 6, 7, 8]; a是[1, 2, 3, 4]</div><div class="line">a.splice(1, 2);	// 返回[2, 3]; a是[1, 4]</div><div class="line">a.splice(1, 1);	// 返回[4]; a是[1]</div></pre></td></tr></table></figure>
<p><br>    splice()的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5];</div><div class="line">a.splice(2, 0, &apos;a&apos;, &apos;b&apos;);	// 返回[]; a是[1, 2, &apos;a&apos;, &apos;b&apos;, 3, 4, 5]</div><div class="line">a.splice(2, 2, [1, 2], 3);	// 返回[&apos;a&apos;, &apos;b&apos;]; a是[1, 2, [1, 2], 3, 4, 5]</div></pre></td></tr></table></figure>
<p><br>    注意，区别于concat(),splice()会插入数组本身而非数组的元素。<br></p>

<h3 id="1-8-7-push-和pop"><a href="#1-8-7-push-和pop" class="headerlink" title="1.8.7 push()和pop()"></a>1.8.7 push()和pop()</h3><p><br>    push()和pop()方法允许将数组当做栈来调用。push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop()方法则相反：它删除数组的最后一个元素，减少数组长度并返回它删除的值。注意，这两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用push()和pop()能够用JavaScript数组实现先进后出的栈。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var stack = [];		// stack：[]</div><div class="line">stack.push(1, 2);	// stack: [1, 2]	返回2</div><div class="line">stack.pop();		// stack: [1]		返回2</div><div class="line">stack.push(3);		// stack: [1, 3]	返回2</div><div class="line">stack.pop();		// stack: [1]		返回3</div><div class="line">stack.push([4, 5])	// stack: [1, [4, 5]] 返回2</div><div class="line">stack.pop() 		// stack: [1]		返回[4, 5]</div><div class="line">stack.pop();		// stack: []		返回1</div></pre></td></tr></table></figure>
<h3 id="1-8-8-unshift-和shift"><a href="#1-8-8-unshift-和shift" class="headerlink" title="1.8.8 unshift()和shift()"></a>1.8.8 unshift()和shift()</h3><p><br>    unshift()和shift()方法的行为非常类似于push()和pop(),不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。unshift()在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。shift()删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = [];				// a: []</div><div class="line">a.unshift(1);			// a: [1]				返回：1</div><div class="line">a.unshift(22);			// a: [22, 1]			返回：2</div><div class="line">a.shift();				// a: [1]				返回22</div><div class="line">a.unshift(3, [4, 5]);	// a: [3, [4, 5], 1]	返回3</div><div class="line">a.shift();				// a: [[4, 5], 1]		返回3</div><div class="line">a.shift();				// a: [1]				返回：[4, 5]</div><div class="line">a.shift();				// a: []				返回： 1</div></pre></td></tr></table></figure>
<p><br>    注意，当使用多个参数调用unshift()时它的行为令人惊讶。参数是一次性插入的(就像splice()方法)而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。<br></p>

<h3 id="1-8-9-toString-和toLocaleString"><a href="#1-8-9-toString-和toLocaleString" class="headerlink" title="1.8.9 toString()和toLocaleString()"></a>1.8.9 toString()和toLocaleString()</h3><p><br>    数组和其他JavaScript对象一样拥有toString()方法。针对数组，该方法将其每个元素转换为字符串(如有必要将调用元素的toString()方法)并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].toString()		// 生成&apos;1, 2, 3&apos;</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].toString()	// 生成&apos;a, b, c&apos;</div><div class="line">[1, [2, &apos;c&apos;]].toString()	// 生成&apos;1, 2, c&apos;</div></pre></td></tr></table></figure>
<p><br>    注意，这里与不使用任何参数调用join()方法返回的字符串是一样的。<br></p>

<p><br>    toLocaleString()是toString()方法的本地化版本。它调用元素的toLocaleString()方法将每个数组元素转化为字符串，并且使用本地化(和自定义实现的)分隔符将这些字符串连接起来生成最终的字符串。<br></p>

<h3 id="1-9-ECMAScript-5中的数组方法"><a href="#1-9-ECMAScript-5中的数组方法" class="headerlink" title="1.9 ECMAScript 5中的数组方法"></a>1.9 ECMAScript 5中的数组方法</h3><p><br>    ECMAScript 5定义了9个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组，下面将分别介绍这些方法。<br></p>

<p><br>    但在开始详细介绍之前，很有必要对ECMAScript 5中的数组方法做一个概述。首先，大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，可以忽略后两个参数。大多数ECMAScript 5数组方法的第一个参数是一个函数，第二个参数是可选的。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用的函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript 5中的数组方法都不会修改它们调用的原始数组。当然，传递给这些方法的函数是可以修改这些数组的。<br></p>

<h3 id="1-9-1-forEach"><a href="#1-9-1-forEach" class="headerlink" title="1.9.1 forEach()"></a>1.9.1 forEach()</h3><p><br>    forEach()方法从头至尾遍历数组，为每个元素调用指定的函数。如上所述，传递的函数作为forEach()的第一个参数。然后forEach()使用三个参数调用该函数：数组元素、元素的索引和数组本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var data = [1, 2, 3, 4, 5];		// 要求和的数组</div><div class="line">// 计算数组元素和值</div><div class="line">var sum = 0;		// 初始为0</div><div class="line">data.forEach(function(value) &#123; sum += value; &#125;);	// 将每个值累加到sum上</div><div class="line">sum 				// =&gt; 15</div><div class="line">// 每个数组元素的值自加1</div><div class="line">data.forEach(function(v, i, a) &#123; a[i] = v + 1; &#125;);</div><div class="line">data 				// =&gt; [2, 3, 4, 5, 6]</div></pre></td></tr></table></figure>
<p><br>    注意，forEach()无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach方法放到一个try块中，并能抛出一个异常。如果forEach()调用的函数抛出foreach.break异常，循环会提前终止：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foreach(a, f, t) &#123;</div><div class="line">    try &#123;</div><div class="line">        a.forEach(f, t);</div><div class="line">    &#125; catch(e) &#123;</div><div class="line">        if (e === foreach.break) return;</div><div class="line">        else throw e;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foreach.break = new Error(&quot;StopInteration&quot;);</div></pre></td></tr></table></figure>
<h3 id="1-9-2-map"><a href="#1-9-2-map" class="headerlink" title="1.9.2 map()"></a>1.9.2 map()</h3><p><br>    map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3];</div><div class="line">b = a.map(function(x) &#123; return x*x; &#125;);		// b是[1, 4, 9]</div></pre></td></tr></table></figure>
<p><br>    传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该有返回值。注意，map()返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素/<br></p>

<h3 id="1-9-3-filter"><a href="#1-9-3-filter" class="headerlink" title="1.9.3 filter()"></a>1.9.3 filter()</h3><p><br>    filter()方法返回的数组元素的一个子集。传递的函数是用来逻辑判定的：该函数返回true或false。调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [5, 4, 3, 2, 1];</div><div class="line">smallvalues = a.filter(function(x) &#123; return x &lt; 3 &#125;);	// [2, 1]</div><div class="line">everyother = a.filter(function(x, i) &#123; return i % 2 &#125;);	// [5, 3, 1]</div></pre></td></tr></table></figure>
<p><br>    注意，filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var dense = sparse.filter(function() &#123; return true; &#125;);</div></pre></td></tr></table></figure>
<p><br>    甚至，压缩空缺并删除undefined和null元素，可以这样使用filter():<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = a.filter(function(x) &#123; return x !== undefined &amp;&amp; x != null; &#125;);</div></pre></td></tr></table></figure>
<h3 id="1-9-4-every-和some"><a href="#1-9-4-every-和some" class="headerlink" title="1.9.4 every()和some()"></a>1.9.4 every()和some()</h3><p><br>    every()和some()方法是数组的逻辑判定：它们对数组应用指定的函数进行判定，返回true或false。<br></p>

<p><br>    every()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定函数都返回ture，它才返回true：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3, 4, 5];</div><div class="line">a.every(function(x) &#123; return x &lt; 10; &#125;)	// =&gt; true：所有的值小于10</div><div class="line">a.every(function(x) &#123; return x % 2 === 0; &#125;)	// =&gt; false：不是所有的值都是偶数</div></pre></td></tr></table></figure>
<p><br>    some()方法就像数学中的“存在”量词：当数组中至少有一个元素调用判定函数返回true，它就返回true；并且仅当数值中的所有元素调用判定函数都返回false，它才返回false：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3, 4, 5];</div><div class="line">a.some(function(x) &#123; return x%2 === 0; &#125;)	// =&gt; true：a含有偶数值</div><div class="line">a.some(isNaN)		// false：a不包含非数值元素</div></pre></td></tr></table></figure>
<p><br>    注意，一旦every()和some()确认该返回什么值时它们就会停止遍历数组元素。some()在判定函数第一次返回true就返回true，但如果判定函数一直返回false，它将会遍历整个数组。every()恰好相反：它在判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将遍历整个数组。注意，根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false.<br></p>

<h3 id="1-9-5-reduce-和reduceRight"><a href="#1-9-5-reduce-和reduceRight" class="headerlink" title="1.9.5 reduce()和reduceRight()"></a>1.9.5 reduce()和reduceRight()</h3><p><br>    reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。举例来说它是如何工作的：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4, 5];</div><div class="line">var sum = a.reduce(function(x, y) &#123; return x+y &#125;, 0);		// 数组求和</div><div class="line">var product = a.reduce(function(x, y) &#123; return x*y &#125;, 1);	// 数组求积</div><div class="line">var max = a.reduce(function(x, y) &#123; return (x&gt;y)?x:y &#125;);	// 求最大值</div></pre></td></tr></table></figure>
<p><br>    reduce()需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。<br></p>

<p><br>    reduce()使用的函数与forEach()和map()使用的函数不同。比较熟悉的是，数组元素、元素索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止化简操作累积的结果。第一次调用函数时，第一个参数是一个初始值，它就是传递给reduce()的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在上面的第一个例子中，第一次调用化简函数时的参数是0和1.将两者相加并返回1.再次调用时的参数是1和2，它返回3.然后它计算3+3=6、6+4=10，最后计算10+5=15.最后的值是15.reduce()返回这个值。<br></p>

<p><br>    可能已经注意到了，上面第三次调用reduce()时只有一个参数：没有指定初始值。当不指定初始值调用reduce()时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个数组参数。在上面求和与求积的例子中，可以省略初始值参数。<br></p>

<p><br>    在空数组上，不带初始值参数调用reduce()将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值——reduce()只是简单地返回那个值而不会调用化简函数。<br></p>

<p><br>    reduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低(从右到左)处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，你可能想使用它，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4];</div><div class="line">// 计算2^(3^4)。乘方操作的优先顺序是从右到左</div><div class="line">var big = a.reduceRight(function(accumulator, value) &#123;</div><div class="line">    return Math.pow(value, accumulator);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><br>    注意，reduce()和reduceRight()都能接收一个可选的参数，它指定了化简函数调用时this关键字的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，请参看Function.bind()方法。<br></p>

<p><br>    值得注意的是，上面描述的every()和some()方法是一种类型的数组化简操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。<br></p>

<p><br>    为了简单起见，到目前位置所展示的例子都是数值的，但数学计算不是reduce()和reduceRight()的唯一意图。union()函数。它计算两个对象的“并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和化简函数一样，并且可以使用reduce()来把它一般化，计算任意数目的对象的“并集”。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var objects = [&#123;x: 1&#125;, &#123;y: 2&#125;, &#123;z: 3&#125;];</div><div class="line">var merged = objects.reduce(union);	// =&gt; &#123;x: 1, y: 2, z: 3&#125;</div></pre></td></tr></table></figure>
<p><br>    回想一下，当两个对象拥有同名的属性时，union()函数使用第一个参数的属性值。这样，reduce()和reduceRight()在使用union()时给出了不同的结果：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var objects = [&#123;x: 1, a: 1&#125;, &#123;y: 2, a: 2&#125;, &#123;z: 3, a: 3&#125;];</div><div class="line">var leftunion = objects.reduce(union);	// &#123;x: 1, y: 2, z: 3, a: 1&#125;</div><div class="line">var rightunion = objects.reduceRIght(union);	// &#123;x: 1, y: 2, z: 3, a: 3&#125;</div></pre></td></tr></table></figure>
<h3 id="1-9-6-indexOf-和lastIndexOf"><a href="#1-9-6-indexOf-和lastIndexOf" class="headerlink" title="1.9.6 indexOf()和lastIndexOf()"></a>1.9.6 indexOf()和lastIndexOf()</h3><p><br>    indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1.indexOf()从头至尾搜索，而lastIndexOf()则反向搜索。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [0, 1, 2, 1, 0];</div><div class="line">a.indexOf(1)	// =&gt; 1：a[1]是1</div><div class="line">a.lastIndexOf(1)	// =&gt; 3：a[3]是1</div><div class="line">a.indexOf(3)		// =&gt; -1：没有值为3的元素</div></pre></td></tr></table></figure>
<p><br>    不同于本节描述的其他方法，indexOf()和lastIndexOf()方法不接收一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索。如果省略该参数，indexOf()从头开始搜索，而lastIndexOf()从末尾开始搜索。第二个参数也可以是负数，它代表相对数组末尾的偏移量，对于splice()方法：例如，-1指定数组的最后一个元素。<br></p>

<p><br>    如下函数在第一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用indexOf()的第二个参数来查找除了第一个以外匹配的值。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 在数组中查找所有出现的x，并返回一个包含匹配索引的数组</div><div class="line">function findall(a, x) &#123;</div><div class="line">    var results = [],</div><div class="line">        len = a.length,</div><div class="line">        pos = 0;</div><div class="line">    while(pos &lt; len) &#123;</div><div class="line">        pos = a.indexOf(x, pos);</div><div class="line">        if (pos === -1) break;</div><div class="line">        results.push(pos);</div><div class="line">        pos = pos + 1;</div><div class="line"> &#125;</div><div class="line"> return results;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    注意，字符串也有indexOf()和lastIndexOf()方法，它们和数组方法的功能类似。<br></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/23/数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/数组/" itemprop="url">数组(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T15:15:22+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。JavaScript数组的索引是基于零的32位数值：第一个元素的索引为0，最大可能的索引为4 294 967 294（2^32-2）,数组最大能容纳4 294 967 295个元素。JavaScript数组是动态的：根据需要他们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个JavaScript数组都有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length比所有元素的索引都要大。</p>
<p>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规对象属性要快很多。</p>
<p>数组继承自Array.prototype中的属性，它定义了一套丰富的数组操作方法。大多数这些方法是通用的，这意味着它们不仅对真正的数组有效，而且对“类数组对象”同样有效。 </p>
</blockquote>
<h3 id="1-1-创建数组"><a href="#1-1-创建数组" class="headerlink" title="1.1 创建数组"></a>1.1 创建数组</h3><p><br>    使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var empty = [];		// 没有元素的数组</div><div class="line">var primes = [2, 3, 5, 7, 11];	// 有5个数值的数组</div><div class="line">var misc = [1.1, true, &apos;a&apos;,];	// 3个不同类型的元素和结尾的逗号</div></pre></td></tr></table></figure>
<p><br>    数组直接量中的值不一定要是常量；它们可以是任意的表达式：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var base = 1024;</div><div class="line">var table = [base, base+1, base+2, base+3];</div></pre></td></tr></table></figure>
<p><br>    它可以包含对象直接量或其他数组直接量：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var b = [[1, &#123;x: 1, y:2 &#125;], [2, &#123;x: 3, y: 4 &#125;]];</div></pre></td></tr></table></figure>
<p><br>    如果省略数组直接量中的某个值，省略的元素将被赋予undefined值：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var count = [1,,3];	// 数组有3个元素，中间的哪个元素值为undefined</div><div class="line">var undefs = [,,];	// 数组有2个元素，都是undefined</div></pre></td></tr></table></figure>
<p><br>    数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。<br></p>

<p><br>    调用构造函数Array()是创建数组的另一种方法。可以用三种方式调用构造函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">a) 调用时没有参数</div><div class="line">var a = new Array();</div><div class="line">该方法创建一个没有任何元素的空数组，等同于数组直接量[].</div><div class="line"></div><div class="line">b) 调用时有一个数值参数，它指定长度：</div><div class="line">var a = new Array(10);</div><div class="line">该技术创建指定长度的数组。当预先知道所需元素个数时，这种形式的Array()构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还未定义。</div><div class="line"></div><div class="line">c) 显式指定两个或多个数组元素或者数组的一个非数值元素：</div><div class="line">var a = new Array(5, 4, 3, 2, 1, &quot;testing, testing&quot;);</div><div class="line">以这种形式，构造函数的参数将会成为新数组的元素。使用数组字面量比这样使用Array()构造函数要简单多了。</div></pre></td></tr></table></figure>
<h3 id="1-2-数组元素的读和写"><a href="#1-2-数组元素的读和写" class="headerlink" title="1.2 数组元素的读和写"></a>1.2 数组元素的读和写</h3><p><br>    使用[]操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的JavaScript语句：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [&quot;world&quot;];	// 从一个元素的数组开始</div><div class="line">var value = a[0];	// 读第0个元素</div><div class="line">a[1] = 3.14;		// 写第一个元素</div><div class="line">i = 2;</div><div class="line">a[i] = 3;			// 写第二个元素</div><div class="line">a[i + 1] = &quot;hello&quot;;	// 写第三个元素</div><div class="line">a[a[i]] = a[0];		// 读第0个元素和第2个元素，写第三个元素</div></pre></td></tr></table></figure>
<p><br>    请记住，数组是对象的特殊形式。使用方括号访问数组元素就像方括号访问对象的属性一样。JavaScript将指定的数字索引值转换成字符串——索引值1变成“1”——然后将其作为属性名来使用。关于索引值从数字转换为字符串没有什么特别支持：对常规对象也可以这么做：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">o = &#123;&#125;;			// 创建一个普通对象</div><div class="line">o[1] = &quot;one&quot;;	// 用一个整数来索引它</div></pre></td></tr></table></figure>
<p><br>    数组的特别之处在于，当使用小于2^32的非负整数作为属性名时数组会自动维护其length属性值。如上，创建仅有一个元素的数组。然后，在索引1、2和3处分别进行赋值。当我们这么做时数组的length属性值变为：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.length 	// =&gt; 4</div></pre></td></tr></table></figure>
<p><br>    清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有0~2^32-2之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但是如果使用的属性是数组的索引，数组的特殊性为就是将根据需要更新它们的length属性值。<br></p>

<p><br>    注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果碰巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性，当使用的一个浮点数和一个整数相等时情况也是一样的：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[-1.23] = true;	// 这将创建一个名为“-1.23”的属性</div><div class="line">a[&quot;1000&quot;] = 0;		// 这是数组的第1001个元素</div><div class="line">a[1.000]			// 和a[1]相等</div></pre></td></tr></table></figure>
<p><br>    事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着JavaScript数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到undefined值。类似于对象，对于对象同样存在这种情况。<br></p>

<p><br>    既然数组是对象，那么它们可以从原型中继承元素。在ECMAScript 5中，数组可以定义元素的getter和setter方法，你应该期望它使用非优化的代码路径：访问这种数组的元素时间会与常规对象属性的查找相近。<br></p>

<h3 id="1-3-稀疏数组"><a href="#1-3-稀疏数组" class="headerlink" title="1.3 稀疏数组"></a>1.3 稀疏数组</h3><p><br>    稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。可以用Array()构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = new Array(5);	// 数组没有元素，但是a.length是5</div><div class="line">a = [];				// 创建一个空数组，length=0</div><div class="line">a[1000] = 0;		// 赋值添加一个元素，但是设置length为1001</div></pre></td></tr></table></figure>
<p>后面会看到你也可以用delete操作符来生产稀疏数组。</p>

<p><br>    足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。<br></p>

<p><br>    注意，当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为undefined。这和数组元素根本不存在时有一些微妙的区别的。可以用in操作符检测两者之间的区别：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a1 = [,,,];			// 数组是[undefined, undefined, undefined]</div><div class="line">var a2 = new Array(3);	// 该数组根本没有元素</div><div class="line">0 in a1					// =&gt; true：a1在索引0处有一个元素</div><div class="line">0 in a1					// =&gt; false：a2在索引0处没有元素</div></pre></td></tr></table></figure>
<p>当使用for/in循环时，a1和a2之间的区别也很明显。</p>

<p><br>    在一些旧版本的实现中（比如Firefox），在存在连续逗号的情况下，插入undefined值的操作则与此不同，在这些实现中，[1,,3]和[1,undefined,3]是一模一样的。<br></p>

<p><br>    了解稀疏数组是了解JavaScript数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数JavaScript数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能向对待非稀疏数组一样来对待它们，只不过它们包含一些undefined值。<br></p>

<h3 id="1-4-数组长度"><a href="#1-4-数组长度" class="headerlink" title="1.4 数组长度"></a>1.4 数组长度</h3><p><br>    每个数组有一个length属性，就是这个属性使其区别于常规的JavaScript对象。针对稠密(也就是非稀疏)数组,length属性值代表数组中元素的个数。其值比数组中最大的索引大1：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[].length 				// =&gt; 0: 数组没有元素</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].length 	// =&gt; 3: 最大的索引为2，length为3</div></pre></td></tr></table></figure>
<p><br>    当数组是稀疏的时，length属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中(无论稀疏与否)肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1。<br></p>

<p><br>    第二个特殊行为就是设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3, 4, 5];	// 从5个元素的数组开始</div><div class="line">a.length = 3;			// 现在a为[1, 2, 3]</div><div class="line">a.length = 0;			// 删除所有的元素。a为[]</div><div class="line">a.length = 5;			// 长度为5，但是镁元素，就像new Array(5)</div></pre></td></tr></table></figure>
<p><br>    还可以将数组的length属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。<br></p>

<p>在ECMAScript 5中，可以用Object.defineProperty()让数组的length属性值变成只读的：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3];	// 从3个元素的数组开始</div><div class="line">Object.defineProperty(a, &quot;length&quot;, &#123; writable: false &#125;);	// 让length属性只读</div><div class="line">a.length = 0;	// a不会改变</div></pre></td></tr></table></figure>
<p><br>    类似地，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，length属性不能设置为小于不可配置元素的索引值。<br></p>

<h3 id="7-5-数组元素的添加和删除"><a href="#7-5-数组元素的添加和删除" class="headerlink" title="7.5 数组元素的添加和删除"></a>7.5 数组元素的添加和删除</h3><p>我们已经见过添加数组元素最简单的方法：为新索引赋值：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = []			// 开始是一个空数组</div><div class="line">a[0] = &quot;zero&quot;;	// 然后向其中添加元素</div><div class="line">a[1] = &quot;one&quot;;</div></pre></td></tr></table></figure>
<p>也可以使用push()方法在数组末尾增加一个或多个元素：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [];		// 开始是一个空数组</div><div class="line">a.push(&quot;zero&quot;)		// 在末尾添加一个元素。a = [&quot;zero&quot;]</div><div class="line">a.push(&quot;one&quot;, &quot;two&quot;)	// 再添加两个元素。a = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</div></pre></td></tr></table></figure>
<p><br>    在数组尾部压入一个元素与给数组a[a.length]赋值是一样的。可以使用unshift()方法在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。<br></p>

<p>可以像删除对象属性一样使用delete运算符来删除数组元素：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3];</div><div class="line">delete a[1];	// a在索引1的位置不再有元素</div><div class="line">1 in a 			// =&gt; false：数组索引1并未在数组中定义</div><div class="line">a.length 		// =&gt; 3：delete操作并不影响数组长度</div></pre></td></tr></table></figure>
<p><br>    删除数组元素与为其赋undefined值是类似的(但有一些微妙的区别).注意，对一个数组元素使用delete不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，他就变成稀疏数组。<br></p>

<p><br>    上面我们看到，也可以简单地设置length属性为一个新的期望长度来删除数组尾部的元素。数组有pop()方法(它和push()一起使用)，后者一次使减少长度1并返回被删除元素的值。还有一个shift()方法(它和unshift()一起使用)，从数组头部删除一个元素。和delete不同的是shift()方法将所有元素下移到比当前索引低1的地方。<br></p>

<p><br>    最后，splice()是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改length属性并移动元素到更高或更低的索引处。<br></p>

<h3 id="1-6-数组遍历"><a href="#1-6-数组遍历" class="headerlink" title="1.6 数组遍历"></a>1.6 数组遍历</h3><p>使用for循环时遍历数组元素最常见的方法：</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var keys = Object.keys(o);	// 获取对象属性名组成的数组</div><div class="line">var values = []				// 在数组中存储匹配属性的值</div><div class="line">for (var i = 0; i &lt; keys.length; i++) &#123;		// 对于数组中每个索引</div><div class="line">	var key = keys[i];	// 获取索引处的键值</div><div class="line">	values[i] = o[key];	// 在values数组中保存属性值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">    // 循环体仍然不变</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这些例子假设数组是稠密的，并且多有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。如果想要排除null、undefined和不存在的元素，代码如下：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; a.length; i++) &#123;</div><div class="line">    if (!a[i]) continue;	// 跳过null、undefined和不存在的元素</div><div class="line">    // 循环体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    如果指向跳过undefined和不存在的元素，代码如下：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; a.length; i++) &#123;</div><div class="line">    if (a[i] === undefined) continue;	// 跳过undefined+不存在的元素</div><div class="line">    // 循环体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    还可以使用for/in循环处理稀疏数组。循环每次将一个可枚举的属性名(包括数组索引)赋值给循环变量。不存在的索引将不会遍历到：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var index in sparseArray) &#123;</div><div class="line">    var value = sparseArrayp[index];</div><div class="line">    // 此处可以使用索引和值做一些事情</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    我们已经注意到了for/in循环能够枚举继承的属性名，如添加到Array.prototype中的方法。由于这个原因，在数组上不应该使用for/in循环，除非使用额外的检测方法来过滤不想要的属性。如下检测代码取其一即可：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for(var i in a) &#123;</div><div class="line">    if (!a.hasOwnProperty(i)) continue;	// 跳过继承的属性</div><div class="line">    // 循环体</div><div class="line">&#125;</div><div class="line">for(var i in a) &#123;</div><div class="line">    // 跳过不是非负整数的i</div><div class="line">    if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    ECMAScript规范允许for/in循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。特别地，如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如果处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用for/in而用常规的for循环。<br></p>

<p><br>    ECMAScript 5定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数。这些方法中最常用的就是forEach()方法：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var data = [1, 2, 3, 4, 5];		// 这是需要遍历的数组</div><div class="line">var sumOfSquares = 0;			// 要得到数据的平方和</div><div class="line">data.forEach(function(x) &#123;		// 把每个元素传递给此函数</div><div class="line">    sumOfSquares += x*x;		// 平方相加</div><div class="line">&#125;);</div><div class="line">sumOfSquares					// =&gt; 55: 1+4+9+16+25</div><div class="line"></div><div class="line">forEach()和相关的遍历方法使得数组拥有简单而强大的函数式编程风格。</div></pre></td></tr></table></figure>
<h3 id="1-7-多维数组"><a href="#1-7-多维数组" class="headerlink" title="1.7 多维数组"></a>1.7 多维数组</h3><p><br>    JavaScript不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次[]操作符即可。例如，假设变量matrix是一个数组的数组，它的基本元素是数值，那么matrix[x]的每个元素是包含一个数值数组，访问数组中特定数值的代码为matrix[x][y].这里有一个具体的例子,它使用二维数组作为一个九九乘法表：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 创建一个多维数组</div><div class="line">var table = new Array(10);	// 表格有10行</div><div class="line">for (var i = 0; i &lt; table.length; i++) &#123;</div><div class="line">    table[i] = new Array(10);	// 每列有10行</div><div class="line">&#125;</div><div class="line">// 初始化数组</div><div class="line">for (var row = 0; row &lt; table.length; row++) &#123;</div><div class="line">    for (col = 0; col &lt; table[row].length; col++) &#123;</div><div class="line">        table[row][col] = row * col;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 使用多为数组来计算(查询)5*7</div><div class="line">var product = table[5][7];	// 35</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/23/window对象（2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/window对象（2）/" itemprop="url">Window对象(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T15:09:22+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-1-计时器"><a href="#1-1-计时器" class="headerlink" title="1.1 计时器"></a>1.1 计时器</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/21/window对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/21/window对象/" itemprop="url">Window对象(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-21T17:26:26+08:00">
                2017-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-1-计时器"><a href="#1-1-计时器" class="headerlink" title="1.1 计时器"></a>1.1 计时器</h3><p><br>    setTimeout()和setInterval()可以用来注册在指定的时间之后单次或重复调用的函数。它们都是客户端JavaScript中重要的全局函数，所以定义为Window对象的方法，但作为通用函数，其实不会对窗口做什么事情。<br></p>

<p><br>    Window对象的setTimeout()方法用来实现一个函数在指定的毫秒数之后运行。setTimeout()返回一个值，这个值可以传递给clearTimeout()用于取消这个函数的执行。<br></p>

<p><br>    setInterval()和setTimeout()一样，只不过这个函数会在指定毫秒数的间隔里重复调用：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setInterval(updateClock, 60000);	// 每60秒调用一次updateClock()</div></pre></td></tr></table></figure>
<p><br>    和setTimeout()一样，setInterval()也返回一个值，这个值可以传递给clearInterval()，用于取消后续函数的调用。<br></p>

<p><br>    例1-1定义的应用函数会在等待指定的时间之后，开始重复调用某个函数，然后又过了一段时间之后取消函数调用。该例子演示了setTimeout()、setInterval()和clearInterval()的用法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">例1-1：定时器应用函数</div><div class="line">/*</div><div class="line">  安排函数f()在未来的调用模式在等待了若干毫秒</div><div class="line">  之后调用f()，如果设置了interval并没有设置end</div><div class="line">  参数，则对f()调用将不会停止，如果没有设置interval</div><div class="line">  和end，只在若干毫秒后调用f()一次，只有指定了</div><div class="line">  f(),才会从start=0的时刻开始。注意，调用invoke()</div><div class="line">  不会阻塞，它会立即返回。</div><div class="line">*/</div><div class="line">function invoke(f, start, interval, end) &#123;</div><div class="line">    if (!start) start = 0;	// 默认设置为0毫秒</div><div class="line">    if (arguments.length &lt;= 2)	// 单次调用模式</div><div class="line">        setTimeout(f, start);	// 若干毫秒后的单次调用模式</div><div class="line">    else &#123;		// 多次调用模式</div><div class="line">        setTimeout(repeat, start);	// 在若干毫秒后调用repeat()</div><div class="line">        function repeat () &#123;	// 在上一行所示的setTimeout()中调用</div><div class="line">            var h = setInterval(f, interval);	// 循环调用f()</div><div class="line">            // 在end毫秒后停止调用，前提是end已经定义了</div><div class="line">            if (end) setTimeout(function () &#123; clearInterval(h); &#125;, end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    由于历史原因，setTimeout()和setInterval()的第一个参数可以作为字符串传入。如果这么做，那这个字符串会在指定的超时时间或间隔时间之后进行求值(相当于执行eval())，除前两个参数之外，HTML5规范(除IE之外的所有浏览器)还允许setTimeout()和setInterval()传入额外的参数，并在调用函数时把这些参数传递过去，然而，如果需要支持IE的话，就不要应用此特性了。<br></p>

<p><br>    如果以0毫秒的超时时间来调用setTimeout(),那么指定的函数不会立刻执行。相反，会把它放到队列中，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。<br></p>

<h3 id="1-2-浏览器定位和导航"><a href="#1-2-浏览器定位和导航" class="headerlink" title="1.2 浏览器定位和导航"></a>1.2 浏览器定位和导航</h3><p><br>    Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL，并定义了方法来使窗口载入新的文档。<br></p>

<p><br>    Document对象的location属性也引用到Location对象：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.location === document.location 	// 总是返回true</div></pre></td></tr></table></figure>
<p><br>    Document对象也有一个URL属性，是文档首次载入后保存该文档的URL的静态字符串。如果定位到文档中的片段标识符(如#table-of-contents),Location对象会做相应的更新，而document.URL属性却不会改变。<br></p>

<h3 id="1-2-1-解析URL"><a href="#1-2-1-解析URL" class="headerlink" title="1.2.1 解析URL"></a>1.2.1 解析URL</h3><p><br>    Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL。Location对象的href属性是一个字符串，后者包含URL的完整文本。Location对象的toString()方法返回href属性的值，因此在会隐式调用toString()的情况下，可以使用location代替location.href.<br></p>

<p><br>    这个对象的其他属性——protocol，host，hostname，port，pathname和search，分别表示URL的各个部分。它们称为“URL分解”属性，同时被Link对象(通过HTML文档中的<a>和<area>元素创建)支持。<br></a></p>

<p><br>    Location对象的hash和search属性比较有趣。如果有的话，hash属性返回URL中的“片段标识符”部分。search属性也类似，它返回的是问好之后的URL，这部分通常是某种类型的查询字符串。一般来说，这部分内容是用来参数化URL并在其中嵌入参数的。虽然这些参数通常用于运行在服务器上的脚本，但在启用JavaScript的页面中当然也可以使用它们。例1-2展示了一个通用函数urlArgs()的定义，可以用这个函数将参数从URL的search属性中提取出来。该例子用到了decodeURIComponent(),后者是在客户端JavaScript定义的全局函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">例1-2：提取URL的搜索字符串中的参数</div><div class="line">/*</div><div class="line">  这个函数用来解析来自URL的查询串中的name=value参数对</div><div class="line">  它将name=value对存储在一个对象的属性中，并返回该对象</div><div class="line">  这样来使用它</div><div class="line"></div><div class="line">  var args = urlArgs();	// 从URL中解析参数</div><div class="line">  var q = args.q || &quot;&quot;;	// 如果参数定义了的话就使用参数；否则使用一个默认值</div><div class="line">  var n = args.n ? parseInt(args.n) : 10;</div><div class="line">*/</div><div class="line">function urlArgs () &#123;</div><div class="line">    var args = &#123;&#125;;		// 定义一个空对象</div><div class="line">    var query = location.search.substring(1);	// 查找到查询串，并去掉&apos;?&apos;</div><div class="line">    var pairs = query.split(&apos;&amp;&apos;);	// 根据“&amp;”符号将查询字符串分隔开</div><div class="line">    for (var i = 0; i &lt; pairs.length; i++) &#123;	// 对于每个片段</div><div class="line">        var pos = pairs[i].indexOf(&apos;=&apos;);	// 查找“name=value”</div><div class="line">        if (pos === -1) continue;	// 如果没有找到的话，就跳过</div><div class="line">        var name = pairs[i].substring(0, pos);	// 提取name</div><div class="line">        var value = pairs[i].substring(pos + 1);	// 提取value</div><div class="line">        value = decodeURIComponent(value);	// 对value进行解码</div><div class="line">        args[name] = value;		// 存储为属性</div><div class="line">    &#125;</div><div class="line">    return args;	// 返回解析后的参数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-2-载入新的文档"><a href="#1-2-2-载入新的文档" class="headerlink" title="1.2.2 载入新的文档"></a>1.2.2 载入新的文档</h3><p><br>    Location对象的assign()方法可以使窗口载入并显示你指定的URL中的文档。replace()方法也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。如果脚本无条件地载入一个新文档，replace()方法可能是比assign()方法更好的选择。否则，“后退”按钮会把浏览器带回到原始文档，而相同的脚本则会再次载入新文档。如果检测到用户的浏览器不支持某些特性来显示功能齐全的版本，可以用location.replace()来载入动态的HTML版本。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 如果浏览器不支持XMLHttpRequest对象</div><div class="line">// 则将其重定向到一个不需要Ajax的静态页面</div><div class="line">if (!XMLHttpRequest) location.replace(&apos;staticpage.html&apos;);</div></pre></td></tr></table></figure>
<p><br>    注意，在这个例子中传入replace()的是一个相对URL。相对URL是相对于当前页面所在的目录来解析的，就像它们用于一个超链接中。<br></p>

<p><br>    除了assign()和replace()方法，location对象还定义了reload()方法，后者可以让浏览器重新载入当前文档。<br></p>

<p><br>    使浏览器跳转到新页面的一种更传统的方法是直接把新的URL赋给location属性：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = &quot;http://www.oreilly.com&quot;;</div></pre></td></tr></table></figure>
<p><br>    还可以把相对URL赋给location，它们会相对当前URL进行解析：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = &quot;page2.html&quot;;	// 载入下一个页面</div></pre></td></tr></table></figure>
<p><br>    纯粹的片段标识符是相对URL的一种类型，它不会让浏览器载入新文档，但只会使它滚动到文档的某个位置。#top标识符是个特殊的例子：如果文档中没有元素的ID是“top”，它会让浏览器跳到文档开始处。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = “#top”;	// 跳转到文档的顶部</div></pre></td></tr></table></figure>
<p><br>    Location对象的URL分解属性是可写的，对它们重新赋值会改变URL的位置，并且导致浏览器载入一个新的文档(如果改变的是hash属性，则在当前文档中进行跳转)：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.search = &quot;?page=&quot; + (pagenum + 1);	// 载入下一个页面</div></pre></td></tr></table></figure>
<h3 id="1-3-浏览历史"><a href="#1-3-浏览历史" class="headerlink" title="1.3 浏览历史"></a>1.3 浏览历史</h3><p><br>    Window对象的history属性引用的是该窗口的History对象。History对象是用来把窗口的浏览历史用文档和文档状态列表的形式表示。History对象的length属性表示浏览历史列表中的元素数量，但出于安全的因素，脚本不能访问已保存的URL。(如果允许，则任意脚本都可以窥探你的浏览历史.)<br></p>

<p><br>    History对象的back()和forward()方法与浏览器的“后退”和“前进”按钮一样：它们使浏览器在浏览历史中前后跳转一格。第三个方法——go()接受一个整数参数，可以在历史列表中向前(正参数)或向后(负参数)跳过任意多个页。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.go(-2);	// 后退两个历史记录，相当于单击“后退”按钮两次</div></pre></td></tr></table></figure>
<p><br>    如果窗口包含多个子窗口(比如iframe元素)，子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用history.back()(举例)可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。<br></p>

<p><br>    现代Web应用可以不通过载入新文档而动态地改变自身内容。这么做可能希望用户能用“后退”和“前进”按钮在这些动态创建的应用状态之间进行跳转。HTML5将这种技术标准化。<br></p>

<p><br>    HTML5之前的历史管理是个更复杂的难题。应用程序必须要在窗口浏览历史中创建一个新的条目来管理自身的历史记录，用历史条目关联自身的状态信息，判断什么时候用户使用了“后退”按钮来移动到不同的历史条目，联合那个条目获取状态信息，并且重新创建应用程序之前的状态。一种方式是用隐藏的iframe来保存状态信息并在浏览器的历史中创建条目。为了创建新的历史条目，需要用Document对象的open()和write()方法动态地把一个新文档写入这个隐藏的窗体。不管怎样，文档内容应该包含重新创建应用状态所需要的状态信息。当用户点击“后退”按钮，隐藏的窗体的内容会改变。在HTML5之前，没有生成事件来通知你这个改变，因此，为了检测用户是否单击了“后退”按钮，可能要用setInterval()每秒对隐藏的窗体检测两到三次，来看它是否改变了。<br></p>

<h3 id="用HTML5进行历史管理"><a href="#用HTML5进行历史管理" class="headerlink" title="用HTML5进行历史管理"></a>用HTML5进行历史管理</h3><p><br>    Web浏览器会记录一个窗口中载入的所有文档，同时提供了“后退”和“前进”按钮，允许用户在这些文档之间切换浏览。这种浏览器历史记录模型最早在“文档都是被动的，所有的计算都在服务器上完成”那个时期就已经存在了。如今，Web应用通常都是动态地生成或载入页面内容，并在无须刷新页面的情况下就显示新的应用状态。如果想要提供用户能够通过浏览器的“后退”和“前进”按钮，直观的切换应用状态，像这类应用就必须自己处理应用的历史记录管理。HTML5定义了两种用于历史记录管理的机制。<br></p>

<p><br>    其中比较简单的历史记录管理技术就是利用location.hash和hashchange事件。截至撰写本书时，这种技术一直也是比较广泛实现的：浏览器甚至在HTML5标准化之前就已经开始实现该技术了。在绝大多数浏览器中(IE早期版本除外)，设置location.hash属性会更新显示在地址栏中的URL，同时会在浏览器的历史记录中添加一条记录。hash属性设置URL的片段标识符，通常用于指定要滚动到的文档中某一部分的ID。但是location.hash不一定非要设置为一个元素的ID：它可以设置成任何的字符串。如果能够将应用状态编码成一个字符串，就可以使用该字符串作为片段标识符。<br></p>

<p><br>    设置了location.hash属性后，接下来要实现允许用户通过“后退”和“前进”按钮来切换不同的文档状态。这个时候，应用必须要想办法检测状态变化，以便它能够读取出存储在片段标识符中的状态并相应地更新自己的状态。支持HTML5的浏览器一旦发现片段标识符发生了改变，就会在Window对象上触发一个hashchange事件。这样，在支持hashchange事件的浏览器中，就可以通过设置window.onhashchange为一个处理程序函数，使得每次由于切换历史记录导致片段标识符变化的时候，都会调用该处理程序函数。当调用该处理程序函数的时候，就可以对location.hash的值进行解析，然后使用该值包含的状态信息来重新显示应用。<br></p>

<p><br>    HTML5还定义了一个相对更复杂和强健的历史记录管理方法，该方法包含history。pushState()方法和popstate事件。当一个Web应用进入一个新的状态的时候，它会调用history.pushState()方法将该状态添加到浏览器的浏览历史记录中。该方法的第一个参数是一个对象，该对象包含用于恢复当前文档状态所需的所有信息。该对象可以是任何能够通过JSON.stringify()方法转换成相应字符串形式的对象，也可以是其他类似Date和RegExp这样特定的本地类型。该方法的第二个可选参数是一个可选的标题(普通的文本字符串)，浏览器可以使用它(比如，在一个<back>菜单中)来标识浏览历史记录中保存的状态。该方法的第三个参数是一个可选的URL，表示当前状态的位置。相对的URL都是以文档的当前位置为参照，通常该URL只是简单地指定URL(诸如#state)这样的hash(或者“片段标识符”)部分。将一个URL和状态关联，可以允许用户将应用的内部状态作为书签添加到浏览器中，并当URL中包含足够信息的时候，应用可以在从书签中载入的时候就恢复它的状态。<br></back></p>

<p><br>    除了pushState()方法之外，History对象还定义了replaceState()方法，该方法和pushState()方法接收同样的参数，但是不同的是，它不是将新的状态添加到浏览器的历史记录中，而是用新的状态代替当前的历史状态。<br></p>

<p><br>    当用户通过“后退”和“前进”按钮浏览保存的历史状态时，浏览器会在Window对象上触发一个popstate事件。与该事件相关联的事件对象有一个state属性，该属性包含传递给pushState()方法的状态对象的副本(另一种结构性复制)。<br></p>

<blockquote>
<p>结构性复制：正如上面提到的，pushState()方法接受一个状态对象并为该对象创建一份私有副本。这是对一个对象进行深拷贝或者深复制：它会递归地复制所有嵌套对象或者数组的内容。HTML5标准将这类复制称为“结构性复制”(structured clone)。创建一个结构性复制的过程就好比是将一个对象传递给JSON.stringify()方法，然后再将结果字符串传递给JSON.parse()方法。但是JSON只支持JavaScript的基础类型和对象以及数组。在HTML5标准中提到，结构性复制算法必须还能够复制Date对象、RegExp对象、ImageData对象、FileList对象、File对象以及Blob对象。但是在结构性复制算法中会显式排除JavaScript中的函数和错误以及绝大部分诸如窗口、文档、元素等这类宿主对象。</p>
</blockquote>
<h3 id="1-4-浏览器和屏幕信息"><a href="#1-4-浏览器和屏幕信息" class="headerlink" title="1.4 浏览器和屏幕信息"></a>1.4 浏览器和屏幕信息</h3><blockquote>
<p>脚本有时候需要获取和它们所在的Web浏览器或浏览器所在的桌面相关信息。将要介绍Window对象的navigator和screen属性。它们分别引用的是Navigator和Screen对象，而这些对象提供的信息允许脚本来根据环境定制自己的行为。</p>
</blockquote>
<h3 id="1-4-1-Navigator对象"><a href="#1-4-1-Navigator对象" class="headerlink" title="1.4.1 Navigator对象"></a>1.4.1 Navigator对象</h3><p><br>    Window对象的navigator属性引用的是包含浏览器厂商和版本信息的Navigator对象。Navigator对象的命名是为了纪念Netscape之后Navigator浏览器，不过所有其他的浏览器也支持它(IE还支持clientInformation属性，它作为navigator的厂商中立同义词。遗憾的是，其他浏览器并不支持这一更直观的属性命名)。<br></p>

<p><br>    过去，Navigator对象通常被脚本用来确定它们是在IE中还是在Netscape中运行。这种浏览器嗅探方法有问题，因为它要求随着新浏览器和现有浏览器的新版本的引入而不断地调整。如今，有一种更好的功能测试方法，只需要测试所需要的功能(即，方法或属性)，而不是假设特定的浏览器版本及其功能。<br></p>

<p><br>    然而，浏览器嗅探有时候仍然有价值。这样的一种情况是，当需要解决存在于某个特定的浏览器的特定版本中的特殊的bug时。Navigator对象有4个属性用于提供关于运行中的浏览器的版本信息，并且可以使用这些属性进行浏览器嗅探。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">appName</div><div class="line">    Web浏览器的全称。在IE中，这就是“Microsoft Internet Explorer”。在Firefox中，该属性就是“Netscape”。为了兼容现存的浏览器的嗅探代码，其他浏览器通常也取值为“Netscape”。</div><div class="line"></div><div class="line">appVersion</div><div class="line">    此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是4.0或5.0，表示它是第4或第5代兼容的浏览器。appVersion字符串没有标准的格式，所以，没有办法直接用它来判断浏览器的类型。</div><div class="line"></div><div class="line">userAgent</div><div class="line">    浏览器在它的USER-AGENT HTTP头部中发送的字符串。这个属性通常包含appVersion中的所有信息，并且常常也可能包含其他的细节。和appVersion一样，它也没有标准的格式。由于这个属性包含绝大部分信息，因此浏览器嗅探代码通常用它来嗅探。</div><div class="line"></div><div class="line">platform</div><div class="line">    在其上运行浏览器的操作系统(并且可能是硬件)的字符串。</div></pre></td></tr></table></figure>
<p><br>    Navigator属性的复杂性正说明了浏览器嗅探对于处理客户端兼容性问题是没有太大帮助的。在Web的早期，人们写了大量的浏览器特定代码用于测试类似于navigator.appName的属性。在开发新浏览器的时候，浏览器厂商发现为了让现有网站显示正确，它们需要把appName设置为“Netscape”。类似的做法使得appVersion的起始数字失去了意义，而现在的浏览器嗅探代码必须要依赖于比之前复杂很多的navigator.userAgent字符串。例1-3展示了如何使用正则表达式(摘自jQuery)从navigator.userAgent中抽取浏览器名称和版本号的方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">例1-3：使用navigator.userAgent来进行浏览器嗅探</div><div class="line">// 为客户端嗅探定义browser.name和browser.version,这里使用了jQuery1.4.1中的代码</div><div class="line">// name和number都是字符串，对于不同的浏览器输出的结果也是不一样的，检测结果如下：</div><div class="line">//</div><div class="line">// &quot;webkit&quot;：Safari或Chrome;版本号是Webkit的版本号</div><div class="line">// &quot;opera&quot;：Opera;版本号就是软件的版本号</div><div class="line">// &quot;mozilla&quot;：Firefox或者其他基于gecko内核的浏览器;版本号是Gecko的版本</div><div class="line">// &quot;msie&quot;：IE;版本号就是软件的版本</div><div class="line">//</div><div class="line">// 比如Firefox 3.6返回：&#123; name：“mozilla”，version：“1.9.2” &#125;</div><div class="line">var browser = (function() &#123;</div><div class="line">    var s = navigator.userAgent.toLowerCase();</div><div class="line">    var match = /(webkit)[\/]([\w.]+)/.exec(s) ||</div><div class="line">	    /(opera)(?:.*version)?[\/]([\w.]+)/.exec(s) ||</div><div class="line">	    /(mise)([\w.]+)/.exec(s) ||</div><div class="line">	    !/compatible/.test(s) &amp;&amp; /(mozilla)(?:.*? rv:([\w.]+))?/.exec(s) ||</div><div class="line">	    [];</div><div class="line"></div><div class="line">    return &#123; name: match[1] || &quot;&quot;, version: match[2] || &quot;0&quot; &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p><br>    除了浏览器厂商和版本信息的属性之外，Navigator对象还包含一些杂项的属性和方法。以下是一些标准化的属性以及广泛应用但未标准化的属性：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">onLine</div><div class="line">    navigator.onLine属性(如果存在的话)表示浏览器当前是否连接到网络。应用程序可能希望在离线状态下把状态保存在本地。</div><div class="line"></div><div class="line">geolocation</div><div class="line">    Geolocation对象定义用于确定用户地理位置信息的接口。</div><div class="line"></div><div class="line">javaEnabled()</div><div class="line">    一个非标准的方法，当浏览器可以运行Java小程序时返回true。</div><div class="line">    </div><div class="line">cookieEnable()</div><div class="line">    非标准的方法，如果浏览器可以保存永久的cookie时，返回true。当cookie配置为“视具体情况而定”时可能会返回不正确的值。</div></pre></td></tr></table></figure>
<h3 id="1-4-2-Screen对象"><a href="#1-4-2-Screen对象" class="headerlink" title="1.4.2 Screen对象"></a>1.4.2 Screen对象</h3><p><br>    Window对象的screen属性引用的是Screen对象。它提供有关窗口显示的大小和可用的颜色数量的信息。属性width和height指定的是以像素为单位的窗口大小。属性availWidth和availHeight指定的实际可用的显示大小，它们排除了像桌面任务栏这样的特性所占用的空间。属性colorDepth指定的是显示BPP(bits-per-pixel)值,典型的值有16、24和32.<br></p>

<p><br>    window.screen属性和它引用的Screen对象都是非标准但广泛实现的。可以用Screen对象来确定Web应用是否运行在一个小屏幕的设备上，比如上网本。如果屏幕空间有限，可能要选择用更小的字体和图片等。<br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/浮动概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/浮动概述/" itemprop="url">浮动概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T22:19:52+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p><br>    最后一种定位模型是浮动模型。浮动的框可以左右移动，直到它的外边缘碰到包含框或另一个浮动框的边缘。因为浮动框不在文档的普通流中，<br></p>

<p><br>    如图1-13所示，当把框1向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘。<br></p>

<p><br>    在图1-14中，当把框1向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框2，使框2从视图中消失。如果把3个框都向左浮动，那么框1向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。<br></p>

<p><img src="https://shaoqianheng.github.io/images/1-13.png"></p>
<div style="text-align: center;">图1-13 向右浮动的元素</div>

<p><img src="https://shaoqianheng.github.io/images/1-14.png"></p>
<div style="text-align: center;">图1-14 向左浮动的元素</div>

<p><br>    如果包含块太窄，无法容纳水平排列的3个浮动元素，那么其他浮动块向下移动，直到有足够空间的地方（见图1-15）.如果浮动元素的高度不同，那么当它们向下移动时可能会被其他浮动元素“卡住”。<br></p>

<p><img src="https://shaoqianheng.github.io/images/1-15.png"></p>
<div style="text-align: center;">图1-15 如果没有足够的水平空间，浮动元素将向下移动，直到有足够空间的地方</div>

<h3 id="行框和清理"><a href="#行框和清理" class="headerlink" title="行框和清理"></a>行框和清理</h3><p><br>    前一节指出，浮动会让元素脱离文档流，不再影响不浮动的元素。实际上，并不完全如此。如果浮动的元素后面有一个文档流中的元素，那么这个元素的框会表现得像浮动根本不存在一样。但是，框的文本内容会受到浮动元素的影响，会移动以留出空间。用技术术语来说，浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。实际上，创建浮动框使文本可以围绕图像（1-16）.<br></p>

<p><img src="https://shaoqianheng.github.io/images/1-16.png"></p>
<div style="text-align: center;">图1-16 浮动框旁边的行框被缩短</div>

<p><br>    要想阻止行框围绕在浮动框的外边，需要对包含这些行框的元素应用clear属性。clear属性的值可以是left、right、both或none，它表示框的那些边不应该挨着浮动框。我以前总是认为clear属性会自动地抵消前面的浮动。但是，实际情况有意思很多。在清理元素时，浏览器在元素顶上添加足够的外边距，使元素的顶边缘垂直下降到浮动框下面（见图1-17）.<br></p>

<p><img src="https://shaoqianheng.github.io/images/1-17.png"></p>
<div style="text-align: center;">图1-17 清理元素的顶外边距，为前一个浮动框留出足够的垂直空间</div>

<p><br>    浮动元素脱离了文档流，不影响周围的元素。但是，对元素进行清理实际上为前面的浮动元素留出了垂直空间。<br></p>

<p><br>    这是一个有用的布局工具，它让周围的元素为浮动元素留出空间。这解决了前面你看到的绝对定位的问题——垂直高度的改变不影响周围的元素，从而破坏了设计。<br></p>

<p><br>    我们来更详细地看看浮动和清理。假设有一个图片，你希望让它浮动到一个文本块的左边。你想将这个图片和文本包含在另一个具有背景颜色和边框的元素中。你可能会编写下面这样的代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.news &#123;</div><div class="line">    background-color: gray;</div><div class="line">    border: solid 1px black;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news img &#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news p &#123;</div><div class="line">    float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;news&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><br>    但是，因为浮动元素脱离了文档流，所以包围图片和文本的div不占据空间。如何让包围元素在视觉上包围浮动元素呢？需要在这个元素中的某个地方应用clear（见图1-18）.可惜这个示例中没有现有的元素可以清理，所以需要在最后一个段落下面添加一个空元素并且清理它。<br></p>

<p><img src="https://shaoqianheng.github.io/images/1-18.png"></p>
<div style="text-align: center;">图1-18 因为浮动元素不占据空间，所以容器元素不包围它们。添加一个进行清理的空元素可以迫使容器元素包围浮动元素</div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">.news &#123;</div><div class="line">    background-color: gray;</div><div class="line">    border: solid 1px black;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news img &#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news p &#123;</div><div class="line">    float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.clear &#123;</div><div class="line">    clear: both;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;news&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">    &lt;br class=&quot;clear&quot; /&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><br>    这会实现我们希望的效果，但是要添加不必要的代码。常常有现成的元素可以应用clear，但是有时候不得不忍受巨大通过布局添加无意义的标记。<br></p>

<p><br>    还可以不对浮动的文本和图像进行清理，而是选择浮动容器div：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">.news &#123;</div><div class="line">    background-color: gray;</div><div class="line">    border: solid 1px black;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news img &#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.news p &#123;</div><div class="line">    float: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;news&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><br>    这也会产生我们想要的结果。但是，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择浮动布局中的几乎所有东西，然后使用合适的元素（常常是站点的页脚）对这些浮动元素进行清理。这有助于减少或消除不必要的标记。但是，浮动会变得复杂，而且一些老式浏览器在处理有许多浮动元素的布局时有困难。因此，许多人喜欢添加少量的额外标记。<br></p>

<p><br>    overflow属性定义在包含的内容对于指定的尺寸太大的情况下元素应该怎么样。在默认情况下，内容会溢出到框外，进入相邻的空间。应用值为hidden或auto的overflow属性有一个有用的副作用，这会自动地清理包含的任何浮动元素。因此这是一种有用的元素清理方法，不需要添加额外的标记。这个方法并不适合所有情况，因为设置框的overflow属性会影响它的表现。更具体地说，这种方法在某些情况下会产生滚动条或截断内容。<br></p>

<p><br>    然后，一些人使用CSS生成的内容或JavaScript对浮动元素进行清理。这两种方法的基本概念是相同的，并不直接向标记中添加进行清理的元素，而是将它动态添加到页面中。对于这两种方法，需要指定进行清理的元素应该出现在哪里，而且常常需要添加一个类名：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;news clear&quot;&gt;</div><div class="line">    &lt;img src=&quot;/img/news-pic.jpg&quot; alt=&quot;my pic&quot; /&gt;</div><div class="line">    &lt;p&gt;Some text&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><br>    在使用CSS方法时，结合使用:after伪类和内容声明在指定的现有内容的末尾添加新的内容。在这个示例中，我添加了一个点，因为它是个非常小的不引人注意的字符。因为不希望新内容占据垂直空间或者在页面上显示，所以需要将height设置为0，将visibility设置为hidden。因为被清理的元素在它们的顶外边距上添加了空间，所以生成的内容需要将它的display属性设置为block。这样设置之后，就可以对生成的内容进行清理：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.clear:after &#123;</div><div class="line">    content: &quot;.&quot;;</div><div class="line">    height: 0;</div><div class="line">    visibility: hidden;</div><div class="line">    display: block;</div><div class="line">    clear: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="谦恒" />
          <p class="site-author-name" itemprop="name">谦恒</p>
           
              <p class="site-description motion-element" itemprop="description">苟日新 日日新 又日新</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谦恒</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
