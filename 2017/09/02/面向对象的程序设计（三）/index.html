<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="1.2.4 组合使用构造函数模式和原型模式    创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。  12345678910111">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象的程序设计（三）——JavaScript高级程序设计">
<meta property="og:url" content="http://yoursite.com/2017/09/02/面向对象的程序设计（三）/index.html">
<meta property="og:site_name" content="谦恒-个人博客">
<meta property="og:description" content="1.2.4 组合使用构造函数模式和原型模式    创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。  12345678910111">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-6-4.png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-6-5.png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-6-6.png">
<meta property="og:updated_time" content="2017-09-03T14:11:23.128Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象的程序设计（三）——JavaScript高级程序设计">
<meta name="twitter:description" content="1.2.4 组合使用构造函数模式和原型模式    创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。  12345678910111">
<meta name="twitter:image" content="https://shaoqianheng.github.io/images/h-6-4.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/02/面向对象的程序设计（三）/"/>





  <title>面向对象的程序设计（三）——JavaScript高级程序设计 | 谦恒-个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谦恒-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/面向对象的程序设计（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面向对象的程序设计（三）——JavaScript高级程序设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T09:23:54+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-2-4-组合使用构造函数模式和原型模式"><a href="#1-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="1.2.4 组合使用构造函数模式和原型模式"></a>1.2.4 组合使用构造函数模式和原型模式</h3><p><br>    创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line"> constructor: Person,</div><div class="line"> sayName: function() &#123;</div><div class="line">  alert(this.name);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div><div class="line"></div><div class="line">person1.friends.push(&quot;Van&quot;);</div><div class="line">alert(person1.friends);    // &quot;Shelby, Count, Van&quot;</div><div class="line">alert(person2.friends);    // &quot;Shelby, Count&quot;</div><div class="line">alert(person1.friends === person2.friends);    // false</div><div class="line">alert(person1.sayName === person2.sayName);    // true</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。而修改了person1.friends(向其中添加一个新字符串)，并不会影响到person2.friends，因为它们分别引用了不同的数组。<br></p>

<p><br>    这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。<br></p>

<h3 id="1-2-5-动态原型模式"><a href="#1-2-5-动态原型模式" class="headerlink" title="1.2.5 动态原型模式"></a>1.2.5 动态原型模式</h3><p><br>    有其他OO语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的有点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    // 属性</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    // 方法</div><div class="line">    if(typeof this.sayName != &quot;function&quot;) &#123;</div><div class="line">        Person.prototype.sayName = function() &#123;</div><div class="line">            alert(this.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p><br>    注意上面代码的if语句。这里只在sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中，if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if语句检查每个属性和每个方法；只要检查其中一个即可。。对于采用这种模式创建的对象，还可以使用instanceof操作符确定它的类型。<br></p>

<blockquote>
<p>使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>
</blockquote>
<h3 id="1-2-6-寄生构造函数模式"><a href="#1-2-6-寄生构造函数模式" class="headerlink" title="1.2.6 寄生构造函数模式"></a>1.2.6 寄生构造函数模式</h3><p><br>    通常，在前述的几种模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    var o = new Object();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = function() &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;;</div><div class="line">    return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了使用new操作符并使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。<br></p>

<p><br>    这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function SpeicalArray() &#123;</div><div class="line">    // 创建数组</div><div class="line">    var values = new Array();</div><div class="line">    // 添加值</div><div class="line">    values.push.apply(values, arguments);</div><div class="line">    // 添加方法</div><div class="line">    values.toPopedString = function() &#123;</div><div class="line">        return this.join(&quot;|&quot;);</div><div class="line">    &#125;;</div><div class="line">    // 返回数组</div><div class="line">    return values；</div><div class="line">&#125;</div><div class="line"></div><div class="line">var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</div><div class="line">alert(colors.toPipedString());    // &quot;red|blue|green&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们创建了一个名叫SpecialArray的构造函数。在这个函数内部，首先创建了一个数组，然后push()方法(用构造函数接收到的所有参数)初始化了数组的值。随后，又给数组实例添加了一个toPipedString()方法，该方法返回以竖线分割的数组值。最后，将数组以函数值的形式返回。接着，我们调用了SpecialArray构造函数，向其中传入了用于初始化数组的值，此后又调用了toPipedString()方法。<br></p>

<p><br>    关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。<br></p>

<h3 id="1-2-7-稳妥构造函数模式"><a href="#1-2-7-稳妥构造函数模式" class="headerlink" title="1.2.7 稳妥构造函数模式"></a>1.2.7 稳妥构造函数模式</h3><p><br>    道格拉斯·克罗克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中(这些环境中会禁止使用this和new)，或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不引用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">    // 创建要返回的对象</div><div class="line">    var o = new Object();</div><div class="line">    // 可以在这里定义私有变量和函数</div><div class="line"></div><div class="line">    // 添加方法</div><div class="line">    o.sayName = function() &#123;</div><div class="line">    	alert(name);</div><div class="line">    &#125;;</div><div class="line">    // 返回对象</div><div class="line">    return o；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法返回name的值。可以像下面使用稳妥的Person构造函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">friend.sayName();    // &quot;Nicholas&quot;</div></pre></td></tr></table></figure>
<p><br>    这样，变量friend中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境。<br></p>

<blockquote>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p>
</blockquote>
<h3 id="1-3-继承"><a href="#1-3-继承" class="headerlink" title="1.3 继承"></a>1.3 继承</h3><p><br>    继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。<br></p>

<h3 id="1-3-1-原型链"><a href="#1-3-1-原型链" class="headerlink" title="1.3.1 原型链"></a>1.3.1 原型链</h3><p><br>    ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型有时另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。<br></p>

<p><br>    实现原型链有一种基本模式，其代码大致如下。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // true</div></pre></td></tr></table></figure>
<p><br>    以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确立了继承关系之后，我们给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如下图所示。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-6-4.png"></p>
<p><br>    在上面的代码中，我们没有使用SubType默认提供的原型，而是给它换了一个新原型；这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向SuperType的原型。最终结果就是这样的：instance指向SubType的原型，SubType的原型又指向SuperType的原型。getSuperValue()方法仍然还在SuperType.prototype中，但property则位于SubType.prototype中。这是因为property是一个实例属性，而getSuperValue()则是一个原型方法。既然SubType.prototype现在是SuperType的实例，那么property当然就位于该实例中了。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来SubType.prototype中的constructor被重写了的缘故。<br></p>

<p><br>    通过实现原型链，本质上扩展了前面介绍的原型搜索机制。当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤:1) 搜索实例；2) 搜索SubType.prototype；3) 搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。<br></p>

<h4 id="1-别忘记默认的原型"><a href="#1-别忘记默认的原型" class="headerlink" title="1. 别忘记默认的原型"></a>1. 别忘记默认的原型</h4><p><br>    事实上，前面例子中展示的原型链还少了一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层次。下图展示了该例子中完整的原型链。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-6-5.png"></p>
<p><br>    一句话，SubType继承了SuperType，而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法。<br></p>

<h4 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2. 确定原型和实例的关系"></a>2. 确定原型和实例的关系</h4><p><br>    可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。以下几行代码就说明了这一点。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(instance instanceof Object);    // true</div><div class="line">alert(instance instanceof SuperType); // true</div><div class="line">alert(instance instanceof SubType);   // true</div></pre></td></tr></table></figure>
<p><br>    由于原型链的关系，我们可以说instance是Object、SuperType或SubType中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了true。<br></p>

<p><br>    第二种方式是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(Object.prototype.isPrototypeOf(instance));    // true</div><div class="line">alert(SuperType.prototype.isPrototypeOf(instance)); // true</div><div class="line">alert(SubType.prototype.isPrototypeOf(instance));   // true</div></pre></td></tr></table></figure>
<h4 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3. 谨慎地定义方法"></a>3. 谨慎地定义方法</h4><p><br>    子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">// 添加新方法</div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line">// 重写超类型中的方法</div><div class="line">SubType.prototype.getSuperValue = function() &#123;</div><div class="line">    return false;</div><div class="line">&#125;;</div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // false</div></pre></td></tr></table></figure>
<p><br>    在以上代码中，getSubValue()被添加到了SubType中。第二个方法getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个那个方法。这里要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。<br></p>

<p><br>    还有一点需要注意，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">// 使用字面量添加新方法，会导致上一行代码无效</div><div class="line">SubType.prototype = &#123;</div><div class="line">    getSubValue: function() &#123;</div><div class="line">        return this.subproperty;</div><div class="line">    &#125;,</div><div class="line">    someOtherMethod: function() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());    // error!</div></pre></td></tr></table></figure>
<p><br>    以上代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断——SubType和SuperType之间已经没有关系了。<br></p>

<h4 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h4><p><br>    原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。下列代码可以用来说明这个问题。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType() &#123;&#125;</div><div class="line"></div><div class="line">// 继承SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green, black&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的SuperType构造函数定义了一个colors属性，该属性包含一个数组(引用类型值)。SuperType的每个实例都会有各自包含自己数组的colors属性。当SubType通过原型链继承了SuperType之后，SubType.prototype就变成了SuperType的一个实例，因此它也拥有了一个它自己的colors属性——就跟专门创建了一个SubType.prototype.colors属性一样。但结果是什么呢？结果是SubType的所有实例都会共享这一个colors属性一样。但结果是什么呢？结果是SubType的所有实例都会共享这一个colors属性。而我们对instance1.colors的修改能够通过instance2.colors反映出来，就已经充分证实了这一点。<br></p>

<p><br>    原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。<br></p>

<h3 id="1-3-2-借用构造函数"><a href="#1-3-2-借用构造函数" class="headerlink" title="1.3.2 借用构造函数"></a>1.3.2 借用构造函数</h3><p><br>    在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数，如下所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType() &#123;</div><div class="line">    // 继承SuperType</div><div class="line">    SuperType.call(this);</div><div class="line">&#125;</div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green&quot;</div></pre></td></tr></table></figure>
<p><br>    代码中加注释（第一个）的那一行代码“借调”了超类型的构造函数。通过使用call()方法(或apply()方法也可以)，我们实际上是在(未来将要)新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都具有自己的colors属性的副本了。<br></p>

<h4 id="1-传递参数"><a href="#1-传递参数" class="headerlink" title="1. 传递参数"></a>1. 传递参数</h4><p><br>    相对于原型链而言，借用构造函数有一个很大的优势，既可以在子类型构造函数中向超类型构造函数传递参数。看下面这个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">function SubType() &#123;</div><div class="line">    // 继承了SuperType，同时还传递了参数</div><div class="line">    SuperType.call(this, &quot;Nicholas&quot;);</div><div class="line">    // 实例属性</div><div class="line">    this.age = 29;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.name);    // &quot;Nicholas&quot;;</div><div class="line">alert(instance.age);     // 29</div></pre></td></tr></table></figure>
<p><br>    以上代码中的SuperType只接受一个参数name，该参数会直接赋给一个属性。在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。<br></p>

<h4 id="2-借用构造函数的问题"><a href="#2-借用构造函数的问题" class="headerlink" title="2. 借用构造函数的问题"></a>2. 借用构造函数的问题</h4><p><br>    如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。<br></p>

<h3 id="1-3-3-组合继承"><a href="#1-3-3-组合继承" class="headerlink" title="1.3.3 组合继承"></a>1.3.3 组合继承</h3><p><br>    组合继承(combination inheritance),有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。下面来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    // 继承属性</div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line">// 继承方法</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);    // &quot;red, blue, green, black&quot;</div><div class="line">instance1.sayName();        // &quot;Nicholas&quot;</div><div class="line">instance1.sayAge();         // 29</div><div class="line"></div><div class="line">var instance2 = new SubType(&quot;Greg&quot;, 27);</div><div class="line">alert(instance2.colors);    // &quot;red, blue, green&quot;</div><div class="line">instance2.sayName();        // &quot;Greg&quot;</div><div class="line">instance2.sayAge();         // 27</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName().SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge().这样一来，就可以让两个不同的SubType实例既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。<br></p>

<p><br>    组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。<br></p>

<h3 id="1-3-4-原型式继承"><a href="#1-3-4-原型式继承" class="headerlink" title="1.3.4 原型式继承"></a>1.3.4 原型式继承</h3><p><br>    道格拉斯·克罗克福德在2006年写了一篇文章，题为Prototyal Inheritance in JavaScript(JavaScript中的原型式继承)。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">    function F() &#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = object(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</div><div class="line"></div><div class="line">alert(person.friends);    // &quot;Shelby, Court, Van, Rob, Barbie&quot;</div></pre></td></tr></table></figure>
<p><br>    克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到object()函数中，然后改函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。<br></p>

<p><br>    ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson = Object.create(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = Object.create(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</div><div class="line"></div><div class="line">alert(person.friends);    // &quot;Shelby, Court, Van, Rob, Barbie&quot;</div></pre></td></tr></table></figure>
<p><br>    Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = Object.create(person, &#123;</div><div class="line">    name: &#123;</div><div class="line">        value: &quot;Greg&quot;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name);    // &quot;Greg&quot;</div></pre></td></tr></table></figure>
<p><br>    支持Object.create()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br></p>

<p><br>    在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。<br></p>

<h3 id="1-3-5-寄生式继承"><a href="#1-3-5-寄生式继承" class="headerlink" title="1.3.5 寄生式继承"></a>1.3.5 寄生式继承</h3><p><br>    寄生式(parasitic)继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function createAnother(original) &#123;</div><div class="line">    var clone = object(original);    // 通过调用函数创建一个新对象</div><div class="line">    clone.sayHi = function() &#123;</div><div class="line">        alert(&quot;hi&quot;);</div><div class="line">    &#125;;</div><div class="line">    return clone;    // 返回这个对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，createAnother()函数接收一个参数，也就是将要作为新对象基础的对象。然后，把这个对象(original)传递给object()函数，将返回的结果赋值给clone。再为clone对象添加一个新方法sayHi(),最后返回clone对象。可以像下面这样来使用createAnother()函数：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi();    // &quot;hi&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person的所有属性和方法，而且还有自己的sayHi()方法。<br></p>

<p><br>    在主要考虑对象而不是定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。<br></p>

<blockquote>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
</blockquote>
<h3 id="1-3-6-寄生组合式继承"><a href="#1-3-6-寄生组合式继承" class="headerlink" title="1.3.6 寄生组合式继承"></a>1.3.6 寄生组合式继承</h3><p><br>    前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数；一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。再来看一看下面组合继承的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    SuperType.call(this, name);    // 第二次调用SuperType()</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = new SuperType();    // 第一次调用SuperType()</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><br>    加注释的代码是调用SuperType构造函数的代码。在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。图1-6展示了上述过程。<br></p>

<p><br>    图1-6所示，有两组name和colors属性：一组在实例上，一组在SubType原型中。这就是调用两次SuperType构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。<br></p>

<p><br>    所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType, superType) &#123;</div><div class="line">    var prototype = object(superType.prototype);    // 创建对象</div><div class="line">    prototype.constructor = subType;                // 增强对象</div><div class="line">    subType.prototype = prototype;                  // 指定对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个示例中的inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。最后一步，将新创建的对象(即副本)赋值给子类型的原型。这样，我们就可以用调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name, age) &#123;</div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = function() &#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://shaoqianheng.github.io/images/h-6-6.png"></p>
<div style="text-align: center;">图1-6</div>

<p><br>    这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf().开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。<br></p>

<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><br>    ECMAScript支持面向对象(OO)编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。<br></p>

<p><br>    (1) 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。<br><br>    (2) 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象(即与对象具有松散耦合的特点)，因此没有理由不在多个对象间共向函数。<br><br>    (3) 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式与原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。<br></p>

<p><br>    JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型的构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合模式，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。<br></p>

<p><br>    此外，还存在下列可供选择的继承模式。<br></p>

<p><br>    (1) 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。<br><br>    (2) 寄生式继承，与原型式继承非常类似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。<br><br>    (3) 寄生组合式继承，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。<br></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/01/面向对象的程序设计（二）/" rel="next" title="面向对象的程序设计（二）——JavaScript高级程序设计">
                <i class="fa fa-chevron-left"></i> 面向对象的程序设计（二）——JavaScript高级程序设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/03/函数表达式（一）/" rel="prev" title="函数表达式（一）——JavaScript高级程序设计">
                函数表达式（一）——JavaScript高级程序设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="谦恒" />
          <p class="site-author-name" itemprop="name">谦恒</p>
           
              <p class="site-description motion-element" itemprop="description">苟日新 日日新 又日新</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-组合使用构造函数模式和原型模式"><span class="nav-number">1.</span> <span class="nav-text">1.2.4 组合使用构造函数模式和原型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5-动态原型模式"><span class="nav-number">2.</span> <span class="nav-text">1.2.5 动态原型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-6-寄生构造函数模式"><span class="nav-number">3.</span> <span class="nav-text">1.2.6 寄生构造函数模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-7-稳妥构造函数模式"><span class="nav-number">4.</span> <span class="nav-text">1.2.7 稳妥构造函数模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-继承"><span class="nav-number">5.</span> <span class="nav-text">1.3 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-原型链"><span class="nav-number">6.</span> <span class="nav-text">1.3.1 原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-别忘记默认的原型"><span class="nav-number">6.1.</span> <span class="nav-text">1. 别忘记默认的原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-确定原型和实例的关系"><span class="nav-number">6.2.</span> <span class="nav-text">2. 确定原型和实例的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-谨慎地定义方法"><span class="nav-number">6.3.</span> <span class="nav-text">3. 谨慎地定义方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-原型链的问题"><span class="nav-number">6.4.</span> <span class="nav-text">4. 原型链的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-借用构造函数"><span class="nav-number">7.</span> <span class="nav-text">1.3.2 借用构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-传递参数"><span class="nav-number">7.1.</span> <span class="nav-text">1. 传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-借用构造函数的问题"><span class="nav-number">7.2.</span> <span class="nav-text">2. 借用构造函数的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-组合继承"><span class="nav-number">8.</span> <span class="nav-text">1.3.3 组合继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-原型式继承"><span class="nav-number">9.</span> <span class="nav-text">1.3.4 原型式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5-寄生式继承"><span class="nav-number">10.</span> <span class="nav-text">1.3.5 寄生式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-6-寄生组合式继承"><span class="nav-number">11.</span> <span class="nav-text">1.3.6 寄生组合式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-小结"><span class="nav-number">12.</span> <span class="nav-text">1.4 小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谦恒</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
