<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="1.1.7 系统对话框    浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及(或)浏览器设置决定，而不是由CSS决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。      前">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="BOM（三）——JavaScript高级程序设计">
<meta property="og:url" content="http://yoursite.com/2017/09/07/BOM（三）/index.html">
<meta property="og:site_name" content="谦恒-个人博客">
<meta property="og:description" content="1.1.7 系统对话框    浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及(或)浏览器设置决定，而不是由CSS决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。      前">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-8-4.png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-8-5(1).png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-8-5(2).png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-8-6(1).png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-8-6(2).png">
<meta property="og:updated_time" content="2017-09-07T16:06:21.350Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BOM（三）——JavaScript高级程序设计">
<meta name="twitter:description" content="1.1.7 系统对话框    浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及(或)浏览器设置决定，而不是由CSS决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。      前">
<meta name="twitter:image" content="https://shaoqianheng.github.io/images/h-8-4.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/07/BOM（三）/"/>





  <title>BOM（三）——JavaScript高级程序设计 | 谦恒-个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谦恒-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/BOM（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">BOM（三）——JavaScript高级程序设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-07T09:36:47+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-1-7-系统对话框"><a href="#1-1-7-系统对话框" class="headerlink" title="1.1.7 系统对话框"></a>1.1.7 系统对话框</h3><p><br>    浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及(或)浏览器设置决定，而不是由CSS决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。<br></p>

<p><br>    前面经常会用到alert()方法，这个方法接受一个字符串并将其显示给用户。具体来说，调用alert()方法的结果就是向用户显示一个系统对话框，其中包含指定的文本和一个OK(“确定”)按钮。<br></p>

<p><br>    通常使用alert()生成的“警告”对话框向用户显示一些他们无法控制的消息，例如错误消息。而用户只能在看完消息后关闭对话框。<br></p>

<p><br>    第二种对话框是调用confirm()方法生成的。从向用户显示消息的方面来看，这种“确认”对话框很像是一个“警告”对话框。但二者的主要区别在于“确认”对话框除了显示OK按钮外，还会显示一个Cancel(“取消”)按钮，两个按钮可以让用户决定是否执行给定的操作。<br></p>

<p><br>    最后一种对话框是通过调用prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示OK和Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值(可以是一个空字符串)。<br></p>

<p><br>    综上所述，这些系统对话框很适合向用户显示消息并请用户做出决定。由于不涉及HTML、CSS或JavaScript，因此它们是增强Web应用程序的一种便捷方式。<br></p>

<h3 id="1-2-location对象"><a href="#1-2-location对象" class="headerlink" title="1.2 location对象"></a>1.2 location对象</h3><p><br>    location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location对象是很特别的一个对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下表列出了location对象的所有属性。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-8-4.png"></p>
<h3 id="1-2-1-查询字符串参数"><a href="#1-2-1-查询字符串参数" class="headerlink" title="1.2.1 查询字符串参数"></a>1.2.1 查询字符串参数</h3><p><br>    虽然通过上面的属性可以访问到location对象的大多数信息，但其中访问URL包含的查询字符串的属性并不方便。尽管location.search返回从问好到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。为此，可以像下面这样创建一个函数，用于解析查询字符串，然后返回包含所有参数的一个对象。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function getQueryStringArgs() &#123;</div><div class="line">    // 取得查询字符串并去掉开头的问好</div><div class="line">    var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;),</div><div class="line"></div><div class="line">    // 保存数据的对象</div><div class="line">    args = &#123;&#125;，</div><div class="line"></div><div class="line">    // 取得每一项</div><div class="line">    items = qs.length ? qs.split(&quot;&amp;&quot;) : [],</div><div class="line">    item = null,</div><div class="line">    name = null,</div><div class="line">    value = null,</div><div class="line"></div><div class="line">    // 在for循环中使用</div><div class="line">    i = 0,</div><div class="line">    len = items.length;</div><div class="line"></div><div class="line">    // 逐个将每一项添加到args对象中</div><div class="line">    for(i = 0; i &lt; len; i++) &#123;</div><div class="line">        item = items[i].split(&quot;=&quot;);</div><div class="line">        name = decodeURIComponent(item[0]);</div><div class="line">        value = decodeURIComponent(item[1]);</div><div class="line"></div><div class="line">        if (name.length) &#123;</div><div class="line">            args[name] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return args;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    这个函数的第一步是先去掉查询字符串开头的问号。当然，前提是location.search中必须要包含一个或多个字符。然后，所有参数将被保存在args对象中，该对象以字面量形式创建。接下来，根据和号(&amp;)来分割查询字符串，并返回name=value格式的字符串数组。下面的for循环会迭代这个数组，然后再根据等于号分割每一项，从而返回第一项为参数名，第二项为参数值的数组。在使用decodeURIComponent()分别解码name和value(因为查询字符串应该是被编码过的)。最后，将name作为args对象的属性，将value作为相应属性的值。下面给出了使用这个函数的示例。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 假设查询字符串是?q=javascript&amp;num=10</div><div class="line">var args = getQueryStringArgs();</div><div class="line"></div><div class="line">alert(args[&quot;q&quot;]);    // &quot;javascript&quot;</div><div class="line">alert(args[&quot;num&quot;]);  // &quot;10&quot;</div></pre></td></tr></table></figure>
<p><br>    可见，每个查询字符串参数都成了返回对象的属性。这样就极大地方便了对每个参数的访问。<br></p>

<h3 id="1-2-2-位置操作"><a href="#1-2-2-位置操作" class="headerlink" title="1.2.2 位置操作"></a>1.2.2 位置操作</h3><p><br>    使用location对象可以通过很多方式来改变浏览器的位置。首先，也是最常用的方式，就是使用assign()方法并为其传递一个URL，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.assign(&quot;xxxx&quot;);</div></pre></td></tr></table></figure>
<p><br>    这样，就可以立即打开新URL并在浏览器的历史记录中生成一条记录。如果将location.href或window.location设置为一个URL值，也会以该值调用assign()方法。例如，下列两行代码与显式调用assign()方法的效果完全一样。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">window.location = &quot;xxxx&quot;;</div><div class="line">location.href = &quot;xxxx&quot;;</div></pre></td></tr></table></figure>
<p><br>    在这些改变浏览器位置的方法中，最常用的是设置location.href属性。<br></p>

<p><br>    另外，修改location对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将hash、search、hostname、pathname和port属性设置为新值来改变URL。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 假设初始URL为 http://www.wrox.com/WileyCDA/</div><div class="line"></div><div class="line">// 将URL修改为 http://www.wrox.com/WileyCDA/#section1</div><div class="line">location.hash = &quot;#section1&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.wrox.com/WileyCDA/?q=javascript</div><div class="line">location.search = &quot;?q=javascript&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.yahoo.com/WileyCDA/</div><div class="line">location.hostname = &quot;www.yahoo.com&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.yahoo.com/mydir/</div><div class="line">location.pathname = &quot;mydir&quot;;</div><div class="line"></div><div class="line">// 将URL修改为 http://www.yahoo.com:8080/WileyCDA/</div><div class="line">location.port = 8080;</div></pre></td></tr></table></figure>
<p><br>    每次修改location的属性(除hash外)，页面都会以新URL重新加载。<br></p>

<p><br>    当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。这个方法只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新纪录。在调用replace()方法之后，用户不能回到前一个页面，来看下面的例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;You won&apos;t be able to get back here&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;p&gt;Enjoy this page for a second, because you won&apos;t be coming back here.&lt;/p&gt;</div><div class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            setTimeout(function () &#123;</div><div class="line">                location.replace(&quot;http://www.wrox.com/&quot;);</div><div class="line">            &#125;, 1000);</div><div class="line">        &lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><br>    如果将这个页面加载到浏览器中，浏览器就会在1秒钟后重新定向到www.wrox.com。然后，“后退”按钮将处于禁用状态，如果不重新输入完整的URL，则无法返回示例页面。<br></p>

<p><br>    与位置有关的最后一个方法是reload(),作用是重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">location.reload();      // 重新加载(有可能从缓存中加载)</div><div class="line">location.reload(true);  // 重新加载(从服务器重新加载)</div></pre></td></tr></table></figure>
<p><br>    位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。<br></p>

<h3 id="1-3-navigator对象"><a href="#1-3-navigator对象" class="headerlink" title="1.3 navigator对象"></a>1.3 navigator对象</h3><p><br>    最早由Netscape Navigator 2.0引入的navigator对象，现在已经成为识别客户端浏览器的事实标准。虽然其他浏览器也通过其他方式提供了相同或相似的信息(例如，IE中的window.clientInformation和Opera中的window.opera),但navigator对象却是所有支持JavaScript的浏览器所共有的。与其他BOM对象的情况一样，每个浏览器中的navigator对象也都有一套自己的属性。下表列出了存在于所有浏览器中的属性和方法，以及支持他么的浏览器版本。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-8-5(1).png"><br><img src="https://shaoqianheng.github.io/images/h-8-5(2).png"></p>
<h3 id="1-3-1-检测插件"><a href="#1-3-1-检测插件" class="headerlink" title="1.3.1 检测插件"></a>1.3.1 检测插件</h3><p><br>    检测浏览器中是否安装了特定的插件是一种最常见的检测例程。对于非IE浏览器，可以使用plugins数组来达到这个目的。该数组中的每一项都包含下列属性。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(1) name: 插件的名字。</div><div class="line">(2) description: 插件的描述。</div><div class="line">(3) filename: 插件的文件名。</div><div class="line">(4) length: 插件所处理的MIME类型数量。</div></pre></td></tr></table></figure>
<p><br>    一般来说，name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 检测插件（在 IE 中无效）</div><div class="line">function hasPlugin(name) &#123;</div><div class="line">    name = name.toLowerCase();</div><div class="line">    for (var i=0; i &lt; navigator.plugins.length; i++) &#123;</div><div class="line">        if (navigator. plugins [i].name.toLowerCase().indexOf(name) &gt; -1) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测 Flash</div><div class="line">alert(hasPlugin(&quot;Flash&quot;));</div><div class="line">// 检测 QuickTime</div><div class="line">alert(hasPlugin(&quot;QuickTime&quot;));</div></pre></td></tr></table></figure>
<p><br>    这个hasPlugin()函数接受一个参数：要检测的插件名。第一步是将传入的名称转换为小写形式，以便于比较。然后迭代plugins数组，通过indexOf()检测每个name属性，以确定传入的名称是否出现在字符串的某个地方。比较的字符串都使用小写形式可以避免因大小写不一致导致的错误。而传入的参数应该尽可能具体，以避免混淆。应该说，像Flash和QuickTime这样的字符串就比较具体了，不容易导致混淆。在Firefox、Safari、Opera和Chrome中可以使用这种方法来检测插件。<br></p>

<blockquote>
<p>每个插件对象本身也是一个MimeType对象的数组，这些对象可以通过方括号语法来访问。每个MimeType对象有4个属性：包含MIME类型描述的description、回指插件对象的enabledPlugin、表示与MIME类型对应的文件扩展名的字符串suffixes(以逗号分隔)和表示完整MIME类型字符串的type。</p>
</blockquote>
<p><br>    检测IE中的插件比较麻烦，因为IE不支持Netscape式的插件。在IE中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。例如，Flash的标识符是ShockwaveFlash.shockwaveFlash.知道唯一标识符之后，就可以编写类似下面的函数来检测IE中是否安装相应插件了。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 检测 IE 中的插件</div><div class="line">function hasIEPlugin(name) &#123;</div><div class="line">    try &#123;</div><div class="line">        new ActiveXObject(name);</div><div class="line">        return true;</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测 Flash</div><div class="line">alert(hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;));</div><div class="line">// 检测 QuickTime</div><div class="line">alert(hasIEPlugin(&quot;QuickTime.QuickTime&quot;));</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，函数hasIEPlugin()只接收一个COM标识符作为参数。在函数内部，首先会尝试创建一个COM对象的实例。之所以要在try-catch语句中进行实例化，是因为创建未知COM对象会抛出错误。这样，如果实例化成功，则函数返回true；否则，如果抛出了错误，则执行catch块，结果就会返回false。例子最后检测IE中是否安装了Flash和QuickTime插件。<br></p>

<p><br>    鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 检测所有浏览器中的 Flash</div><div class="line">function hasFlash() &#123;</div><div class="line">    var result = hasPlugin(&quot;Flash&quot;);</div><div class="line">    if (!result) &#123;</div><div class="line">        result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaveFlash&quot;);</div><div class="line">    &#125; </div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测所有浏览器中的 QuickTime</div><div class="line">function hasQuickTime() &#123;</div><div class="line">    var result = hasPlugin(&quot;QuickTime&quot;);</div><div class="line">    if (!result) &#123;</div><div class="line">        result = hasIEPlugin(&quot;QuickTime.QuickTime&quot;);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 检测 Flash</div><div class="line">alert(hasFlash());</div><div class="line">// 检测 QuickTime</div><div class="line">alert(hasQuickTime());</div></pre></td></tr></table></figure>
<p><br>    上面代码中定义了两个函数：hasFlash()和hasQuickTime().每个函数都是先尝试使用不针对IE的插件检测方法。如果返回了false(在IE中会这样)，那么再使用针对IE的插件检测方法。如果IE的插件检测方法再返回false，则整个方法也将返回false。只要任何一次检测返回true，整个方法都会返回true。<br></p>

<blockquote>
<p>plugins集合有一个名叫refresh()的方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。</p>
</blockquote>
<h3 id="1-3-2-注册处理程序"><a href="#1-3-2-注册处理程序" class="headerlink" title="1.3.2 注册处理程序"></a>1.3.2 注册处理程序</h3><p><br>    Firefox 2为navigator对象新增了registerContentHandler()和registerProtocolHandler()方法(这两个方法是在HTML5中定义的)。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。<br></p>

<p><br>    其中，registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称。举个例子，要将一个站点注册为处理RSS源的处理程序，可以使用如下代码。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   navigator.registerContentHandler(&quot;application/rss+xml&quot;,</div><div class="line">&quot;http://www.somereader.com?feed=%s&quot;, &quot;Some Reader&quot;);</div></pre></td></tr></table></figure>
<p><br>    第一个参数是RSS源的MIME类型。第二个参数是应该接收RSS源URL的URL，其中的%s表示RSS源URL，由浏览器自动插入。当下一次请求RSS源时，浏览器就会打开指定的URL，而相应的Web应用程序将以适当方式来处理该请求。<br></p>

<blockquote>
<p>Firefox 4及之前版本只允许在registerContentHandler()方法中使用三个MIME类型：application/rss+xml、application/atom+xml和application/vnd.mozilla.maybe.feed.这三个MIME类型的作用都一样，即为RSS或ATOM新闻源(feed)注册处理程序。</p>
</blockquote>
<p><br>    类似的调用方式也适用于registerProtocolHandler()方法，它也接收三个参数：要处理的协议(例如，mailto或ftp)、处理该协议的页面的URL和应用程序的名称。例如，要想将一个应用程序注册为默认的邮件客户端，可以使用如下代码。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   navigator.registerProtocolHandler(&quot;mailto&quot;,</div><div class="line">&quot;http://www.somemailclient.com?cmd=%s&quot;, &quot;Some Mail Client&quot;);</div></pre></td></tr></table></figure>
<p><br>    这个例子注册了一个mailto协议的处理程序，该程序指向一个基于Web的电子邮件客户端。同样，第二个参数仍然是处理相应请求的URL，而%s则表示原始的请求。<br></p>

<blockquote>
<p>Firefox 2虽然实现了registerProtocolHandler(),当该方法还不能用。Firefox 3完整实现这个方法。</p>
</blockquote>
<h3 id="1-4-screen对象"><a href="#1-4-screen对象" class="headerlink" title="1.4 screen对象"></a>1.4 screen对象</h3><p><br>    JavaScript中有几个对象在编程中用处不大，而screen对象就是其中之一。screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各自不同的属性，下表列出了所有属性及支持相应属性的浏览器。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-8-6(1).png"><br><img src="https://shaoqianheng.github.io/images/h-8-6(2).png"></p>
<p><br>    这些信息经常集中出现在测定客户端能力的站点跟踪工具中，但通常不会用于影响功能。不过，有时候也可能会用到其中的信息来调整浏览器窗口大小，使其占据屏幕的可用空间，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.resizeTo(screen.availWidth, screen.availHeight);</div></pre></td></tr></table></figure>
<p><br>    前面曾经提到过，许多浏览器都会禁用调整浏览器窗口大小的能力，因此上面这行代码不一定在所有环境下都有效。<br></p>

<p><br>    涉及移动设备的屏幕大小时，情况有点不一样。运行iOS的设备始终会像是把设备竖着拿在手里一样，因此返回的值是768 * 1024.而Android设备则会相应调用screen.width和screen.height的值。<br></p>

<h3 id="1-5-history对象"><a href="#1-5-history对象" class="headerlink" title="1.5 history对象"></a>1.5 history对象</h3><p><br>    history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。出于安全方面的考虑，开发人员无法得知用于浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL的情况下实现后退和前进。<br></p>

<p><br>    使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转(类似于单击浏览器的“后退”<br>    按钮)，正数表示向前跳转(类似于单击浏览器的“前进”按钮)。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//后退一页</div><div class="line">history.go(-1);</div><div class="line"></div><div class="line">//前进一页</div><div class="line">history.go(1);</div><div class="line"></div><div class="line">//前进两页</div><div class="line">history.go(2);</div></pre></td></tr></table></figure>
<p><br>    也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//跳转到最近的 wrox.com 页面</div><div class="line">history.go(&quot;wrox.com&quot;);</div><div class="line"></div><div class="line">//跳转到最近的 nczonline.net 页面</div><div class="line">history.go(&quot;nczonline.net&quot;);</div></pre></td></tr></table></figure>
<p><br>    另外，还可以使用两个简写方法back()和forward()来代替go().顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//后退一页</div><div class="line">history.back();</div><div class="line"></div><div class="line">//前进一页</div><div class="line">history.forward();</div></pre></td></tr></table></figure>
<p><br>    除了上述几个方法外，history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0.通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的页面。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (history.length == 0) &#123;</div><div class="line">    //这应该是用户打开窗口后的第一个页面</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    虽然history并不常用，但在创建自定义的“后退”和“前进”按钮，以及检测当前页面是不是用户历史记录中第一个页面时，还是必须使用它。<br></p>

<blockquote>
<p>当页面的URL改变时，就会生成一条历史记录。在IE8及更高版本、Opera、Firefox、Safari 3以及更高版本及Chrome中，这里所说的改变包括URL中的hash的变化(因此，设置location.hash会在这些浏览器中生成一条新的历史记录)。</p>
</blockquote>
<h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h3><p><br>    浏览器对象模型(BOM)以window对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。这章讨论了下列BOM的组成部分。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(1) 在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames集合中，可以通过位置或通过名称来访问。</div><div class="line">(2) 有一些窗口指针，可以用来引用其他框架，包括父框架。</div><div class="line">(3) top对象始终指向最外围的框架，也就是整个浏览器窗口。</div><div class="line">(4) parent对象表示包含当前框架的框架，而self对象则回指window。</div><div class="line">(5) 使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。</div><div class="line">(6) 调用replace()方法可以导航到一个新URL，同时该URL会替换掉浏览器历史记录中当前显示的页面。</div><div class="line">(7) navigator对象提供了与浏览器相关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性(如userAgent)存在于所有浏览器中。</div></pre></td></tr></table></figure>
<blockquote>
<p>BOM中还有两个对象：screen和history，但它们的功能有限。screen对象中保存着与客户端显示器有关信息，这些信息一般只用于站点分析。history对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/06/BOM（二）/" rel="next" title="BOM（二）——JavaScript高级程序设计">
                <i class="fa fa-chevron-left"></i> BOM（二）——JavaScript高级程序设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="谦恒" />
          <p class="site-author-name" itemprop="name">谦恒</p>
           
              <p class="site-description motion-element" itemprop="description">苟日新 日日新 又日新</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-7-系统对话框"><span class="nav-number">1.</span> <span class="nav-text">1.1.7 系统对话框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-location对象"><span class="nav-number">2.</span> <span class="nav-text">1.2 location对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-查询字符串参数"><span class="nav-number">3.</span> <span class="nav-text">1.2.1 查询字符串参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-位置操作"><span class="nav-number">4.</span> <span class="nav-text">1.2.2 位置操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-navigator对象"><span class="nav-number">5.</span> <span class="nav-text">1.3 navigator对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-检测插件"><span class="nav-number">6.</span> <span class="nav-text">1.3.1 检测插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-注册处理程序"><span class="nav-number">7.</span> <span class="nav-text">1.3.2 注册处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-screen对象"><span class="nav-number">8.</span> <span class="nav-text">1.4 screen对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-history对象"><span class="nav-number">9.</span> <span class="nav-text">1.5 history对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-小结"><span class="nav-number">10.</span> <span class="nav-text">1.6 小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谦恒</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
