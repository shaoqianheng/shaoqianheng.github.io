<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必须的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。      Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="引用类型（三）——JavaScript高级程序设计">
<meta property="og:url" content="http://yoursite.com/2017/08/30/引用类型（三）/index.html">
<meta property="og:site_name" content="谦恒-个人博客">
<meta property="og:description" content="当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必须的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。      Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-5-3.png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-5-4.png">
<meta property="og:image" content="https://shaoqianheng.github.io/images/h-5-5.png">
<meta property="og:updated_time" content="2017-08-30T11:27:54.873Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="引用类型（三）——JavaScript高级程序设计">
<meta name="twitter:description" content="当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必须的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。      Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类">
<meta name="twitter:image" content="https://shaoqianheng.github.io/images/h-5-3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/30/引用类型（三）/"/>





  <title>引用类型（三）——JavaScript高级程序设计 | 谦恒-个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谦恒-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/引用类型（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">引用类型（三）——JavaScript高级程序设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T09:10:54+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><br>    当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必须的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值true。<br></p>

<p><br>    Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = new Object(&quot;some text&quot;);</div><div class="line">alert(obj instanceof String);   // true</div></pre></td></tr></table></figure>
<p><br>    把字符串传给Object构造函数，就会创建String的实例；而传入数值参数会得到Number的实例，传入布尔值参数就会得到Boolean的实例。<br></p>

<p><br>    要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var value = &quot;25&quot;;</div><div class="line">var number = Number(value);    // 转型函数</div><div class="line">alert(typeof number);          // &quot;number&quot;</div><div class="line"></div><div class="line">var obj = new Number(value);   // 构造函数</div><div class="line">alert(typeof obj);             // &quot;object&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，变量number中保存的是基本类型的值25，而变量obj中保存的是Number的实例。<br></p>

<p><br>    尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。<br></p>

<h3 id="1-5-1-Boolean类型"><a href="#1-5-1-Boolean类型" class="headerlink" title="1.5.1 Boolean类型"></a>1.5.1 Boolean类型</h3><p><br>    Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以像下面这样调用Boolean构造函数并传入true或false。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var booleanObject = new Boolean(true);</div></pre></td></tr></table></figure>
<p><br>    Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false。可是，Boolean对象在ECMAScript中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是布尔表达式中使用Boolean对象，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var falseObject = new Object(false);</div><div class="line">var result = falseObject &amp;&amp; true;</div><div class="line">alert(result);    // true</div><div class="line"></div><div class="line">var falseValue = false;</div><div class="line">result = falseValue &amp;&amp; true;</div><div class="line">alert(result);    // false</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，我们使用false值创建了一个Boolean对象。然后，将这个对象与基本类型值true构成了逻辑与表达式。在布尔运算中，false &amp;&amp; true等于false。可是，示例中的这行代码是对falseObject对象而不是对它的值(false)进行求值。前面讨论过，布尔表达式中的所有对象都会被转换为true，因此falseObject对象在布尔表达式中代表的是true。结果，true &amp;&amp; true当然就等于true了。<br></p>

<p><br>    基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(typeof falseObject);    // object</div><div class="line">alert(typeof falseValue);     // boolean</div><div class="line">alert(falseObject instanceof Boolean);    // true</div><div class="line">alert(falseValue instanceof Boolean);     // false</div></pre></td></tr></table></figure>
<p><br>    理解基本类型的布尔值与Boolean对象之间的区别非常重要——当然，建议是永远不要使用Boolean对象。<br></p>

<h3 id="1-5-2-Number类型"><a href="#1-5-2-Number类型" class="headerlink" title="1.5.2 Number类型"></a>1.5.2 Number类型</h3><p><br>    Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递相应的数值。下面是一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var numberObject = new Number(10);</div></pre></td></tr></table></figure>
<p><br>    与Boolean类型一样，Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。我们可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString());    // &quot;10&quot;</div><div class="line">alert(num.toString(2));   // &quot;1010&quot;</div><div class="line">alert(num.toString(8));   // &quot;12&quot;</div><div class="line">alert(num.toString(10));  // &quot;10&quot;</div><div class="line">alert(num.toString(16));  // &quot;a&quot;</div></pre></td></tr></table></figure>
<p><br>    除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toFixed(2));    // &quot;10.00&quot;</div></pre></td></tr></table></figure>
<p><br>    这里给toFixed()方法传入了数值2，意思是显示几位小数。于是，这个方法返回了“10.00”，即以0填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就舍入，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10.005;</div><div class="line">alert(num.toFixed(2));    // &quot;10.01&quot;</div></pre></td></tr></table></figure>
<p><br>    能够自动舍入的特性，使得toFixed()方法很适合处理货币值。但需要注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同。在给toFixed()传入0的情况下，IE8及之前版本不能正确舍入范围在{(-0.94, -0.5], [0.5, 0.94)}之间的值。对于这个范围内的值，IE会返回0，而不是-1或1；其他浏览器都能返回正确的值。IE9修复了这个问题。<br></p>

<blockquote>
<p>toFixed()方法可以表示带有0到20个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数。</p>
</blockquote>
<p><br>    另外可用于格式化数值的方法是toExponential()，该方法返回以指数表示法(也称e表示法)表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数。看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toExponential(1));    // &quot;1.0e+1&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码输出了“1.0e+1”;不过，这么小的数值一般不必使用e表示法。如果你想得到表示某个数值的最合适的格式，就应该使用toPrecision()方法，<br></p>

<p><br>    对于一个数值来说，toPrecision()方法可能会返回固定大小(fixed)格式，也可能返回指数(exponential)格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数(不包括指数部分)。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var num = 99;</div><div class="line">alert(num.toPrecision(1));    // &quot;1e+2&quot;</div><div class="line">alert(num.toPrecision(2));    // &quot;99&quot;</div><div class="line">alert(num.toPrecision(3));    // &quot;99.0&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码首先完成的任务是以一位数来表示99，结果是“1e+2”,即100.因为一位数无法准确地表示99，因此toPrecision()就将它向上舍入为100，这样就可以使用一位数来表示它。而接下来的用两位数表示99，当然还是“99”。最后，在想以三位数表示99时，toPrecision()方法返回“99.0”。实际上，toPrecision()会根据要处理的数值决定到底是调用toFixed()还是调用toExponential()。而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。<br></p>

<blockquote>
<p>toPrecision()方法可以表现1到21位小数。某些浏览器支持的范围更大，但这是典型实现的范围。</p>
</blockquote>
<p><br>    与Boolean对象类似，Number对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化Number类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var numberObject = new Number(10);</div><div class="line">var numberValue = 10;</div><div class="line">alert(typeof numberObject);    // &quot;object&quot;</div><div class="line">alert(typeof numberValue);     // &quot;object&quot;</div><div class="line">alert(numberObject instanceof Number);    // true</div><div class="line">alert(numberValue instanceof Number);     // false</div></pre></td></tr></table></figure>
<p><br>    在使用typeof操作符测试基本类型数值时，始终会返回“number”，而在测试Number对象时，则会返回“object”。类似地，Number对象时Number类型的实例，而基本类型的数值则不是。<br></p>

<h3 id="1-5-3-String类型"><a href="#1-5-3-String类型" class="headerlink" title="1.5.3 String类型"></a>1.5.3 String类型</h3><p><br>    String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var stringObject = new String(&quot;hello world&quot;);</div></pre></td></tr></table></figure>
<p><br>    String对象的方法也可以在所有基本的字符串值中访问到。其中，继承的valueOf()、toLocaleString()和toString()方法，都返回对象所表示的基本字符串值。<br></p>

<p><br>    String类型的每个实例都有一个length属性，表示字符串中包含多个字符。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.length);    // &quot;11&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子输出了字符串“hello world”中的字符数量，即“11”。应该注意的是，即使字符串中包含双字节字符(不是占一个字节的ASCII字符)，每个字符也仍然算一个字符。<br></p>

<p><br>    String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。<br></p>

<p>####1、字符方法</p>
<p><br>    两个用于访问字符串中特定字符的方法是：charAt()和chatCodeAt()。这两个方法都接收一个参数，即基于0的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符(ECMAScript中没有字符类型)。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charAt(1));    // &quot;e&quot;</div></pre></td></tr></table></figure>
<p><br>    字符串“hello world”位置1处的字符是“e”，因此调用charAt(1)就返回了“e”。如果你想得到的不是字符而是字符编码，那么就像下面这样使用charCodeAt()了。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charCodeAt(1));    // 输出&quot;101&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子输出的是“101”，也就是小写字母“e”的字符编码。<br></p>

<p><br>    ECMAScript 5还定义了另一个访问个别字符的方法，在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue(1));    // &quot;e&quot;</div></pre></td></tr></table></figure>
<p><br>    使用方括号表示法访问个别字符的语法得到了IE8及Firefox、Safari、Chrome和Opera所有版本的支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值(尽管根本不是特殊的undefined值)。<br></p>

<h4 id="2、字符串操作方法"><a href="#2、字符串操作方法" class="headerlink" title="2、字符串操作方法"></a>2、字符串操作方法</h4><p><br>    下面介绍与操作字符串有关的几个方法。第一个就是concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。先来看一个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello &quot;;</div><div class="line">var result = stringValue.concat(&quot;world&quot;);</div><div class="line">alert(result);         // &quot;hello world&quot;</div><div class="line">alert(stringValue);    // &quot;hello&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，通过stringValue调用concat()方法返回的结果是“hello world”——但stringValue的值则保持不变。实际上，concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。再看一个例子：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello &quot;;</div><div class="line">var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);</div><div class="line"></div><div class="line">alert(result);        // &quot;hello world!&quot;</div><div class="line">alert(stringValue);   // &quot;hello&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子将“world”和“！”拼接到了“hello”的末尾。虽然concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符(+)。而且，使用加号操作符在大多数情况下都比使用concat()方法要简便易行(特别是在拼接多个字符串的情况下)。<br></p>

<p><br>    ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(3));        // &quot;lo world&quot;</div><div class="line">alert(stringValue.substring(3));    // &quot;lo world&quot;</div><div class="line">alert(stringValue.substr(3));       // &quot;lo world&quot;</div><div class="line">alert(stringValue.slice(3, 7));     // &quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, 7)); // &quot;lo w&quot;</div><div class="line">alert(stringValue.substr(3, 7));    // &quot;lo worl&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子比较了以相同方式调用slice()、substr()和substring()得到的结果，而且多数情况下的结果是相同的。在只指定一个参数3的情况下，这三个方法都返回“lo world”，因为“hello”中的第二个“1”处于位置3.而在指定两个参数3和7的情况下，slice()和substring()返回“lo w”(“world”中的“o”处于位置7，因此结果中不包含“o”)，但substr()返回“lo worl”，因为它的第二个参数指定的是要返回的字符个数.<br></p>

<p><br>    在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.下面来看例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(-3));    // &quot;rld&quot;</div><div class="line">alert(stringValue.substring(-3));    // &quot;hello world&quot;</div><div class="line">alert(stringValue.substr(-3));       // &quot;rld&quot;</div><div class="line">alert(stringValue.slice(3, -4));     // &quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, -4)); // &quot;hel&quot;</div><div class="line">alert(stringValue.substr(3, -4));    // &quot;&quot;(空字符串)</div></pre></td></tr></table></figure>
<p><br>    这个例子清晰地展示了上述三个方法之间的不同行为。在给slice()和substr()传递一个负值参数时，它们的行为相同。这是因为-3会被转换为8(字符串长度加参数11+(-3)=8),实际上相当于调用slice(8)和substr(8).但substring()方法则返回了全部字符串，因为它将-3转换成了0.<br></p>

<blockquote>
<p>IE的JavaScript实现在处理向substr()方法传递负值的情况时存在问题，它会返回原始的字符串。IE9修复了这个问题。</p>
</blockquote>
<p><br>    当第二个参数是负值时，这三个方法的行为各不相同。slice()方法会把第二个参数转换为7，这就相当于调用了slice(3, 7),因此返回“lo w”。substring()方法会把第二个参数转换为0，使调用变成了substring(3, 0),而由于这个方法将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了substring(0, 3).substr()也会将第二个参数转换为0，这也就意味着返回包含零个字符的字符串，也就是一个空字符串。<br></p>

<h4 id="3、字符串位置方法"><a href="#3、字符串位置方法" class="headerlink" title="3、字符串位置方法"></a>3、字符串位置方法</h4><p><br>    有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf().这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置(如果没有找到该字符串，则返回-1)。这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。还是来看一个例子吧。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;));        // 4</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));    // 7</div></pre></td></tr></table></figure>
<p><br>    子字符串“o”第一次出现的位置是4，即“hello”中的“o”；最后一次出现的位置是7，即“world”中的“o”。如果“o”在这个字符串中仅出现了一次，那么indexOf()和lastIndexOf()会返回相同的位置值。<br></p>

<p><br>    这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;, 6));        // 7</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6));    // 4</div></pre></td></tr></table></figure>
<p><br>    在将第二个参数6传递给这两个方法之后，得到了与前面例子相反的结果。这一次，由于indexOf()是从位置6(字母”w”)开始向后搜索，结果在位置7找到了“o”，因此它返回7.而lastIndexOf()是从位置6开始向前搜索。结果找到了“hello”中的“o”，因此它返回4.在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串，如下面的例子所示：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;</div><div class="line">var positions = new Array();</div><div class="line">var pos = stringValue.indexOf(&quot;e&quot;);</div><div class="line"></div><div class="line">while(pos &gt; -1) &#123;</div><div class="line">	positions.push(pos);</div><div class="line">	pos = stringValue.indexOf(&quot;e&quot;, pos + 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(positions);    // &quot;3, 24, 32, 35, 52&quot;</div></pre></td></tr></table></figure>
<p><br>    这个例子通过不断增加indexOf()方法开始查找的位置，遍历了一个长字符串。在循环之外，首先找到了“e”在字符串中的初始位置；而进入循环之后，则每次都给indexOf()传递上一次的位置加1.这样，就确保了每次新搜索都从上一次找到的子字符串的后面开始。每次搜索返回的位置依次被保存在数组positions中，以便将来使用。<br></p>

<h4 id="4-trim-方法"><a href="#4-trim-方法" class="headerlink" title="4.trim()方法"></a>4.trim()方法</h4><p><br>    ECMAScript 5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;   hello world    &quot;;</div><div class="line">var trimmedStringValue = stringValue.trim();</div><div class="line">alert(stringValue);           // &quot;    hello world   &quot;</div><div class="line">alert(trimmedStringValue);    // &quot;hello world&quot;</div></pre></td></tr></table></figure>
<p><br>    由于trim()返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个方法的浏览器有IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和Chrome。此外，Firefox 3.5+、Safari 5+和Chrome 8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。<br></p>

<h4 id="5、字符串大小写转换方法"><a href="#5、字符串大小写转换方法" class="headerlink" title="5、字符串大小写转换方法"></a>5、字符串大小写转换方法</h4><p><br>    接下来要介绍的是一组与大小写转换有关的方法。ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase().其中，toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语)会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.toLocaleUpperCase());    // &quot;HELLO WORLD&quot;</div><div class="line">alert(stringValue.toUpperCase());          // &quot;HELLO WORLD&quot;</div><div class="line">alert(stringValue.toLocaleLowerCase());    // &quot;hello world&quot;</div><div class="line">alert(stringValue.toLowerCase());          // &quot;hello world&quot;</div></pre></td></tr></table></figure>
<p><br>    以上代码调用的toLocaleUpperCase()和toUpperCase()都返回了“HELLO WORLD”，就像调用toLocaleLowerCase()和toLowerCase()都返回“hello world”一样。一般来说，在不知道自己的代码将在那种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。<br></p>

<h4 id="6、字符串的模式匹配方法"><a href="#6、字符串的模式匹配方法" class="headerlink" title="6、字符串的模式匹配方法"></a>6、字符串的模式匹配方法</h4><p><br>    String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pattern = /.at/;</div><div class="line"></div><div class="line">// 与pattern.exec(text)相同</div><div class="line">var matches = text.match(pattern);</div><div class="line">alert(matches.index);        // 0</div><div class="line">alert(matches[0]);           // &quot;cat&quot;</div><div class="line">alert(pattern.lastIndex);    // 0</div></pre></td></tr></table></figure>
<p><br>    本例中的match()方法返回了一个数组；如果是调用RegExp对象的exec()方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串。<br></p>

<p><br>    另一个用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中的第一个匹配项的索引；如果没有找到匹配项，则返回-1.而且，search()方法始终是从字符串的开头向后查找模式。看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var pos = text.search(/at/);</div><div class="line">alert(pos);    // 1</div></pre></td></tr></table></figure>
<p><br>    这个例子中的search()方法返回1，即“at”在字符串中第一次出现的位置。<br></p>

<p><br>    为了简化替换子字符串的操作，ECMAScript提供了replace()方法。这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串(这个字符串不会被转换成正则表达式)，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局(g)标志，如下所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">var result = text.replace(&quot;at&quot;, &quot;ond&quot;);</div><div class="line">alert(result);    // &quot;cond, bat, sat, fat&quot;</div><div class="line"></div><div class="line">result = text.replace(/at/g, &quot;ond&quot;);</div><div class="line">alert(result);    // &quot;cond, bond, sond, fond&quot;</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，首先传入replace()方法的是字符串“at”和替换用的字符串“ond”。替换的结果是把“cat”变成了“cond”，但字符串中的其他字符并没有受到影响。然后，通过将第一个参数修改为带有全局标志的正则表达式，就将全部“at”都替换成了“ond”。<br></p>

<p><br>    如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">字符序列       替换文本</div><div class="line">$$             $</div><div class="line">$&amp;             匹配整个模式的子字符串。与RegExp.lastMatch的值相同</div><div class="line">$&apos;             匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</div><div class="line">$`             匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</div><div class="line">$n             匹配第n个捕获组的子字符串，其中n等于0-9.例如，$1是匹配第一个捕获组的子字符串，$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</div><div class="line">$nn            匹配第nn个捕获组的子字符串，其中nn等于01-99.例如，$01是匹配第一个捕获组的子字符串，$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串</div></pre></td></tr></table></figure>
<p><br>    通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat, bat, sat, fat&quot;;</div><div class="line">result = text.replace(/(.at)/g, &quot;word ($1)&quot;);</div><div class="line">alert(result);    // word(cat), word(bat), word(sat), word(fat)</div></pre></td></tr></table></figure>
<p><br>    在此，每个以“at”结尾的单词都被替换了，替换结果是“word”后跟一对圆括号，而圆括号中是被字符序列$1所替换的单词。<br></p>

<p><br>    replace()方法的第二个参数也可以是一个函数。在只有一个匹配项(即与模式匹配的字符串)的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作，请看下面这个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function htmlEscape(text) &#123;</div><div class="line">    return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, pos, originalText) &#123;</div><div class="line">        switch(match) &#123;</div><div class="line">            case &quot;&lt;&quot;:</div><div class="line">                return &quot;&amp;lt;&quot;;</div><div class="line">            case &quot;&gt;&quot;:</div><div class="line">                return &quot;&amp;gt;&quot;;</div><div class="line">            case &quot;&amp;&quot;:</div><div class="line">                return &quot;&amp;amp;&quot;;</div><div class="line">            case &quot;\&quot;&quot;:</div><div class="line">                return &quot;&amp;quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(htmlEscape(&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;));</div><div class="line">// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</div></pre></td></tr></table></figure>
<p><br>    这里，我们为插入HTML代码定义了函数htmlEscape()，这个函数能够转义4个字符：小于号、大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定HTML实体的函数。<br></p>

<p><br>    最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方法不会将字符串看成正则表达式)。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。请看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colorText = &quot;red, blue, green, yellow&quot;;</div><div class="line">var colors1 = colorText.split(&quot;,&quot;);    // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</div><div class="line">var colors2 = colorText.split(&quot;,&quot;, 2); // [&quot;red&quot;, &quot;blue&quot;]</div><div class="line">var colors3 = colorText.split(/[^\,]+/);    // [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，colorText是逗号分隔的颜色名字符串。基于该字符串调用split(“,”)会得到一个包含其中颜色名的数组，用于分割字符串的分隔符是逗号。为了将数组截短，让它只包含两项，可以为split()方法传递第二个参数2.最后，通过使用正则表达式，还可以取得包含逗号字符的数组。需要注意的是，在最后一次调用split()返回的数组中，第一项和最后一项是两个空字符串。之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头(即子字符串“red”)和末尾(即子字符串“yellow”)。<br></p>

<p><br>    对split()中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1) IE8及之前版本会忽略捕获组。ECMAScript-262规定应该把捕获组拼接到结果数组中。IE9中能正确地在结果中捕获组。</div><div class="line">2) Firefox 3.6及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262规定没有匹配项的捕获组在结果数组中应该用undefined表示。</div></pre></td></tr></table></figure>
<p><br>    在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览器下多做一些测试。<br></p>

<h4 id="7-localeCompare-方法"><a href="#7-localeCompare-方法" class="headerlink" title="7.localeCompare()方法"></a>7.localeCompare()方法</h4><p><br>    与操作字符串有关的最后一个方法是localeCompare(),这个方法比较两个字符串，并返回下列值中的一个：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数(大多数情况下是-1，具体的值要视实现而定)；</div><div class="line">2) 如果字符串等于字符串参数，则返回0；</div><div class="line">3) 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是1，具体的值同样要视实现而定)。</div></pre></td></tr></table></figure>
<p><br>    下面是几个例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;yellow&quot;;</div><div class="line">alert(stringValue.localeCompare(&quot;brick&quot;));    // 1</div><div class="line">alert(stringValue.localeCompare(&quot;yellow&quot;));   // 0</div><div class="line">alert(stringValue.localeCompare(&quot;zoo&quot;));      // -1</div></pre></td></tr></table></figure>
<p><br>    这个例子比较了字符串“yellow”和另外几个值：“brick”、“yellow”和“zoo”。因为“brick”在字母表中排在“yellow”之前，所以localeCompare()返回1；而“yellow”等于“yellow”，所以localeCompare()返回了0；最后，“zoo”在字母表中排在“yellow”后面，所以localeCompare()返回了-1.再强调一次，因为localeCompare()返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function determineOrder(value) &#123;</div><div class="line">    var result = stringValue.localeCompare(value);</div><div class="line">    if (result &lt; 0) &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; comes before the string &apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125; else if (result &gt; 0) &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; comes after the string &apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        alert(&quot;The string &apos;yellow&apos; is equal to the string&apos;&quot; + value + &quot;&apos;·&quot;);</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line">determineOrder(&quot;brick&quot;);</div><div class="line">determineOrder(&quot;yellow&quot;);</div><div class="line">determineOrder(&quot;zoo&quot;);</div></pre></td></tr></table></figure>
<p><br>    使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。<br></p>

<h3 id="1-6-单体内置对象"><a href="#1-6-单体内置对象" class="headerlink" title="1.6 单体内置对象"></a>1.6 单体内置对象</h3><p><br>    ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array和String。ECMA-262还定义了两个单体内置对象：Global和Math。<br></p>

<h3 id="1-6-1-Global对象"><a href="#1-6-1-Global对象" class="headerlink" title="1.6.1 Global对象"></a>1.6.1 Global对象</h3><p><br>    Global(全局)对象可以说是ECMAScript中最特别的一个独享了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。像isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global对象还包含其他一些方法。<br></p>

<h4 id="1-URI编码方法"><a href="#1-URI编码方法" class="headerlink" title="1.URI编码方法"></a>1.URI编码方法</h4><p><br>    Global对象的encodeURI()和encodeURIComponent()方法可以对URI(Uniform Resource Identifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如，空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。<br></p>

<p><br>    其中，encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var uri = &quot;http://www.wrox.com/illegal value.htm#start&quot;;</div><div class="line"></div><div class="line">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</div><div class="line">alert(encodeURI(uri));</div><div class="line"></div><div class="line">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</div><div class="line">alert(encodeURIComponent(uri));</div></pre></td></tr></table></figure>
<p><br>    使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20.而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正式可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。<br></p>

<blockquote>
<p>一般来说，我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。</p>
</blockquote>
<p><br>    与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。例如，它可将%20替换成一个空格，但不会对%23作任何处理，因为%23表示井字号(#)，而井字号不是使用encodeURI()替换的。同样地，decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。<br></p>

<h4 id="2-Global对象的属性"><a href="#2-Global对象的属性" class="headerlink" title="2.Global对象的属性"></a>2.Global对象的属性</h4><p><br>    特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下面列出了Global对象的所有属性。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-3.png"></p>
<p><br>    ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。<br></p>

<h4 id="4-window对象"><a href="#4-window对象" class="headerlink" title="4.window对象"></a>4.window对象</h4><p><br>    ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都称为了window对象的属性。来看下面的例子。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var color = &quot;red&quot;;</div><div class="line"></div><div class="line">function sayColor() &#123;</div><div class="line">	alert(window.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.sayColor();    // &quot;red&quot;</div></pre></td></tr></table></figure>
<p><br>    这里定义了一个名为color的全局变量和一个名为sayColor()的全局函数。在sayColor()内部，我们通过window.color来访问color变量，以说明全局变量是window对象的属性。然后，又使用window.sayColor()来直接通过window对象调用这个函数，结果显示在警告框中。<br></p>

<p><br>    另一种取得Global对象的方法是使用以下代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var global = function() &#123;</div><div class="line">    return this;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p><br>    以上代码创建了一个立即调用的函数表达式，返回this的值。。如前所述，在没有给函数明确指定this值的情况下(无论是通过将函数添加为对象的方法，还是通过调用call()或apply()),this值等于Global对象。而像这样通过简单地返回this来取得Global对象，在任何执行环境下都是可行的。<br></p>

<h3 id="1-6-2-Math对象"><a href="#1-6-2-Math对象" class="headerlink" title="1.6.2 Math对象"></a>1.6.2 Math对象</h3><p><br>    ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们在JavaScript直接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。Math对象中还提供了辅助完成这些计算的属性和方法。<br></p>

<h4 id="1-Math对象的属性"><a href="#1-Math对象的属性" class="headerlink" title="1.Math对象的属性"></a>1.Math对象的属性</h4><p><br>    Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-4.png"></p>
<h4 id="2-min-和max-方法"><a href="#2-min-和max-方法" class="headerlink" title="2.min()和max()方法"></a>2.min()和max()方法</h4><p><br>    Math对象还包含许多方法，用于辅助完成简单和复杂的数学计算。<br></p>

<p><br>    其中，min()和max()方法用于确定一组数值中的最大值和最小值。这两个方法都可以接收任意多个数值参数，如下面的例子所示。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var max = Math.max(3, 54, 32, 16);</div><div class="line">alert(max);    // 54</div><div class="line"></div><div class="line">var min = Math.min(3, 54, 32, 16);</div><div class="line">alert(min);    // 3</div></pre></td></tr></table></figure>
<p><br>    对于3、54、32和16，Math.max()返回54，而Math.min()返回3.这两个方法经常用于避免多余的循环和在if语句中确定一组数的最大值。<br></p>

<p><br>    要找到数组中的最大或最小值，可以像下面这样使用apply()方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var values = [1, 2, 3, 4, 5, 6, 7, 8];</div><div class="line">var max = Math.max.apply(Math, values);</div></pre></td></tr></table></figure>
<p><br>    这个技巧的关键是把Math作为apply()的第一个参数，从而正确地设置this值。然后，可以将任何数组作为第二个参数。<br></p>

<h4 id="3-舍入方法"><a href="#3-舍入方法" class="headerlink" title="3. 舍入方法"></a>3. 舍入方法</h4><p><br>    下面介绍将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round().这三个方法分别遵循下列舍入规则：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1) Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</div><div class="line">2) Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</div><div class="line">3) Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</div></pre></td></tr></table></figure>
<h4 id="4-random-方法"><a href="#4-random-方法" class="headerlink" title="4. random()方法"></a>4. random()方法</h4><p><br>    Math.random()方法返回大于等于0小于1的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。<br></p>

<p><br>    值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)<br></p>

<p><br>    公式中用到了Math.floor()方法，这是因为Math.random()总返回一个小数值。而用这个小数值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个1到10之间的数值，可以像下面这样编写代码：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = Math.floor(Math.random() * 10 + 1);</div></pre></td></tr></table></figure>
<p><br>    总共有10个可能的值（1到10），而第一个可能的值是1.而如果想要选择一个介于2到10之间的值，就应该将上面的代码改成这样：<br></p>

<p><br>    var num = Math.floor(Math.random() * 9 + 2);<br></p>

<p><br>    从2数到10要数9个数，因此可能值的总数就是9，而第一个可能的值就是2.多数情况下，其实都可以通过一个函数来计算可能值的总数和第一个可能的值，例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function selectFrom(lowerValue, upperValue) &#123;</div><div class="line">    var choices = upperValue - lowerValue + 1;</div><div class="line">    return Math.floor(Math.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var num = selectFrom(2, 10);</div><div class="line">alert(num);    // 介于2和10之间(包括2和10)的一个数值</div></pre></td></tr></table></figure>
<p><br>    函数selectFrom()接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加1得到了可能值的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用selectFrom(2, 10)就可以得到一个介于2和10之间(包括2和10)的数值了。利用这个函数，可以方便地从数组中随机取出一项。例如：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;];</div><div class="line">var color = colors[selectFrom(0, colors.length-1)];</div><div class="line">alert(color);    // 可能是数组中包含的任何一个字符串</div></pre></td></tr></table></figure>
<p><br>    在这个例子中，传递给selectFrom()的第二个参数是数组的长度减1，也就是数组中最后一项的位置。<br></p>

<h4 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5. 其他方法"></a>5. 其他方法</h4><p><br>    Math对象中还包含其他一些与完成各种简单或复杂计算有关的方法。下图，列出了这些没有介绍到的Math对象的方法。<br></p>

<p><img src="https://shaoqianheng.github.io/images/h-5-5.png"></p>
<p><br>    虽然ECMA-262规定了这些方法，但不同实现可能会对这些方法采用不同的算法。毕竟，计算某个值的正弦、余弦和正切的方式多种多样。也正是因为如此，这些方法在不同的实现中可能会有不同的精度。<br></p>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/29/引用类型（二）/" rel="next" title="引用类型（二）——JavaScript高级程序设计">
                <i class="fa fa-chevron-left"></i> 引用类型（二）——JavaScript高级程序设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/31/面向对象的程序设计（一）/" rel="prev" title="面向对象的程序设计（一）——JavaScript高级程序设计">
                面向对象的程序设计（一）——JavaScript高级程序设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="谦恒" />
          <p class="site-author-name" itemprop="name">谦恒</p>
           
              <p class="site-description motion-element" itemprop="description">苟日新 日日新 又日新</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-Boolean类型"><span class="nav-number">1.</span> <span class="nav-text">1.5.1 Boolean类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-Number类型"><span class="nav-number">2.</span> <span class="nav-text">1.5.2 Number类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-String类型"><span class="nav-number">3.</span> <span class="nav-text">1.5.3 String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2、字符串操作方法"><span class="nav-number">3.1.</span> <span class="nav-text">2、字符串操作方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、字符串位置方法"><span class="nav-number">3.2.</span> <span class="nav-text">3、字符串位置方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-trim-方法"><span class="nav-number">3.3.</span> <span class="nav-text">4.trim()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、字符串大小写转换方法"><span class="nav-number">3.4.</span> <span class="nav-text">5、字符串大小写转换方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、字符串的模式匹配方法"><span class="nav-number">3.5.</span> <span class="nav-text">6、字符串的模式匹配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-localeCompare-方法"><span class="nav-number">3.6.</span> <span class="nav-text">7.localeCompare()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-单体内置对象"><span class="nav-number">4.</span> <span class="nav-text">1.6 单体内置对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-Global对象"><span class="nav-number">5.</span> <span class="nav-text">1.6.1 Global对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-URI编码方法"><span class="nav-number">5.1.</span> <span class="nav-text">1.URI编码方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Global对象的属性"><span class="nav-number">5.2.</span> <span class="nav-text">2.Global对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-window对象"><span class="nav-number">5.3.</span> <span class="nav-text">4.window对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-Math对象"><span class="nav-number">6.</span> <span class="nav-text">1.6.2 Math对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Math对象的属性"><span class="nav-number">6.1.</span> <span class="nav-text">1.Math对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-min-和max-方法"><span class="nav-number">6.2.</span> <span class="nav-text">2.min()和max()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-舍入方法"><span class="nav-number">6.3.</span> <span class="nav-text">3. 舍入方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-random-方法"><span class="nav-number">6.4.</span> <span class="nav-text">4. random()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-其他方法"><span class="nav-number">6.5.</span> <span class="nav-text">5. 其他方法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谦恒</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
