<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="1.1 计时器    setTimeout()和setInterval()可以用来注册在指定的时间之后单次或重复调用的函数。它们都是客户端JavaScript中重要的全局函数，所以定义为Window对象的方法，但作为通用函数，其实不会对窗口做什么事情。      Window对象的setTimeout()方法用来实现一个函数在指定的毫秒数之后运行。setTimeout()返回一个值，这个值可以传递">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="Window对象(一)">
<meta property="og:url" content="http://yoursite.com/2017/08/21/window对象/index.html">
<meta property="og:site_name" content="谦恒-个人博客">
<meta property="og:description" content="1.1 计时器    setTimeout()和setInterval()可以用来注册在指定的时间之后单次或重复调用的函数。它们都是客户端JavaScript中重要的全局函数，所以定义为Window对象的方法，但作为通用函数，其实不会对窗口做什么事情。      Window对象的setTimeout()方法用来实现一个函数在指定的毫秒数之后运行。setTimeout()返回一个值，这个值可以传递">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-08-23T07:07:22.353Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Window对象(一)">
<meta name="twitter:description" content="1.1 计时器    setTimeout()和setInterval()可以用来注册在指定的时间之后单次或重复调用的函数。它们都是客户端JavaScript中重要的全局函数，所以定义为Window对象的方法，但作为通用函数，其实不会对窗口做什么事情。      Window对象的setTimeout()方法用来实现一个函数在指定的毫秒数之后运行。setTimeout()返回一个值，这个值可以传递">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/21/window对象/"/>





  <title>Window对象(一) | 谦恒-个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谦恒-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/21/window对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谦恒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦恒-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Window对象(一)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-21T17:26:26+08:00">
                2017-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="1-1-计时器"><a href="#1-1-计时器" class="headerlink" title="1.1 计时器"></a>1.1 计时器</h3><p><br>    setTimeout()和setInterval()可以用来注册在指定的时间之后单次或重复调用的函数。它们都是客户端JavaScript中重要的全局函数，所以定义为Window对象的方法，但作为通用函数，其实不会对窗口做什么事情。<br></p>

<p><br>    Window对象的setTimeout()方法用来实现一个函数在指定的毫秒数之后运行。setTimeout()返回一个值，这个值可以传递给clearTimeout()用于取消这个函数的执行。<br></p>

<p><br>    setInterval()和setTimeout()一样，只不过这个函数会在指定毫秒数的间隔里重复调用：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setInterval(updateClock, 60000);	// 每60秒调用一次updateClock()</div></pre></td></tr></table></figure>
<p><br>    和setTimeout()一样，setInterval()也返回一个值，这个值可以传递给clearInterval()，用于取消后续函数的调用。<br></p>

<p><br>    例1-1定义的应用函数会在等待指定的时间之后，开始重复调用某个函数，然后又过了一段时间之后取消函数调用。该例子演示了setTimeout()、setInterval()和clearInterval()的用法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">例1-1：定时器应用函数</div><div class="line">/*</div><div class="line">  安排函数f()在未来的调用模式在等待了若干毫秒</div><div class="line">  之后调用f()，如果设置了interval并没有设置end</div><div class="line">  参数，则对f()调用将不会停止，如果没有设置interval</div><div class="line">  和end，只在若干毫秒后调用f()一次，只有指定了</div><div class="line">  f(),才会从start=0的时刻开始。注意，调用invoke()</div><div class="line">  不会阻塞，它会立即返回。</div><div class="line">*/</div><div class="line">function invoke(f, start, interval, end) &#123;</div><div class="line">    if (!start) start = 0;	// 默认设置为0毫秒</div><div class="line">    if (arguments.length &lt;= 2)	// 单次调用模式</div><div class="line">        setTimeout(f, start);	// 若干毫秒后的单次调用模式</div><div class="line">    else &#123;		// 多次调用模式</div><div class="line">        setTimeout(repeat, start);	// 在若干毫秒后调用repeat()</div><div class="line">        function repeat () &#123;	// 在上一行所示的setTimeout()中调用</div><div class="line">            var h = setInterval(f, interval);	// 循环调用f()</div><div class="line">            // 在end毫秒后停止调用，前提是end已经定义了</div><div class="line">            if (end) setTimeout(function () &#123; clearInterval(h); &#125;, end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br>    由于历史原因，setTimeout()和setInterval()的第一个参数可以作为字符串传入。如果这么做，那这个字符串会在指定的超时时间或间隔时间之后进行求值(相当于执行eval())，除前两个参数之外，HTML5规范(除IE之外的所有浏览器)还允许setTimeout()和setInterval()传入额外的参数，并在调用函数时把这些参数传递过去，然而，如果需要支持IE的话，就不要应用此特性了。<br></p>

<p><br>    如果以0毫秒的超时时间来调用setTimeout(),那么指定的函数不会立刻执行。相反，会把它放到队列中，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。<br></p>

<h3 id="1-2-浏览器定位和导航"><a href="#1-2-浏览器定位和导航" class="headerlink" title="1.2 浏览器定位和导航"></a>1.2 浏览器定位和导航</h3><p><br>    Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL，并定义了方法来使窗口载入新的文档。<br></p>

<p><br>    Document对象的location属性也引用到Location对象：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.location === document.location 	// 总是返回true</div></pre></td></tr></table></figure>
<p><br>    Document对象也有一个URL属性，是文档首次载入后保存该文档的URL的静态字符串。如果定位到文档中的片段标识符(如#table-of-contents),Location对象会做相应的更新，而document.URL属性却不会改变。<br></p>

<h3 id="1-2-1-解析URL"><a href="#1-2-1-解析URL" class="headerlink" title="1.2.1 解析URL"></a>1.2.1 解析URL</h3><p><br>    Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL。Location对象的href属性是一个字符串，后者包含URL的完整文本。Location对象的toString()方法返回href属性的值，因此在会隐式调用toString()的情况下，可以使用location代替location.href.<br></p>

<p><br>    这个对象的其他属性——protocol，host，hostname，port，pathname和search，分别表示URL的各个部分。它们称为“URL分解”属性，同时被Link对象(通过HTML文档中的<a>和<area>元素创建)支持。<br></a></p>

<p><br>    Location对象的hash和search属性比较有趣。如果有的话，hash属性返回URL中的“片段标识符”部分。search属性也类似，它返回的是问好之后的URL，这部分通常是某种类型的查询字符串。一般来说，这部分内容是用来参数化URL并在其中嵌入参数的。虽然这些参数通常用于运行在服务器上的脚本，但在启用JavaScript的页面中当然也可以使用它们。例1-2展示了一个通用函数urlArgs()的定义，可以用这个函数将参数从URL的search属性中提取出来。该例子用到了decodeURIComponent(),后者是在客户端JavaScript定义的全局函数。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">例1-2：提取URL的搜索字符串中的参数</div><div class="line">/*</div><div class="line">  这个函数用来解析来自URL的查询串中的name=value参数对</div><div class="line">  它将name=value对存储在一个对象的属性中，并返回该对象</div><div class="line">  这样来使用它</div><div class="line"></div><div class="line">  var args = urlArgs();	// 从URL中解析参数</div><div class="line">  var q = args.q || &quot;&quot;;	// 如果参数定义了的话就使用参数；否则使用一个默认值</div><div class="line">  var n = args.n ? parseInt(args.n) : 10;</div><div class="line">*/</div><div class="line">function urlArgs () &#123;</div><div class="line">    var args = &#123;&#125;;		// 定义一个空对象</div><div class="line">    var query = location.search.substring(1);	// 查找到查询串，并去掉&apos;?&apos;</div><div class="line">    var pairs = query.split(&apos;&amp;&apos;);	// 根据“&amp;”符号将查询字符串分隔开</div><div class="line">    for (var i = 0; i &lt; pairs.length; i++) &#123;	// 对于每个片段</div><div class="line">        var pos = pairs[i].indexOf(&apos;=&apos;);	// 查找“name=value”</div><div class="line">        if (pos === -1) continue;	// 如果没有找到的话，就跳过</div><div class="line">        var name = pairs[i].substring(0, pos);	// 提取name</div><div class="line">        var value = pairs[i].substring(pos + 1);	// 提取value</div><div class="line">        value = decodeURIComponent(value);	// 对value进行解码</div><div class="line">        args[name] = value;		// 存储为属性</div><div class="line">    &#125;</div><div class="line">    return args;	// 返回解析后的参数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-2-载入新的文档"><a href="#1-2-2-载入新的文档" class="headerlink" title="1.2.2 载入新的文档"></a>1.2.2 载入新的文档</h3><p><br>    Location对象的assign()方法可以使窗口载入并显示你指定的URL中的文档。replace()方法也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。如果脚本无条件地载入一个新文档，replace()方法可能是比assign()方法更好的选择。否则，“后退”按钮会把浏览器带回到原始文档，而相同的脚本则会再次载入新文档。如果检测到用户的浏览器不支持某些特性来显示功能齐全的版本，可以用location.replace()来载入动态的HTML版本。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 如果浏览器不支持XMLHttpRequest对象</div><div class="line">// 则将其重定向到一个不需要Ajax的静态页面</div><div class="line">if (!XMLHttpRequest) location.replace(&apos;staticpage.html&apos;);</div></pre></td></tr></table></figure>
<p><br>    注意，在这个例子中传入replace()的是一个相对URL。相对URL是相对于当前页面所在的目录来解析的，就像它们用于一个超链接中。<br></p>

<p><br>    除了assign()和replace()方法，location对象还定义了reload()方法，后者可以让浏览器重新载入当前文档。<br></p>

<p><br>    使浏览器跳转到新页面的一种更传统的方法是直接把新的URL赋给location属性：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = &quot;http://www.oreilly.com&quot;;</div></pre></td></tr></table></figure>
<p><br>    还可以把相对URL赋给location，它们会相对当前URL进行解析：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = &quot;page2.html&quot;;	// 载入下一个页面</div></pre></td></tr></table></figure>
<p><br>    纯粹的片段标识符是相对URL的一种类型，它不会让浏览器载入新文档，但只会使它滚动到文档的某个位置。#top标识符是个特殊的例子：如果文档中没有元素的ID是“top”，它会让浏览器跳到文档开始处。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = “#top”;	// 跳转到文档的顶部</div></pre></td></tr></table></figure>
<p><br>    Location对象的URL分解属性是可写的，对它们重新赋值会改变URL的位置，并且导致浏览器载入一个新的文档(如果改变的是hash属性，则在当前文档中进行跳转)：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.search = &quot;?page=&quot; + (pagenum + 1);	// 载入下一个页面</div></pre></td></tr></table></figure>
<h3 id="1-3-浏览历史"><a href="#1-3-浏览历史" class="headerlink" title="1.3 浏览历史"></a>1.3 浏览历史</h3><p><br>    Window对象的history属性引用的是该窗口的History对象。History对象是用来把窗口的浏览历史用文档和文档状态列表的形式表示。History对象的length属性表示浏览历史列表中的元素数量，但出于安全的因素，脚本不能访问已保存的URL。(如果允许，则任意脚本都可以窥探你的浏览历史.)<br></p>

<p><br>    History对象的back()和forward()方法与浏览器的“后退”和“前进”按钮一样：它们使浏览器在浏览历史中前后跳转一格。第三个方法——go()接受一个整数参数，可以在历史列表中向前(正参数)或向后(负参数)跳过任意多个页。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.go(-2);	// 后退两个历史记录，相当于单击“后退”按钮两次</div></pre></td></tr></table></figure>
<p><br>    如果窗口包含多个子窗口(比如iframe元素)，子窗口的浏览历史会按时间顺序穿插在主窗口的历史中。这意味着在主窗口调用history.back()(举例)可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变。<br></p>

<p><br>    现代Web应用可以不通过载入新文档而动态地改变自身内容。这么做可能希望用户能用“后退”和“前进”按钮在这些动态创建的应用状态之间进行跳转。HTML5将这种技术标准化。<br></p>

<p><br>    HTML5之前的历史管理是个更复杂的难题。应用程序必须要在窗口浏览历史中创建一个新的条目来管理自身的历史记录，用历史条目关联自身的状态信息，判断什么时候用户使用了“后退”按钮来移动到不同的历史条目，联合那个条目获取状态信息，并且重新创建应用程序之前的状态。一种方式是用隐藏的iframe来保存状态信息并在浏览器的历史中创建条目。为了创建新的历史条目，需要用Document对象的open()和write()方法动态地把一个新文档写入这个隐藏的窗体。不管怎样，文档内容应该包含重新创建应用状态所需要的状态信息。当用户点击“后退”按钮，隐藏的窗体的内容会改变。在HTML5之前，没有生成事件来通知你这个改变，因此，为了检测用户是否单击了“后退”按钮，可能要用setInterval()每秒对隐藏的窗体检测两到三次，来看它是否改变了。<br></p>

<h3 id="用HTML5进行历史管理"><a href="#用HTML5进行历史管理" class="headerlink" title="用HTML5进行历史管理"></a>用HTML5进行历史管理</h3><p><br>    Web浏览器会记录一个窗口中载入的所有文档，同时提供了“后退”和“前进”按钮，允许用户在这些文档之间切换浏览。这种浏览器历史记录模型最早在“文档都是被动的，所有的计算都在服务器上完成”那个时期就已经存在了。如今，Web应用通常都是动态地生成或载入页面内容，并在无须刷新页面的情况下就显示新的应用状态。如果想要提供用户能够通过浏览器的“后退”和“前进”按钮，直观的切换应用状态，像这类应用就必须自己处理应用的历史记录管理。HTML5定义了两种用于历史记录管理的机制。<br></p>

<p><br>    其中比较简单的历史记录管理技术就是利用location.hash和hashchange事件。截至撰写本书时，这种技术一直也是比较广泛实现的：浏览器甚至在HTML5标准化之前就已经开始实现该技术了。在绝大多数浏览器中(IE早期版本除外)，设置location.hash属性会更新显示在地址栏中的URL，同时会在浏览器的历史记录中添加一条记录。hash属性设置URL的片段标识符，通常用于指定要滚动到的文档中某一部分的ID。但是location.hash不一定非要设置为一个元素的ID：它可以设置成任何的字符串。如果能够将应用状态编码成一个字符串，就可以使用该字符串作为片段标识符。<br></p>

<p><br>    设置了location.hash属性后，接下来要实现允许用户通过“后退”和“前进”按钮来切换不同的文档状态。这个时候，应用必须要想办法检测状态变化，以便它能够读取出存储在片段标识符中的状态并相应地更新自己的状态。支持HTML5的浏览器一旦发现片段标识符发生了改变，就会在Window对象上触发一个hashchange事件。这样，在支持hashchange事件的浏览器中，就可以通过设置window.onhashchange为一个处理程序函数，使得每次由于切换历史记录导致片段标识符变化的时候，都会调用该处理程序函数。当调用该处理程序函数的时候，就可以对location.hash的值进行解析，然后使用该值包含的状态信息来重新显示应用。<br></p>

<p><br>    HTML5还定义了一个相对更复杂和强健的历史记录管理方法，该方法包含history。pushState()方法和popstate事件。当一个Web应用进入一个新的状态的时候，它会调用history.pushState()方法将该状态添加到浏览器的浏览历史记录中。该方法的第一个参数是一个对象，该对象包含用于恢复当前文档状态所需的所有信息。该对象可以是任何能够通过JSON.stringify()方法转换成相应字符串形式的对象，也可以是其他类似Date和RegExp这样特定的本地类型。该方法的第二个可选参数是一个可选的标题(普通的文本字符串)，浏览器可以使用它(比如，在一个<back>菜单中)来标识浏览历史记录中保存的状态。该方法的第三个参数是一个可选的URL，表示当前状态的位置。相对的URL都是以文档的当前位置为参照，通常该URL只是简单地指定URL(诸如#state)这样的hash(或者“片段标识符”)部分。将一个URL和状态关联，可以允许用户将应用的内部状态作为书签添加到浏览器中，并当URL中包含足够信息的时候，应用可以在从书签中载入的时候就恢复它的状态。<br></back></p>

<p><br>    除了pushState()方法之外，History对象还定义了replaceState()方法，该方法和pushState()方法接收同样的参数，但是不同的是，它不是将新的状态添加到浏览器的历史记录中，而是用新的状态代替当前的历史状态。<br></p>

<p><br>    当用户通过“后退”和“前进”按钮浏览保存的历史状态时，浏览器会在Window对象上触发一个popstate事件。与该事件相关联的事件对象有一个state属性，该属性包含传递给pushState()方法的状态对象的副本(另一种结构性复制)。<br></p>

<blockquote>
<p>结构性复制：正如上面提到的，pushState()方法接受一个状态对象并为该对象创建一份私有副本。这是对一个对象进行深拷贝或者深复制：它会递归地复制所有嵌套对象或者数组的内容。HTML5标准将这类复制称为“结构性复制”(structured clone)。创建一个结构性复制的过程就好比是将一个对象传递给JSON.stringify()方法，然后再将结果字符串传递给JSON.parse()方法。但是JSON只支持JavaScript的基础类型和对象以及数组。在HTML5标准中提到，结构性复制算法必须还能够复制Date对象、RegExp对象、ImageData对象、FileList对象、File对象以及Blob对象。但是在结构性复制算法中会显式排除JavaScript中的函数和错误以及绝大部分诸如窗口、文档、元素等这类宿主对象。</p>
</blockquote>
<h3 id="1-4-浏览器和屏幕信息"><a href="#1-4-浏览器和屏幕信息" class="headerlink" title="1.4 浏览器和屏幕信息"></a>1.4 浏览器和屏幕信息</h3><blockquote>
<p>脚本有时候需要获取和它们所在的Web浏览器或浏览器所在的桌面相关信息。将要介绍Window对象的navigator和screen属性。它们分别引用的是Navigator和Screen对象，而这些对象提供的信息允许脚本来根据环境定制自己的行为。</p>
</blockquote>
<h3 id="1-4-1-Navigator对象"><a href="#1-4-1-Navigator对象" class="headerlink" title="1.4.1 Navigator对象"></a>1.4.1 Navigator对象</h3><p><br>    Window对象的navigator属性引用的是包含浏览器厂商和版本信息的Navigator对象。Navigator对象的命名是为了纪念Netscape之后Navigator浏览器，不过所有其他的浏览器也支持它(IE还支持clientInformation属性，它作为navigator的厂商中立同义词。遗憾的是，其他浏览器并不支持这一更直观的属性命名)。<br></p>

<p><br>    过去，Navigator对象通常被脚本用来确定它们是在IE中还是在Netscape中运行。这种浏览器嗅探方法有问题，因为它要求随着新浏览器和现有浏览器的新版本的引入而不断地调整。如今，有一种更好的功能测试方法，只需要测试所需要的功能(即，方法或属性)，而不是假设特定的浏览器版本及其功能。<br></p>

<p><br>    然而，浏览器嗅探有时候仍然有价值。这样的一种情况是，当需要解决存在于某个特定的浏览器的特定版本中的特殊的bug时。Navigator对象有4个属性用于提供关于运行中的浏览器的版本信息，并且可以使用这些属性进行浏览器嗅探。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">appName</div><div class="line">    Web浏览器的全称。在IE中，这就是“Microsoft Internet Explorer”。在Firefox中，该属性就是“Netscape”。为了兼容现存的浏览器的嗅探代码，其他浏览器通常也取值为“Netscape”。</div><div class="line"></div><div class="line">appVersion</div><div class="line">    此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是4.0或5.0，表示它是第4或第5代兼容的浏览器。appVersion字符串没有标准的格式，所以，没有办法直接用它来判断浏览器的类型。</div><div class="line"></div><div class="line">userAgent</div><div class="line">    浏览器在它的USER-AGENT HTTP头部中发送的字符串。这个属性通常包含appVersion中的所有信息，并且常常也可能包含其他的细节。和appVersion一样，它也没有标准的格式。由于这个属性包含绝大部分信息，因此浏览器嗅探代码通常用它来嗅探。</div><div class="line"></div><div class="line">platform</div><div class="line">    在其上运行浏览器的操作系统(并且可能是硬件)的字符串。</div></pre></td></tr></table></figure>
<p><br>    Navigator属性的复杂性正说明了浏览器嗅探对于处理客户端兼容性问题是没有太大帮助的。在Web的早期，人们写了大量的浏览器特定代码用于测试类似于navigator.appName的属性。在开发新浏览器的时候，浏览器厂商发现为了让现有网站显示正确，它们需要把appName设置为“Netscape”。类似的做法使得appVersion的起始数字失去了意义，而现在的浏览器嗅探代码必须要依赖于比之前复杂很多的navigator.userAgent字符串。例1-3展示了如何使用正则表达式(摘自jQuery)从navigator.userAgent中抽取浏览器名称和版本号的方法。<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">例1-3：使用navigator.userAgent来进行浏览器嗅探</div><div class="line">// 为客户端嗅探定义browser.name和browser.version,这里使用了jQuery1.4.1中的代码</div><div class="line">// name和number都是字符串，对于不同的浏览器输出的结果也是不一样的，检测结果如下：</div><div class="line">//</div><div class="line">// &quot;webkit&quot;：Safari或Chrome;版本号是Webkit的版本号</div><div class="line">// &quot;opera&quot;：Opera;版本号就是软件的版本号</div><div class="line">// &quot;mozilla&quot;：Firefox或者其他基于gecko内核的浏览器;版本号是Gecko的版本</div><div class="line">// &quot;msie&quot;：IE;版本号就是软件的版本</div><div class="line">//</div><div class="line">// 比如Firefox 3.6返回：&#123; name：“mozilla”，version：“1.9.2” &#125;</div><div class="line">var browser = (function() &#123;</div><div class="line">    var s = navigator.userAgent.toLowerCase();</div><div class="line">    var match = /(webkit)[\/]([\w.]+)/.exec(s) ||</div><div class="line">	    /(opera)(?:.*version)?[\/]([\w.]+)/.exec(s) ||</div><div class="line">	    /(mise)([\w.]+)/.exec(s) ||</div><div class="line">	    !/compatible/.test(s) &amp;&amp; /(mozilla)(?:.*? rv:([\w.]+))?/.exec(s) ||</div><div class="line">	    [];</div><div class="line"></div><div class="line">    return &#123; name: match[1] || &quot;&quot;, version: match[2] || &quot;0&quot; &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p><br>    除了浏览器厂商和版本信息的属性之外，Navigator对象还包含一些杂项的属性和方法。以下是一些标准化的属性以及广泛应用但未标准化的属性：<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">onLine</div><div class="line">    navigator.onLine属性(如果存在的话)表示浏览器当前是否连接到网络。应用程序可能希望在离线状态下把状态保存在本地。</div><div class="line"></div><div class="line">geolocation</div><div class="line">    Geolocation对象定义用于确定用户地理位置信息的接口。</div><div class="line"></div><div class="line">javaEnabled()</div><div class="line">    一个非标准的方法，当浏览器可以运行Java小程序时返回true。</div><div class="line">    </div><div class="line">cookieEnable()</div><div class="line">    非标准的方法，如果浏览器可以保存永久的cookie时，返回true。当cookie配置为“视具体情况而定”时可能会返回不正确的值。</div></pre></td></tr></table></figure>
<h3 id="1-4-2-Screen对象"><a href="#1-4-2-Screen对象" class="headerlink" title="1.4.2 Screen对象"></a>1.4.2 Screen对象</h3><p><br>    Window对象的screen属性引用的是Screen对象。它提供有关窗口显示的大小和可用的颜色数量的信息。属性width和height指定的是以像素为单位的窗口大小。属性availWidth和availHeight指定的实际可用的显示大小，它们排除了像桌面任务栏这样的特性所占用的空间。属性colorDepth指定的是显示BPP(bits-per-pixel)值,典型的值有16、24和32.<br></p>

<p><br>    window.screen属性和它引用的Screen对象都是非标准但广泛实现的。可以用Screen对象来确定Web应用是否运行在一个小屏幕的设备上，比如上网本。如果屏幕空间有限，可能要选择用更小的字体和图片等。<br></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/20/浮动概述/" rel="next" title="浮动概述">
                <i class="fa fa-chevron-left"></i> 浮动概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/23/window对象（2）/" rel="prev" title="Window对象(二)">
                Window对象(二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="谦恒" />
          <p class="site-author-name" itemprop="name">谦恒</p>
           
              <p class="site-description motion-element" itemprop="description">苟日新 日日新 又日新</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-计时器"><span class="nav-number">1.</span> <span class="nav-text">1.1 计时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-浏览器定位和导航"><span class="nav-number">2.</span> <span class="nav-text">1.2 浏览器定位和导航</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-解析URL"><span class="nav-number">3.</span> <span class="nav-text">1.2.1 解析URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-载入新的文档"><span class="nav-number">4.</span> <span class="nav-text">1.2.2 载入新的文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-浏览历史"><span class="nav-number">5.</span> <span class="nav-text">1.3 浏览历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用HTML5进行历史管理"><span class="nav-number">6.</span> <span class="nav-text">用HTML5进行历史管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-浏览器和屏幕信息"><span class="nav-number">7.</span> <span class="nav-text">1.4 浏览器和屏幕信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-Navigator对象"><span class="nav-number">8.</span> <span class="nav-text">1.4.1 Navigator对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-Screen对象"><span class="nav-number">9.</span> <span class="nav-text">1.4.2 Screen对象</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谦恒</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
